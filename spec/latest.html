<!DOCTYPE html><html lang="en"><head>
<meta charset="utf-8">
<meta name="generator" content="ReSpec 34.4.0">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<style>
span.example-title{text-transform:none}
:is(aside,div).example,div.illegal-example{padding:.5em;margin:1em 0;position:relative;clear:both}
div.illegal-example{color:red}
div.illegal-example p{color:#000}
:is(aside,div).example{border-left-width:.5em;border-left-style:solid;border-color:#e0cb52;background:#fcfaee}
aside.example div.example{border-left-width:.1em;border-color:#999;background:#fff}
.example pre{background-color:rgba(0,0,0,.03)}
</style>
<style>
.issue-label{text-transform:initial}
.warning>p:first-child{margin-top:0}
.warning{padding:.5em;border-left-width:.5em;border-left-style:solid}
span.warning{padding:.1em .5em .15em}
.issue.closed span.issue-number{text-decoration:line-through}
.issue.closed span.issue-number::after{content:" (Closed)";font-size:smaller}
.warning{border-color:#f11;border-width:.2em;border-style:solid;background:#fbe9e9}
.warning-title:before{content:"⚠";font-size:1.3em;float:left;padding-right:.3em;margin-top:-.3em}
li.task-list-item{list-style:none}
input.task-list-item-checkbox{margin:0 .35em .25em -1.6em;vertical-align:middle}
.issue a.respec-gh-label{padding:5px;margin:0 2px 0 2px;font-size:10px;text-transform:none;text-decoration:none;font-weight:700;border-radius:4px;position:relative;bottom:2px;border:none;display:inline-block}
</style>
<style>
dfn{cursor:pointer}
.dfn-panel{position:absolute;z-index:35;min-width:300px;max-width:500px;padding:.5em .75em;margin-top:.6em;font-family:"Helvetica Neue",sans-serif;font-size:small;background:#fff;color:#000;box-shadow:0 1em 3em -.4em rgba(0,0,0,.3),0 0 1px 1px rgba(0,0,0,.05);border-radius:2px}
.dfn-panel:not(.docked)>.caret{position:absolute;top:-9px}
.dfn-panel:not(.docked)>.caret::after,.dfn-panel:not(.docked)>.caret::before{content:"";position:absolute;border:10px solid transparent;border-top:0;border-bottom:10px solid #fff;top:0}
.dfn-panel:not(.docked)>.caret::before{border-bottom:9px solid #a2a9b1}
.dfn-panel *{margin:0}
.dfn-panel b{display:block;color:#000;margin-top:.25em}
.dfn-panel ul a[href]{color:#333}
.dfn-panel>div{display:flex}
.dfn-panel a.self-link{font-weight:700;margin-right:auto}
.dfn-panel .marker{padding:.1em;margin-left:.5em;border-radius:.2em;text-align:center;white-space:nowrap;font-size:90%;color:#040b1c}
.dfn-panel .marker.dfn-exported{background:#d1edfd;box-shadow:0 0 0 .125em #1ca5f940}
.dfn-panel .marker.idl-block{background:#8ccbf2;box-shadow:0 0 0 .125em #0670b161}
.dfn-panel a:not(:hover){text-decoration:none!important;border-bottom:none!important}
.dfn-panel a[href]:hover{border-bottom-width:1px}
.dfn-panel ul{padding:0}
.dfn-panel li{margin-left:1em}
.dfn-panel.docked{position:fixed;left:.5em;top:unset;bottom:2em;margin:0 auto;max-width:calc(100vw - .75em * 2 - .5em - .2em * 2);max-height:30vh;overflow:auto}
</style>
  

  
<title>SPARQL CDTs: Representing and Querying Lists and Maps as RDF Literals</title>
  
  
  
<style>

    /* copied from TR/turtle, and adapted for SPARQL rules */
    .grammar td { font-family: monospace; vertical-align: top; }
    .grammar-literal, .token { color: gray;}
    .grammar_comment { color: #A52A2A; font-style: italic; }

    /* better looking quoted examples */
    .example .example {
      border-left-width: .15em;
    }

    /* better numbering of algorithm steps */
    .algorithm ol {
      counter-reset: numsection;
      list-style-type: none;
    }
    .algorithm ol>li {
      margin: 0.5em 0;
    }
    .algorithm ol>li:before {
      font-weight: bold;
      counter-increment: numsection;
      content: counters(numsection, ".") ") ";
    }

    /* SPARQL modification section */

    .defn	{ 
/*         margin-left:5% ; margin-right: 7%;  */
        margin-top: 0.1ex ; margin-bottom: 0.1ex ;
        border: thin solid #888888;
        padding: 1ex 2ex 0.5ex 2ex ;
        page-break-inside: avoid ;
        background-color: #F0F8F8 ;
    }
    
    div.defn p	{ margin-top: 1ex ; margin-bottom: 1.5ex ;}
    div.defn ul	{ margin-top: 1ex ; margin-bottom: 1.5ex ; }

    .operator {
        border: solid;
        border-width: 1px;
        border-color: #888;
        width: 100%;
        margin: 0px;
    }

    .operator tr {
        border: solid;
        border-color: #888;
        border-width: 1px;
    }
    
    .operator th {
        border: solid;
        border-color: #888;
        border-width: 1px;
        font-weight: bold;
    }

    .operator td {
        border: solid;
        border-color: #888;
        border-width: 1px;
    }

    .inscope {
        border-collapse: collapse;
    }

    .inscope th {
        border: solid;
        border-width: 1px;
        font-weight: bold;
        padding-left:  10px;
        padding-right: 10px;
    }

    .inscope td {
        border: solid;
        border-width: 1px;
        padding-left:  10px;
        padding-right: 10px;
    }

    .sparqlresult {
        border: solid;
        border-width: 1px;
        border-collapse: collapse;
    }

    .sparqlresult th {
        border: solid;
        border-width: 1px;
        font-weight: bold;
        padding-left:  1ex;
        padding-right: 1ex;
    }

    .sparqlresult td {
        border: solid;
        border-width: 1px;
        padding-left:  1ex;
        padding-right: 1ex;
    }
    
    .heavy { color:black; font-weight:bold }
    .small { font-size: smaller; }

    #structure-map table {
      background-image: url("visual-map-bg.svg");
      background-size: 100% 100%;
      background-repeat: no-repeat;
    }

    #structure-map table td {
      width: 33.34%;
    }

    #structure-map .box {
      display: block;
      border: thin solid gray;
      border-radius: 0.5em;
      background-color: white;
      margin: 0.7em 1em;
      padding: 0.35em 0.5em;
      box-shadow: 0.25em 0.25em 0.5em darkgray;
      text-align: center;
    }

    /* remove "unofficial draft" watermark */
    body.no-watermark {
      background: url('https://www.w3.org/StyleSheets/TR/2016/logos/back-cg-draft') no-repeat !important
    }
  
</style>
  
<script>
    /* copied from JSON-LD specs */
    function updateExample(doc, content) {
      // perform transformations to make it render and prettier
      return _esc(reindent(unComment(doc, content)));
    }

    function _esc(s) {
      return s.replace(/&/g,'&amp;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/</g,'&lt;');
    }

    function reindent(text) {
      // TODO: use trimEnd when Edge supports it
      const lines = text.trimRight().split("\n");
      while (lines.length && !lines[0].trim()) {
        lines.shift();
      }
      const indents = lines.filter(s => s.trim()).map(s => s.search(/[^\s]/));
      const leastIndent = Math.min(...indents);
      return lines.map(s => s.slice(leastIndent)).join("\n");
    }

    function unComment(doc, content) {
      // perform transformations to make it render and prettier
      return content
        .replace(/<!--/, '')
        .replace(/-->/, '')
        .replace(/< !\s*-\s*-/g, '<!--')
        .replace(/-\s*- >/g, '-->')
        .replace(/-\s*-\s*&gt;/g, '--&gt;');
    }
  </script>

<style id="respec-mainstyle">
@keyframes pop{
0%{transform:scale(1,1)}
25%{transform:scale(1.25,1.25);opacity:.75}
100%{transform:scale(1,1)}
}
:is(h1,h2,h3,h4,h5,h6,a) abbr{border:none}
dfn{font-weight:700}
a.internalDFN{color:inherit;border-bottom:1px solid #99c;text-decoration:none}
a.externalDFN{color:inherit;border-bottom:1px dotted #ccc;text-decoration:none}
a.bibref{text-decoration:none}
.respec-offending-element:target{animation:pop .25s ease-in-out 0s 1}
.respec-offending-element,a[href].respec-offending-element{text-decoration:red wavy underline}
@supports not (text-decoration:red wavy underline){
.respec-offending-element:not(pre){display:inline-block}
.respec-offending-element{background:url(data:image/gif;base64,R0lGODdhBAADAPEAANv///8AAP///wAAACwAAAAABAADAEACBZQjmIAFADs=) bottom repeat-x}
}
#references :target{background:#eaf3ff;animation:pop .4s ease-in-out 0s 1}
cite .bibref{font-style:normal}
a[href].orcid{padding-left:4px;padding-right:4px}
a[href].orcid>svg{margin-bottom:-2px}
.toc a,.tof a{text-decoration:none}
a .figno,a .secno{color:#000}
ol.tof,ul.tof{list-style:none outside none}
.caption{margin-top:.5em;font-style:italic}
table.simple{border-spacing:0;border-collapse:collapse;border-bottom:3px solid #005a9c}
.simple th{background:#005a9c;color:#fff;padding:3px 5px;text-align:left}
.simple th a{color:#fff;padding:3px 5px;text-align:left}
.simple th[scope=row]{background:inherit;color:inherit;border-top:1px solid #ddd}
.simple td{padding:3px 10px;border-top:1px solid #ddd}
.simple tr:nth-child(even){background:#f0f6ff}
.section dd>p:first-child{margin-top:0}
.section dd>p:last-child{margin-bottom:0}
.section dd{margin-bottom:1em}
.section dl.attrs dd,.section dl.eldef dd{margin-bottom:0}
#issue-summary>ul{column-count:2}
#issue-summary li{list-style:none;display:inline-block}
details.respec-tests-details{margin-left:1em;display:inline-block;vertical-align:top}
details.respec-tests-details>*{padding-right:2em}
details.respec-tests-details[open]{z-index:999999;position:absolute;border:thin solid #cad3e2;border-radius:.3em;background-color:#fff;padding-bottom:.5em}
details.respec-tests-details[open]>summary{border-bottom:thin solid #cad3e2;padding-left:1em;margin-bottom:1em;line-height:2em}
details.respec-tests-details>ul{width:100%;margin-top:-.3em}
details.respec-tests-details>li{padding-left:1em}
.self-link:hover{opacity:1;text-decoration:none;background-color:transparent}
aside.example .marker>a.self-link{color:inherit}
.header-wrapper{display:flex;align-items:baseline}
:is(h2,h3,h4,h5,h6):not(#toc>h2,#abstract>h2,#sotd>h2,.head>h2){position:relative;left:-.5em}
:is(h2,h3,h4,h5,h6):not(#toch2)+a.self-link{color:inherit;order:-1;position:relative;left:-1.1em;font-size:1rem;opacity:.5}
:is(h2,h3,h4,h5,h6)+a.self-link::before{content:"§";text-decoration:none;color:var(--heading-text)}
:is(h2,h3)+a.self-link{top:-.2em}
:is(h4,h5,h6)+a.self-link::before{color:#000}
@media (max-width:767px){
dd{margin-left:0}
}
@media print{
.removeOnSave{display:none}
}
</style>
<meta name="description" content="This specification defines an approach to represent generic forms of composite values (lists and maps, in particular) as literals in RDF, and corresponding extensions of the SPARQL language. These extensions include an aggregation function to produce such composite values, functions to operate on such composite values in expressions, and a new operator to transform such composite values into their individual components.">
<style>
var{position:relative;cursor:pointer}
var[data-type]::after,var[data-type]::before{position:absolute;left:50%;top:-6px;opacity:0;transition:opacity .4s;pointer-events:none}
var[data-type]::before{content:"";transform:translateX(-50%);border-width:4px 6px 0 6px;border-style:solid;border-color:transparent;border-top-color:#000}
var[data-type]::after{content:attr(data-type);transform:translateX(-50%) translateY(-100%);background:#000;text-align:center;font-family:"Dank Mono","Fira Code",monospace;font-style:normal;padding:6px;border-radius:3px;color:#daca88;text-indent:0;font-weight:400}
var[data-type]:hover::after,var[data-type]:hover::before{opacity:1}
</style>
<script id="initialUserConfig" type="application/json">{
  "specStatus": "unofficial",
  "edDraftURI": "https://w3id.org/awslabs/neptune/SPARQL-CDTs/spec/editors_draft.html",
  "latestVersion": "https://w3id.org/awslabs/neptune/SPARQL-CDTs/spec/latest.html",
  "testSuiteURI": "https://github.com/awslabs/SPARQL-CDTs/tree/main/tests",
  "editors": [
    {
      "name": "Olaf Hartig",
      "url": "http://olafhartig.de/",
      "company": "Amazon",
      "companyURL": "https://amazon.com/",
      "orcid": "https://orcid.org/0000-0002-1741-2090",
      "w3cid": 112469
    },
    {
      "name": "Gregory Todd Williams",
      "url": "https://kasei.us/",
      "company": "Amazon",
      "companyURL": "https://amazon.com/",
      "w3cid": 38870
    }
  ],
  "github": {
    "repoURL": "awslabs/SPARQL-CDTs",
    "branch": "main"
  },
  "localBiblio": {
    "EBNF-NOTATION": {
      "title": "EBNF NOTATION",
      "href": "http://www.w3.org/TR/REC-xml/#sec-notation",
      "publisher": "W3C",
      "date": "26 November 2008",
      "status": "W3C Recommendation",
      "authors": [
        "Tim Bray",
        "Jean Paoli",
        "C. M. Sperberg-McQueen",
        "Eve Maler",
        "François Yergeau"
      ],
      "id": "ebnf-notation"
    }
  },
  "xref": [
    "RDF11-CONCEPTS",
    "SPARQL11-QUERY",
    "RDF11-MT"
  ],
  "maxTocLevel": 3,
  "publishISODate": "2024-03-04T00:00:00.000Z",
  "generatedSubtitle": "Unofficial Draft 04 March 2024"
}</script>
<link rel="stylesheet" href="https://www.w3.org/StyleSheets/TR/2021/W3C-UD"></head>
<body class="h-entry" data-cite="RDF11-CONCEPTS SPARQL11-QUERY RDF11-MT"><div class="head">
    
    <h1 id="title" class="title">SPARQL CDTs: Representing and Querying Lists and Maps as RDF Literals</h1> 
    <p id="w3c-state">Unofficial Draft <time class="dt-published" datetime="2024-03-04">04 March 2024</time></p>
    <details open="">
      <summary>More details about this document</summary>
      <dl>
        
        <dt>Latest published version:</dt><dd>
                <a href="https://w3id.org/awslabs/neptune/SPARQL-CDTs/spec/latest.html">https://w3id.org/awslabs/neptune/SPARQL-CDTs/spec/latest.html</a>
              </dd>
        <dt>Latest editor's draft:</dt><dd><a href="https://w3id.org/awslabs/neptune/SPARQL-CDTs/spec/editors_draft.html">https://w3id.org/awslabs/neptune/SPARQL-CDTs/spec/editors_draft.html</a></dd>
        <dt>History:</dt><dd>
                    <a href="https://github.com/awslabs/SPARQL-CDTs/commits/main">Commit history</a>
                  </dd>
        <dt>Test suite:</dt><dd><a href="https://github.com/awslabs/SPARQL-CDTs/tree/main/tests">https://github.com/awslabs/SPARQL-CDTs/tree/main/tests</a></dd>
        
        
        
        
        <dt>Editors:</dt><dd class="editor p-author h-card vcard" data-editor-id="112469">
    <a class="u-url url p-name fn" href="http://olafhartig.de/">Olaf Hartig</a><a class="p-name orcid" href="https://orcid.org/0000-0002-1741-2090"><svg width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256">
    <style>

      .st1 {
        fill: #fff;
      }
    
</style>
    <path d="M256 128c0 70.7-57.3 128-128 128S0 198.7 0 128 57.3 0 128 0s128 57.3 128 128z" fill="#a6ce39"></path>
    <path class="st1" d="M86.3 186.2H70.9V79.1h15.4v107.1zM108.9 79.1h41.6c39.6 0 57 28.3 57 53.6 0 27.5-21.5 53.6-56.8 53.6h-41.8V79.1zm15.4 93.3h24.5c34.9 0 42.9-26.5 42.9-39.7C191.7 111.2 178 93 148 93h-23.7v79.4zM88.7 56.8c0 5.5-4.5 10.1-10.1 10.1s-10.1-4.6-10.1-10.1c0-5.6 4.5-10.1 10.1-10.1s10.1 4.6 10.1 10.1z"></path>
  </svg></a> (<a class="p-org org h-org" href="https://amazon.com/">Amazon</a>)
  </dd><dd class="editor p-author h-card vcard" data-editor-id="38870">
    <a class="u-url url p-name fn" href="https://kasei.us/">Gregory Todd Williams</a> (<a class="p-org org h-org" href="https://amazon.com/">Amazon</a>)
  </dd>
        
        
        <dt>Feedback:</dt><dd>
        <a href="https://github.com/awslabs/SPARQL-CDTs/">GitHub awslabs/SPARQL-CDTs</a>
        (<a href="https://github.com/awslabs/SPARQL-CDTs/pulls/">pull requests</a>,
        <a href="https://github.com/awslabs/SPARQL-CDTs/issues/new/choose">new issue</a>,
        <a href="https://github.com/awslabs/SPARQL-CDTs/issues/">open issues</a>)
      </dd>
        
        
      </dl>
    </details>
    
    
    <p class="copyright">
      Copyright ©
      2024
      the document editors/authors.
      Text is available under the
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/legalcode">Creative Commons Attribution 4.0 International Public License</a>; additional terms may apply.
    </p>
    <hr title="Separator for header">
  </div>
  <section id="abstract" class="introductory"><h2>Abstract</h2>
    <p>
      This specification defines an approach to represent generic forms of composite values (lists and maps, in particular) as literals in RDF, and corresponding extensions of the SPARQL language. These extensions include an aggregation function to produce such composite values, functions to operate on such composite values in expressions, and a new operator to transform such composite values into their individual components.
    </p>
  </section>
  <section id="sotd" class="introductory"><h2>Status of This Document</h2><p>
      This document is a draft of a potential specification. It has no official
      standing of any kind and does not represent the support or consensus of
      any standards organization.
    </p>
  </section><nav id="toc"><h2 class="introductory" id="table-of-contents">Table of Contents</h2><ol class="toc"><li class="tocline"><a class="tocxref" href="#abstract">Abstract</a></li><li class="tocline"><a class="tocxref" href="#sotd">Status of This Document</a></li><li class="tocline"><a class="tocxref" href="#introduction"><bdi class="secno">1. </bdi>Introduction</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#background-and-motivation-todo"><bdi class="secno">1.1 </bdi>Background and Motivation (TODO)</a></li><li class="tocline"><a class="tocxref" href="#structure"><bdi class="secno">1.2 </bdi>Structure of this Document (TODO)</a></li><li class="tocline"><a class="tocxref" href="#document-conventions-todo"><bdi class="secno">1.3 </bdi>Document Conventions (TODO)</a></li><li class="tocline"><a class="tocxref" href="#conformance"><bdi class="secno">1.4 </bdi>Conformance</a></li></ol></li><li class="tocline"><a class="tocxref" href="#description"><bdi class="secno">2. </bdi>Informal Description of the Approach</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#description-of-literals"><bdi class="secno">2.1 </bdi>Representation of Composite Values as RDF Literals</a></li><li class="tocline"><a class="tocxref" href="#description-of-functions"><bdi class="secno">2.2 </bdi>SPARQL Functions on Composite Datatype Literals</a></li><li class="tocline"><a class="tocxref" href="#description-of-fold"><bdi class="secno">2.3 </bdi>FOLD Aggregate</a></li><li class="tocline"><a class="tocxref" href="#description-of-unfold"><bdi class="secno">2.4 </bdi>UNFOLD Operator</a></li><li class="tocline"><a class="tocxref" href="#description-of-comparing"><bdi class="secno">2.5 </bdi>Comparing Composite Datatype Literals</a></li><li class="tocline"><a class="tocxref" href="#description-of-ordering"><bdi class="secno">2.6 </bdi>Ordering Composite Datatype Literals</a></li></ol></li><li class="tocline"><a class="tocxref" href="#list-datatype"><bdi class="secno">3. </bdi>The cdt:List Datatype</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#list-datatype-valuespace"><bdi class="secno">3.1 </bdi>Value Space</a></li><li class="tocline"><a class="tocxref" href="#list-datatype-lexspace"><bdi class="secno">3.2 </bdi>Lexical Space</a></li><li class="tocline"><a class="tocxref" href="#list-datatype-lex-to-value-mapping"><bdi class="secno">3.3 </bdi>Lexical-To-Value Mapping</a></li><li class="tocline"><a class="tocxref" href="#list-datatype-versus-rdflists"><bdi class="secno">3.4 </bdi>Relationship to RDF Collections</a></li></ol></li><li class="tocline"><a class="tocxref" href="#map-datatype"><bdi class="secno">4. </bdi>The cdt:Map Datatype</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#map-datatype-valuespace"><bdi class="secno">4.1 </bdi>Value Space</a></li><li class="tocline"><a class="tocxref" href="#map-datatype-lexspace"><bdi class="secno">4.2 </bdi>Lexical Space</a></li><li class="tocline"><a class="tocxref" href="#map-datatype-lex-to-value-mapping"><bdi class="secno">4.3 </bdi>Lexical-To-Value Mapping</a></li><li class="tocline"><a class="tocxref" href="#map-datatype-versus-json"><bdi class="secno">4.4 </bdi>Relationship to JSON</a></li></ol></li><li class="tocline"><a class="tocxref" href="#extension-of-sparql-operators"><bdi class="secno">5. </bdi>Extensions of Existing SPARQL Operators</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#func_list-equal"><bdi class="secno">5.1 </bdi>list-equal</a></li><li class="tocline"><a class="tocxref" href="#func_map-equal"><bdi class="secno">5.2 </bdi>map-equal</a></li><li class="tocline"><a class="tocxref" href="#func_list-less-than"><bdi class="secno">5.3 </bdi>list-less-than</a></li><li class="tocline"><a class="tocxref" href="#func_map-less-than"><bdi class="secno">5.4 </bdi>map-less-than</a></li></ol></li><li class="tocline"><a class="tocxref" href="#combined-functions"><bdi class="secno">6. </bdi>Functions on Lists and Maps</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#func_get"><bdi class="secno">6.1 </bdi>cdt:get</a></li><li class="tocline"><a class="tocxref" href="#func_size"><bdi class="secno">6.2 </bdi>cdt:size</a></li></ol></li><li class="tocline"><a class="tocxref" href="#list-functions"><bdi class="secno">7. </bdi>Functions on Lists</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#func_list"><bdi class="secno">7.1 </bdi>cdt:List</a></li><li class="tocline"><a class="tocxref" href="#func_concat"><bdi class="secno">7.2 </bdi>cdt:concat</a></li><li class="tocline"><a class="tocxref" href="#func_contains"><bdi class="secno">7.3 </bdi>cdt:contains</a></li><li class="tocline"><a class="tocxref" href="#func_head"><bdi class="secno">7.4 </bdi>cdt:head</a></li><li class="tocline"><a class="tocxref" href="#func_reverse"><bdi class="secno">7.5 </bdi>cdt:reverse</a></li><li class="tocline"><a class="tocxref" href="#func_subseq"><bdi class="secno">7.6 </bdi>cdt:subseq</a></li><li class="tocline"><a class="tocxref" href="#func_tail"><bdi class="secno">7.7 </bdi>cdt:tail</a></li></ol></li><li class="tocline"><a class="tocxref" href="#map-functions"><bdi class="secno">8. </bdi>Functions on Maps</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#func_map"><bdi class="secno">8.1 </bdi>cdt:Map</a></li><li class="tocline"><a class="tocxref" href="#func_containsKey"><bdi class="secno">8.2 </bdi>cdt:containsKey</a></li><li class="tocline"><a class="tocxref" href="#func_keys"><bdi class="secno">8.3 </bdi>cdt:keys</a></li><li class="tocline"><a class="tocxref" href="#func_merge"><bdi class="secno">8.4 </bdi>cdt:merge</a></li><li class="tocline"><a class="tocxref" href="#func_put"><bdi class="secno">8.5 </bdi>cdt:put</a></li><li class="tocline"><a class="tocxref" href="#func_remove"><bdi class="secno">8.6 </bdi>cdt:remove</a></li></ol></li><li class="tocline"><a class="tocxref" href="#extension-of-order-by"><bdi class="secno">9. </bdi>Extension of ORDER BY</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#relative-order-of-list-literals"><bdi class="secno">9.1 </bdi>Relative Order of cdt:List Literals</a></li><li class="tocline"><a class="tocxref" href="#relative-order-of-map-literals"><bdi class="secno">9.2 </bdi>Relative Order of cdt:Map Literals</a></li></ol></li><li class="tocline"><a class="tocxref" href="#fold"><bdi class="secno">10. </bdi>FOLD</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#fold-grammar"><bdi class="secno">10.1 </bdi>Grammar</a></li><li class="tocline"><a class="tocxref" href="#fold-translation"><bdi class="secno">10.2 </bdi>Translation to the Algebra</a></li><li class="tocline"><a class="tocxref" href="#ordergroups-algebra"><bdi class="secno">10.3 </bdi>Algebra</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#aggregateAlgebra"><bdi class="secno">10.3.1 </bdi>Aggregate Algebra</a><ol class="toc"></ol></li></ol></li><li class="tocline"><a class="tocxref" href="#ordergroups-semantics"><bdi class="secno">10.4 </bdi>Evaluation Semantics</a></li></ol></li><li class="tocline"><a class="tocxref" href="#unfold"><bdi class="secno">11. </bdi>UNFOLD</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#unfold-grammar"><bdi class="secno">11.1 </bdi>Grammar</a></li><li class="tocline"><a class="tocxref" href="#unfold-translation"><bdi class="secno">11.2 </bdi>Translation to the Algebra</a></li><li class="tocline"><a class="tocxref" href="#unfold-algebra"><bdi class="secno">11.3 </bdi>Algebra</a></li><li class="tocline"><a class="tocxref" href="#unfold-semantics"><bdi class="secno">11.4 </bdi>Evaluation Semantics</a></li></ol></li><li class="tocline"><a class="tocxref" href="#iana-considerations"><bdi class="secno">A. </bdi>IANA Considerations</a></li><li class="tocline"><a class="tocxref" href="#complete-ebnf-grammars"><bdi class="secno">B. </bdi>Complete <abbr title="Extended Backus-Naur Form">EBNF</abbr> Grammars</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#cdt-ebnf"><bdi class="secno">B.1 </bdi>Composite Datatypes <abbr title="Extended Backus-Naur Form">EBNF</abbr> Grammar</a></li><li class="tocline"><a class="tocxref" href="#sparql-cdt-ebnf"><bdi class="secno">B.2 </bdi>SPARQL-CDT <abbr title="Extended Backus-Naur Form">EBNF</abbr> Grammar</a></li></ol></li><li class="tocline"><a class="tocxref" href="#references"><bdi class="secno">C. </bdi>References</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#normative-references"><bdi class="secno">C.1 </bdi>Normative references</a></li><li class="tocline"><a class="tocxref" href="#informative-references"><bdi class="secno">C.2 </bdi>Informative references</a></li></ol></li></ol></nav>

  <section id="introduction"><div class="header-wrapper"><h2 id="x1-introduction"><bdi class="secno">1. </bdi>Introduction</h2><a class="self-link" href="#introduction" aria-label="Permalink for Section 1."></a></div>
    

    <section class="informative" id="background-and-motivation-todo"><div class="header-wrapper"><h3 id="x1-1-background-and-motivation-todo"><bdi class="secno">1.1 </bdi>Background and Motivation (TODO)</h3><a class="self-link" href="#background-and-motivation-todo" aria-label="Permalink for Section 1.1"></a></div><p><em>This section is non-normative.</em></p>
      
      <p>
        The Resource Description Framework (RDF) is a general-purpose framework for representing and exchanging data [<cite><a class="bibref" data-link-type="biblio" href="#bib-rdf11-primer" title="RDF 1.1 Primer">RDF11-PRIMER</a></cite>], and the SPARQL language is a declarative language for querying and updating RDF data [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-overview" title="SPARQL 1.1 Overview">SPARQL11-OVERVIEW</a></cite>]. Yet, a feature regarding which RDF and SPARQL lag behind other popular data representation forms such as SQL databases and Property Graphs, and their corresponding query languages, is a built-in support for generic types of composite values such as lists, maps, and sets. Instead, RDF introduces so-called <a href="https://www.w3.org/TR/rdf-schema/#ch_containervocab">containers</a> and <a href="https://www.w3.org/TR/rdf-schema/#ch_collectionvocab">collections</a>, which allow users to model composite values through dedicated vocabulary <em>on top</em> of the core data model.
      </p>
      <p>TODO</p>

    </section>

    <section id="structure" class="informative"><div class="header-wrapper"><h3 id="x1-2-structure-of-this-document-todo"><bdi class="secno">1.2 </bdi>Structure of this Document (TODO)</h3><a class="self-link" href="#structure" aria-label="Permalink for Section 1.2"></a></div><p><em>This section is non-normative.</em></p>
      
      <p>
        In addition to sections marked as non-normative, all examples and notes in this specification are non-normative. Everything else in this specification is normative.
      </p>
      <p>TODO</p>
    </section>

    <section class="informative" id="document-conventions-todo"><div class="header-wrapper"><h3 id="x1-3-document-conventions-todo"><bdi class="secno">1.3 </bdi>Document Conventions (TODO)</h3><a class="self-link" href="#document-conventions-todo" aria-label="Permalink for Section 1.3"></a></div><p><em>This section is non-normative.</em></p>
      
      <p>
        Examples in this document assume that the following prefixes have been declared to represent the IRIs shown with them here:
      </p>

      <table>
        <tbody><tr><td><code>:</code></td><td><code>&lt;http://www.example.org/&gt;</code></td></tr>
        <tr><td><code>ex:</code></td><td><code>&lt;http://example.org/&gt;</code></td></tr>
        <tr><td><code>rdf:</code></td><td><code>&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;</code></td></tr>
        <tr><td><code>foaf:</code></td><td><code>&lt;http://xmlns.com/foaf/0.1/&gt;</code></td></tr>
        <tr><td><code>cdt:</code></td><td><code>&lt;http://w3id.org/awslabs/neptune/SPARQL-CDTs/&gt;</code></td></tr>
      </tbody></table>

    </section>

    <section id="conformance"><div class="header-wrapper"><h3 id="x1-4-conformance"><bdi class="secno">1.4 </bdi>Conformance</h3><a class="self-link" href="#conformance" aria-label="Permalink for Section 1.4"></a></div><p>As well as sections marked as non-normative, all authoring guidelines, diagrams, examples, and notes in this specification are non-normative. Everything else in this specification is normative.</p><p>
        The key words <em class="rfc2119">MAY</em>, <em class="rfc2119">MUST</em>, and <em class="rfc2119">MUST NOT</em> in this document
        are to be interpreted as described in
        <a href="https://datatracker.ietf.org/doc/html/bcp14">BCP 14</a>
        [<cite><a class="bibref" data-link-type="biblio" href="#bib-rfc2119" title="Key words for use in RFCs to Indicate Requirement Levels">RFC2119</a></cite>] [<cite><a class="bibref" data-link-type="biblio" href="#bib-rfc8174" title="Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words">RFC8174</a></cite>]
        when, and only when, they appear in all capitals, as shown here.
      </p>
    </section>

  </section>


  <section id="description" class="informative"><div class="header-wrapper"><h2 id="x2-informal-description-of-the-approach"><bdi class="secno">2. </bdi>Informal Description of the Approach</h2><a class="self-link" href="#description" aria-label="Permalink for Section 2."></a></div><p><em>This section is non-normative.</em></p>
    

    <section id="description-of-literals"><div class="header-wrapper"><h3 id="x2-1-representation-of-composite-values-as-rdf-literals"><bdi class="secno">2.1 </bdi>Representation of Composite Values as RDF Literals</h3><a class="self-link" href="#description-of-literals" aria-label="Permalink for Section 2.1"></a></div>
      

      <p>
        The basis of the approach is to capture composite values (lists and maps) as RDF literals. The components of such a composite value may be RDF terms, including literals representing scalar values (numbers, strings, etc.) as well as literals representing other composite values. The <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form">lexical form</a> (i.e., the string representation) of such a literal that represents a composite value contains the components of the composite value serialized in a format that is based on the <a href="https://www.w3.org/TR/turtle/">RDF Turtle format</a> [<cite><a class="bibref" data-link-type="biblio" href="#bib-turtle" title="RDF 1.1 Turtle">TURTLE</a></cite>]. For instance, the literals in the object positions of the following three RDF triples represent lists. Notice that, in the lexical form of these literals, the elements of the lists are separated by commas and enclosed in square brackets.
      </p>
      <div class="example" id="first-list-example">
        <div class="marker">
    <a class="self-link" href="#first-list-example">Example<bdi> 1</bdi></a>
  </div> <pre data-content-type="text/turtle" class="nohighlight">ex:s ex:p1 "[ 0.504, 0.344, 0.002, 0.716 ]"^^cdt:List .
ex:s ex:p2 "[ &lt;http://example.org/alice&gt;, &lt;http://example.org/bob&gt; ]"^^cdt:List .
ex:s ex:p3 "[ '1999-08-16'^^&lt;http://www.w3.org/2001/XMLSchema#date&gt;, 42 ]"^^cdt:List .</pre>
      </div>
      <p>
        In addition to lists, the approach considers maps, which are sets of key-value pairs where the keys must be distinct. Within the lexical form, the key-values pairs of such a map are separated by commas and a colon is used as separator between each key and its value, as demonstrated by the literal in the object position of the following triple.
      </p>
      <div class="example" id="first-map-example">
        <div class="marker">
    <a class="self-link" href="#first-map-example">Example<bdi> 2</bdi></a>
  </div> <pre data-content-type="text/turtle" class="nohighlight">ex:s ex:p1 "{ 'name' : 'Tuva', 1: &lt;http://example.org/&gt;, 2: null }"^^cdt:Map .</pre>
      </div>
      <p>
        The previous example also illustrates that, in addition to RDF terms, the approach supports <code>null</code> as a special value to be used within maps, as well as in lists. Moreover, the kinds of elements within each list or map may be mixed arbitrarily (defining strongly-typed variations of the proposed composite datatypes is part of our ongoing work).
      </p>
      <p>
        As the examples illustrate, list and map elements that are numeric literals (of particular types) can be written using the Turtle-specific shorthand notation (e.g., <code>0.504</code> is a shortened version of <code>'0.504'^^&lt;http://www.w3.org/2001/XMLSchema#decimal&gt;</code>), and the same holds for boolean-typed literals. Yet, IRIs cannot be shortened in the ways as are possible in Turtle; instead, within the lexical forms of list and map literals, they must be written as absolute IRIs (which is to avoid loosing the definition of the prefix label or the base IRI when the list and map literals are taken out of context). However, as another form of shorthand notation, our approach allows users to directly nest the lexical forms of lists and maps into one another (but still interpreting such contained lists or maps as literals with the corresponding data type). For instance, the literal in the object position of the following triple represents a map in which both of the key-value pairs have a literal as their value, with one of these literals representing a list and the other one a map.
      </p>
      <div class="example" id="second-map-example">
        <div class="marker">
    <a class="self-link" href="#second-map-example">Example<bdi> 3</bdi></a>
  </div> <pre data-content-type="text/turtle" class="nohighlight">ex:s ex:p1 """{
                'names' : ['Tuva', 'Ada', 'Eva'],
                'address': {
                    'street': 'Harbor St.',
                    'number': 43,
                }
              }"""^^cdt:Map .</pre>
      </div>
      <p>
        The attentive reader may observe that the lexical form of the literal in the previous example looks like a JSON document, which is not a coincidence. In contrast, our approach is designed such that, by and large, JSON is a subset of what can be used in the lexical forms of the list and map literals (see Section&nbsp;<a href="#map-datatype-versus-json" class="sectionRef sec-ref"><bdi class="secno">4.4 </bdi>Relationship to JSON</a> for further details).
      </p>
      <p>
        For the definition of the datatypes used for such list and map literals, refer to Sections&nbsp;<a href="#list-datatype" class="sectionRef sec-ref"><bdi class="secno">3. </bdi>The cdt:List Datatype</a> and <a href="#map-datatype" class="sectionRef sec-ref"><bdi class="secno">4. </bdi>The cdt:Map Datatype</a>, respectively.
      </p>
    </section>

    <section id="description-of-functions"><div class="header-wrapper"><h3 id="x2-2-sparql-functions-on-composite-datatype-literals"><bdi class="secno">2.2 </bdi>SPARQL Functions on Composite Datatype Literals</h3><a class="self-link" href="#description-of-functions" aria-label="Permalink for Section 2.2"></a></div>
      

      <p>
        Given such composite datatype literals, this document defines extensions to the SPARQL language that introduce functionality related to the types of composite values that these literals capture. The first of these extensions is a collection of various functions for such literals that can be used in expressions within BIND clauses, FILTER clauses, and SELECT clauses of SPARQL queries.
      </p>
      <p>
        For instance, the following SPARQL query (prefix declarations omitted) uses two such functions in a BIND clause; one of these functions (<a href="#func_concat"><code>cdt:concat</code></a>) concatenates two or more lists, returning the resulting list as a literal again, and the other function (<a href="#func_size"><code>cdt:size</code></a>) returns the cardinality of the resulting list.
      </p>
      <div class="example" id="first-functions-example">
        <div class="marker">
    <a class="self-link" href="#first-functions-example">Example<bdi> 4</bdi></a>
  </div> <pre data-content-type="application/sparql-query" class="nohighlight">SELECT * WHERE {
  ex:s ex:p1 ?l1 .
  ex:s ex:p2 ?l2 .
  ex:s ex:p3 ?l3 .
  BIND( cdt:size( cdt:concat(?l1,?l2,?l3) ) AS ?combinedLength )
}</pre>
      </div>
      <p>
        When executing this query over the <a href="#first-list-example">first example data above</a> (the example with the three lists), the value produced for the <code>?combinedLength</code> variable would be&nbsp;8.
      </p>
      <p>
        Further functions for lists that are defined in this document (in addition to <a href="#func_concat"><code>cdt:concat</code></a> and <a href="#func_size"><code>cdt:size</code></a>, as already used in the previous example) are the following:
      </p>
      <ul>
        <li><a href="#func_contains"><code>cdt:contains</code></a> - can be used to check whether a particular RDF term is contained in a given list</li>
        <li><a href="#func_get"><code>cdt:get</code></a> - returns the RDF term that is at a particular position within a given list</li>
        <li><a href="#func_head"><code>cdt:head</code></a> - returns the RDF term that is at the first position within a given list</li>
        <li><a href="#func_reverse"><code>cdt:reverse</code></a> - returns a list in which the elements of a given list are in the reverse order</li>
        <li><a href="#func_subseq"><code>cdt:subseq</code></a> - returns a part of a given list</li>
        <li><a href="#func_tail"><code>cdt:tail</code></a> - returns a list with all elements of a given list except for the first element</li>
      </ul>
      <p>
        In addition to functions for lists, the document defines functions for maps. As an example, consider the following SPARQL query (prefix declarations omitted).
      </p>
      <div class="example" id="second-functions-example">
        <div class="marker">
    <a class="self-link" href="#second-functions-example">Example<bdi> 5</bdi></a>
  </div> <pre data-content-type="application/sparql-query" class="nohighlight">SELECT ?newAddressSubMap WHERE {
  ex:s ex:p1 ?map .
  BIND( cdt:get( ?map, "address" ) AS ?addressSubMap )
  BIND( cdt:put( ?addressSubMap, "number", 42 ) AS ?newAddressSubMap )
}</pre>
      </div>
      <p>
        This query focuses on the earlier example with the <a href="#second-map-example">JSON-like map</a> (<a href="#second-map-example" class="sectionRef box-ref">Example<bdi> 3</bdi></a>). By using the <a href="#func_get"><code>cdt:get</code></a> function, the query obtains the <code>'address'</code> object of that map and, then, creates and returns a version of this object in which the value of the <code>'number'</code> field is replaced (using <a href="#func_put"><code>cdt:put</code></a>). Hence, the result of the query, when executed over the data of <a href="#second-map-example" class="sectionRef box-ref">Example<bdi> 3</bdi></a>, is a literal such as the following one.
      </p>
      <div class="example" id="second-map-example">
        <div class="marker">
    <a class="self-link" href="#second-map-example">Example<bdi> 6</bdi></a>
  </div> <pre data-content-type="text/turtle" class="nohighlight">"{ 'street': 'Harbor St.', 'number': 42 }"^^cdt:Map .</pre>
      </div>
      <p>
        In addition to <a href="#func_get"><code>cdt:get</code></a> and <a href="#func_put"><code>cdt:put</code></a>, further functions for maps in this document are:
      </p>
      <ul>
        <li><a href="#func_containsKey"><code>cdt:containsKey</code></a> - can be used to check whether a particular RDF term is a key in a given map</li>
        <li><a href="#func_keys"><code>cdt:keys</code></a> - returns a list of all keys in a given map</li>
        <li><a href="#func_merge"><code>cdt:merge</code></a> - returns a map that is the result of merging two maps</li>
        <li><a href="#func_remove"><code>cdt:remove</code></a> - returns a map resulting from a given map but without a particular key-value pair</li>
        <li><a href="#func_size"><code>cdt:size</code></a> - returns the number of key-value pairs in a given map</li>
      </ul>
      <p>
        While all the functions mentioned above operate on the composite datatype literals introduced in this document, the document also defines functions to construct such literals. In particular, the <a href="#func_list"><code>cdt:List</code></a> function can be used to construct a literal that represents a list consisting of the elements that are passed as arguments to the function. For instance, the following query constructs and returns such a literal with the three integers 1, 2, and 3 as elements of the represented list.
      </p>
      <div class="example" id="constructor-function-example">
        <div class="marker">
    <a class="self-link" href="#constructor-function-example">Example<bdi> 7</bdi></a>
  </div> <pre data-content-type="application/sparql-query" class="nohighlight">SELECT ?list WHERE {
  BIND( 1 AS ?arg )
  BIND( cdt:List(?arg, ?arg+1, ?arg+2) AS ?list )
}</pre>
      </div>
      <p>
        Similarly, the <a href="#func_map"><code>cdt:Map</code></a> function can be used to construct a literal representing a map of the key-value pairs that are passed as arguments to that function.
      </p>
      <p>
        For both of these constructor functions, it is possible that some of the given arguments evaluate to an error. For instance, the second and the third argument in the <a href="#constructor-function-example">previous query</a> would evaluate to an error if the variable <code>?arg</code> was bound to an IRI (because the <code>+</code> operator is not defined for IRIs). For any such argument that evaluates to an error, the corresponding element in the created list or map literal becomes the <code>null</code> value, unless it is an argument that specifies the key of a key-value pair for a map literal; in such a case, this key-value pair is ignored because keys cannot be <code>null</code>.
      </p>
    </section>

    <section id="description-of-fold"><div class="header-wrapper"><h3 id="x2-3-fold-aggregate"><bdi class="secno">2.3 </bdi>FOLD Aggregate</h3><a class="self-link" href="#description-of-fold" aria-label="Permalink for Section 2.3"></a></div>
      
      <p>
        Another way to create list and map literals from within SPARQL queries (in addition to the aforementioned two constructor functions, <a href="#func_list"><code>cdt:List</code></a> and <a href="#func_map"><code>cdt:Map</code></a>) is to use the <a href="#fold">FOLD</a> function introduced in this document. As a so-called <a href="https://www.w3.org/TR/sparql11-query/#setFunctions">set function</a>, which are typically used for aggregation, FOLD produces composite values for groups of solution mappings. The following query illustrates how this function can be used to create lists of persons that have the same surname.
      </p>
      <div class="example" id="simple-fold-list-example">
        <div class="marker">
    <a class="self-link" href="#simple-fold-list-example">Example<bdi> 8</bdi></a>
  </div> <pre data-content-type="application/sparql-query" class="nohighlight">SELECT ?sname (FOLD(?person) AS ?list) WHERE {
  ?person rdf:type foaf:Person .
  ?person foaf:surname ?sname .
}
GROUP BY ?sname</pre>
      </div>
      <p>
        Notice that the solution mappings within each of the groups in the previous query are not sorted. As a consequence, the order of the elements in the lists created by the query (i.e., the person IRIs in these lists) is undefined and may even be different each time the query is executed. For use cases in which a particular order is required, the FOLD function can be used with an ORDER BY clause. As an example, consider the following query, which extends the previous one with the requirement that the persons within each list are ordered based on their first names.
      </p>
      <div class="example" id="fold-list-with-order-example">
        <div class="marker">
    <a class="self-link" href="#fold-list-with-order-example">Example<bdi> 9</bdi></a>
  </div> <pre data-content-type="application/sparql-query" class="nohighlight">SELECT ?sname (FOLD(?person ORDER BY ?fname) AS ?list) WHERE {
  ?person rdf:type foaf:Person .
  ?person foaf:surname ?sname .
  ?person foaf:firstName ?fname .
}
GROUP BY ?sname</pre>
      </div>
      <p>
        The ORDER BY feature of FOLD works exactly as the ORDER BY clause that can be used in SPARQL queries. Hence, it is possible to specify multiple ordering comparators, each with the optional keywords ASC and DESC (where ASC is the default).
      </p>
      <p>
        In addition to creating list literals, the FOLD function can also be used to create map literals. To this end, two arguments must be passed to the function, where the first argument provides the keys of the key-value pairs to be added to the map, and the second argument provides the corresponding values. The following query illustrates this functionality; it creates a single map literal in which the key-value pairs are surnames paired up with the number of persons in the queried graph that have the respective surname.
      </p>
      <div class="example" id="fold-map-example">
        <div class="marker">
    <a class="self-link" href="#fold-map-example">Example<bdi> 10</bdi></a>
  </div> <pre data-content-type="application/sparql-query" class="nohighlight">SELECT (FOLD(?sname, ?cnt) AS ?map) WHERE {
  {
    SELECT ?sname (COUNT(*) AS ?cnt) WHERE {
      ?person rdf:type foaf:Person .
      ?person foaf:surname ?sname .
    }
    GROUP BY ?sname
  }
}</pre>
      </div>
      <p>
        When using the two-argument version of FOLD, it may be the case that multiple solution mappings within a group to which FOLD is applied result in key-value pairs with the same key. If that is the case, only one of these key-value pairs is added to the map (which one is undefined unless ORDER BY is used within FOLD, in which case it is the last one in the specified order).
      </p>
    </section>

    <section id="description-of-unfold"><div class="header-wrapper"><h3 id="x2-4-unfold-operator"><bdi class="secno">2.4 </bdi>UNFOLD Operator</h3><a class="self-link" href="#description-of-unfold" aria-label="Permalink for Section 2.4"></a></div>
      
      <p>
        While FOLD compiles values from multiple solution mappings into a composite value, to support the reverse of this process as well this document adds a new operator to SPARQL. This operator, called <a href="#unfold">UNFOLD</a>, breaks composite values into their individual components and assigns these components separately to a new query variable. The following query illustrates how this operator can be used to extract all elements from each list literal of the triples that match a given triple pattern.
      </p>
      <div class="example" id="first-unfold-example">
        <div class="marker">
    <a class="self-link" href="#first-unfold-example">Example<bdi> 11</bdi></a>
  </div> <pre data-content-type="application/sparql-query" class="nohighlight">SELECT ?p ?element WHERE {
  ex:s ?p ?list .
  UNFOLD( ?list AS ?element )
}</pre>
      </div>
      <p>
        When executing this query over the <a href="#first-list-example">first example data above</a>, the query result consists of eight solutions as enumerated in the following tabular representation of the result. Notice that the first four solutions in this table are produced from the four elements of the list in the first triple of the example data; the next two solutions are from the two elements of the list in the second triple; and the last two solutions from the two elements of the list in the third triple.
      </p>
      <table class="sparqlresult">
        <tbody><tr>
          <th>?p</th>
          <th>?element</th>
        </tr>
        <tr>
          <td>ex:p1</td>
          <td>0.504</td>
        </tr>
        <tr>
          <td>ex:p1</td>
          <td>0.344</td>
        </tr>
        <tr>
          <td>ex:p1</td>
          <td>0.002</td>
        </tr>
        <tr>
          <td>ex:p1</td>
          <td>0.716</td>
        </tr>
        <tr>
          <td>ex:p2</td>
          <td>http://example.org/alice</td>
        </tr>
        <tr>
          <td>ex:p2</td>
          <td>http://example.org/bob</td>
        </tr>
        <tr>
          <td>ex:p3</td>
          <td>'1999-08-16'^^&lt;http://www.w3.org/2001/XMLSchema#date&gt;</td>
        </tr>
        <tr>
          <td>ex:p3</td>
          <td>42</td>
        </tr>
      </tbody></table>
      <p>
        If a list literal that is given to the UNFOLD operator contains <code>null</code> values, then the variable introduced in the UNFOLD operator remains unbound in the solution mappings created for these <code>null</code> elements. Yet, it is also possible to add a second variable in the UNFOLD operator, which then gets assigned an integer that represents the position of the list element assigned to the first variable. The following query illustrates this feature for a list that contains a <code>null</code> value.
      </p>
      <div class="example" id="unfold-with-null-example">
        <div class="marker">
    <a class="self-link" href="#unfold-with-null-example">Example<bdi> 12</bdi></a>
  </div> <pre data-content-type="application/sparql-query" class="nohighlight">SELECT ?element ?pos WHERE {
  BIND( "[42, null, &lt;http://example.org/&gt;]"^^cdt:List AS ?list ).
  UNFOLD( ?list AS ?element, ?pos )
}</pre>
      </div>
      <p>
        The result of this query is illustrated in the following table. The empty cell in the table indicates that the solution mapping represented by the corresponding table row does not contain a binding for the corresponding variable (<code>?element</code>).
      </p>
      <table class="sparqlresult">
        <tbody><tr>
          <th>?element</th>
          <th>?pos</th>
        </tr>
        <tr>
          <td>42</td>
          <td>1</td>
        </tr>
        <tr>
          <td></td>
          <td>2</td>
        </tr>
          <tr><td>http://example.org/</td>
          <td>3</td>
        </tr>
      </tbody></table>
      <p>
        The UNFOLD operator can be used for map literals as well. In this case, the one-variable version extracts the keys of the key-value pairs, whereas the two-variables version extracts both the keys (into the first variable) and the their corresponding values (into the second variable). As an example of the latter option, consider the following query.
      </p>
      <div class="example" id="unfold-map-example">
        <div class="marker">
    <a class="self-link" href="#unfold-map-example">Example<bdi> 13</bdi></a>
  </div> <pre data-content-type="application/sparql-query" class="nohighlight">SELECT ?p ?key ?value WHERE {
  ex:s ?p ?map .
  UNFOLD( ?map AS ?key, ?value )
}</pre>
      </div>
      <p>
        When executing this query over the <a href="#first-map-example">data of the first map-related example above</a>, the query result consists of the three solutions listed in the following table (where the variable <code>?value</code> is unbound in the last solution because the value of the corresponding key-value pair in the map is <code>null</code>).
      </p>
      <table class="sparqlresult">
        <tbody><tr>
          <th>?p</th>
          <th>?key</th>
          <th>?value</th>
        </tr>
        <tr>
          <td>ex:p1</td>
          <td>"name"</td>
          <td>"Tuva"</td>
        </tr>
        <tr>
          <td>ex:p1</td>
          <td>1</td>
          <td>http://example.org/</td>
        </tr>
          <tr><td>ex:p1</td>
          <td>2</td>
          <td></td>
        </tr>
      </tbody></table>
    </section>

    <section id="description-of-comparing"><div class="header-wrapper"><h3 id="x2-5-comparing-composite-datatype-literals"><bdi class="secno">2.5 </bdi>Comparing Composite Datatype Literals</h3><a class="self-link" href="#description-of-comparing" aria-label="Permalink for Section 2.5"></a></div>
      
      <p>
        Another important contribution of this document is to extend the definition of the SPARQL comparison operators (<code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code>) for list and map literals. The general idea captured by this extension is that two composite values of the same type (i.e., either two lists or two maps) are compared based on a pairwise comparison of the components of the compared composite values.
      </p>
      <p>
        In particular, two list literals are considered equal (<code>=</code>) if they contain the same number of elements and, for each position within the lists, the elements at that position are equal (<code>=</code>). For instance, <code>"[42]"^^cdt:List</code> and <code>"[42,43]"^^cdt:List</code> are not equal, and neither are <code>"[42]"^^cdt:List</code> and <code>"['42']"^^cdt:List</code>. In contrast, <code>"[42,43]"^^cdt:List</code> and <code>"[&nbsp;42&nbsp;,&nbsp;43&nbsp;]"^^cdt:List</code> are equal, and so are <code>"['1'^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;]"^^cdt:List</code> and <code>"['001'^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;]"^^cdt:List</code>.
      </p>
      <p>
        Similarly, two map literals are considered equal (<code>=</code>) if they contain the same number of key-value pairs, they have the exact same keys, and for each such key, the values associated with that key in both maps compare equal (<code>=</code>). The algorithms that define these two comparison processes in detail can be found in Sections&nbsp;<a href="#func_list-equal" class="sectionRef sec-ref"><bdi class="secno">5.1 </bdi>list-equal</a> and <a href="#func_map-equal" class="sectionRef sec-ref"><bdi class="secno">5.2 </bdi>map-equal</a>, respectively.
      </p>
      <p>
        The definition of whether a list literal is smaller (<code>&lt;</code>) than another list literal is also captured in terms of an algorithm that iterates over the two lists (see Section&nbsp;<a href="#func_list-less-than" class="sectionRef sec-ref"><bdi class="secno">5.3 </bdi>list-less-than</a>). In this case, the iteration stops once it arrives at a position where the respective elements at this position in the two lists do not compare equal (<code>=</code>). At this point, if one of these two elements is smaller (<code>&lt;</code>) than the other one, then the list with this element is considered smaller. If, however, comparing the two elements results in an error or one of them is <code>null</code> and the other one not, then the comparison of the two lists also raises an error. In case the iteration arrives at the end of one of the two lists without stopping, then this list (with fewer elements) is considered smaller.
      </p>
      <p>
        Finally, to define whether a map literal is smaller than another map literal we provide another algorithm (see Section&nbsp;<a href="#func_map-less-than" class="sectionRef sec-ref"><bdi class="secno">5.4 </bdi>map-less-than</a>). This algorithm iterates over the key-value pairs of both maps, assuming these pairs are ordered based on their keys. Once the iteration arrives at two such pairs that do not have both the same key and equal values, the iteration stops. At this point, the algorithm first compares the keys of these two pairs. If the two keys are not the same, then the map with the key that would be ordered before the other one is considered smaller. If the keys are the same, the decision is made by comparing the corresponding values (in the same way as done by the algorithm for the list literals).
      </p>
    </section>

    <section id="description-of-ordering"><div class="header-wrapper"><h3 id="x2-6-ordering-composite-datatype-literals"><bdi class="secno">2.6 </bdi>Ordering Composite Datatype Literals</h3><a class="self-link" href="#description-of-ordering" aria-label="Permalink for Section 2.6"></a></div>
      
      <p>
        The last main contribution of this document is to define a relative order of list and map literals, to be used in the context of the ORDER BY clause of SPARQL (and, therefore, also for the aforementioned ORDER BY feature of FOLD). This definition is based on algorithms—one for list literals and one for map literals—that are similar to the respective comparison algorithms as mentioned in the previous section. In particular, these algorithms that define the relative order also iterate over the components of a given pair of composite values; i.e., the elements of two lists (resp. the key-value pairs of two maps) are considered in a pairwise manner. The major difference between these algorithms and the comparison algorithms is that the latter apply the smaller-than operator (<code>&lt;</code>) at each iteration step whereas the former consider the relative ordering of the list elements (resp. key-value pairs) considered at each iteration step.
      </p>
      <p>
        The effect of this difference can be observed for composite values that contain IRIs or blank nodes. For instance, while the expression
      </p>
      <pre data-content-type="application/sparql-query" class="nohighlight">"[&lt;http://example.org/a&gt;]"^^cdt:List  &lt;  "[&lt;http://example.org/b&gt;]"^^cdt:List</pre>
      <p>
        yields an error because &lt; is not defined for IRIs, the relative order of the two list literals in this expression is defined (namely based on the relative order of the IRIs they contain).
      </p>
      <p>
        Similarly, the expression
      </p>
      <pre data-content-type="application/sparql-query" class="nohighlight">"[&lt;http://example.org/a&gt;]"^^cdt:List  &lt;  "[42]"^^cdt:List</pre>
      <p>
        yields an error because &lt; is not defined between IRIs and (numeric) literals, whereas the relative order of the two list literals in this expression is defined (namely based on the fact that <a href="https://www.w3.org/TR/sparql11-query/#modOrderBy">literals are ordered higher than IRIs</a>).
      </p>
      <p>
        Yet, there are also pairs of list literals and pairs of map literals for which the relative order is undefined. For instance, this is the case for <code>"['hello'@en]"^^cdt:List</code> and <code>"['hello']"^^cdt:List</code>, because the relative order between language-tagged literals and string literals without language tag <a href="https://www.w3.org/TR/sparql11-query/#modOrderBy">is undefined in SPARQL</a>.
      </p>
      <p>
        The complete algorithms that define the relative order for list literals and for map literals can be found in Section&nbsp;<a href="#relative-order-of-list-literals" class="sectionRef sec-ref"><bdi class="secno">9.1 </bdi>Relative Order of cdt:List Literals</a> and in Section&nbsp;<a href="#relative-order-of-map-literals" class="sec-ref"><bdi class="secno">9.2 </bdi>Relative Order of cdt:Map Literals</a>, respectively.
      </p>
    </section>

  </section>


  <section id="list-datatype"><div class="header-wrapper"><h2 id="x3-the-cdt-list-datatype"><bdi class="secno">3. </bdi>The cdt:List Datatype</h2><a class="self-link" href="#list-datatype" aria-label="Permalink for Section 3."></a></div>
    

    <p>
      The <dfn data-lt="cdt:List datatype" id="dfn-cdt-list-datatype" tabindex="0" aria-haspopup="dialog" data-dfn-type="dfn">cdt:List datatype</dfn> is the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-datatype">RDF datatype</a>&nbsp;that consists of the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-value-space">value space</a>, the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-space">lexical space</a>, and the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-to-value-mapping">lexical-to-value mapping</a> defined in this section (see Subsections <a href="#list-datatype-valuespace" class="sectionRef sec-ref"><bdi class="secno">3.1 </bdi>Value Space</a>, <a href="#list-datatype-lexspace" class="sectionRef sec-ref"><bdi class="secno">3.2 </bdi>Lexical Space</a>, and <a href="#list-datatype-lex-to-value-mapping" class="sectionRef sec-ref"><bdi class="secno">3.3 </bdi>Lexical-To-Value Mapping</a>, respectively), and that is denoted by the following <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-datatype-iri">datatype IRI</a>:
    </p>
    <p>
      <code>http://w3id.org/awslabs/neptune/SPARQL-CDTs/List</code>
    </p>
    <p>
      Every <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-literal">literal</a> that has this IRI as its <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-datatype-iri">datatype IRI</a> is called a <dfn data-lt="cdt:List literal" data-plurals="cdt:list literals" id="dfn-cdt-list-literal" tabindex="0" aria-haspopup="dialog" data-dfn-type="dfn">cdt:List literal</dfn>. If the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form">lexical form</a> of such a literal is in the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-space">lexical space</a> of the <a href="#dfn-cdt-list-datatype" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-datatype-1">cdt:List datatype</a>, as defined in Section&nbsp;<a href="#list-datatype-lexspace" class="sectionRef sec-ref"><bdi class="secno">3.2 </bdi>Lexical Space</a>, then the literal is called a <dfn data-lt="well-formed cdt:List literal" data-plurals="well-formed cdt:list literals" id="dfn-well-formed-cdt-list-literal" tabindex="0" aria-haspopup="dialog" data-dfn-type="dfn">well-formed cdt:List literal</dfn>. In contrast, a <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-1">cdt:List literal</a> whose lexical form is not in the lexical space of the cdt:List datatype is called an <dfn data-lt="ill-formed cdt:List literal" id="dfn-ill-formed-cdt-list-literal" tabindex="0" aria-haspopup="dialog" data-dfn-type="dfn">ill-formed cdt:List literal</dfn>.
    </p>

    <section id="list-datatype-valuespace"><div class="header-wrapper"><h3 id="x3-1-value-space"><bdi class="secno">3.1 </bdi>Value Space</h3><a class="self-link" href="#list-datatype-valuespace" aria-label="Permalink for Section 3.1"></a></div>
      

      <p>
        The <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-value-space">value space</a> of the <a href="#dfn-cdt-list-datatype" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-datatype-2">cdt:List datatype</a> consists of all finite <a href="https://en.wikipedia.org/wiki/Sequence">sequences</a> of <a href="#dfn-list-element" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-list-element-1">list elements</a>, where the notion of a <dfn data-lt="list element" data-plurals="list elements" id="dfn-list-element" tabindex="0" aria-haspopup="dialog" data-dfn-type="dfn">list element</dfn> is defined as follows:
        </p><ul>
          <li>every <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-rdf-term">RDF term</a> is a list element and</li>
          <li><a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-1">null</a> is a list element.</li>
        </ul>
        Any such sequence is called <dfn data-lt="term list" data-plurals="term lists" id="dfn-term-list" tabindex="0" aria-haspopup="dialog" data-dfn-type="dfn">term list</dfn>, and the empty sequence of <a href="#dfn-list-element" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-list-element-2">list elements</a> is the <dfn data-lt="empty term list" id="dfn-empty-term-list" tabindex="0" aria-haspopup="dialog" data-dfn-type="dfn">empty term list</dfn>.
      <p></p>

      <p>
        <dfn data-lt="null" id="dfn-null" tabindex="0" aria-haspopup="dialog" data-dfn-type="dfn">null</dfn> is a special symbol that can be used as a <a href="#dfn-list-element" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-list-element-3">list element</a> (and as a <a href="#dfn-map-value" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-value-1">map value</a>) and that is <em>not</em> an <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-rdf-term">RDF term</a>.
      </p>

      <div class="note" role="note" id="issue-container-generatedID"><div role="heading" class="note-title marker" id="h-note" aria-level="4"><span>Note</span></div><p class="">
        Every RDF term <em class="rfc2119">MAY</em> occur multiple times in a <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-1">term list</a>, and so may <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-2">null</a>.
      </p></div>

    </section>

    <section id="list-datatype-lexspace"><div class="header-wrapper"><h3 id="x3-2-lexical-space"><bdi class="secno">3.2 </bdi>Lexical Space</h3><a class="self-link" href="#list-datatype-lexspace" aria-label="Permalink for Section 3.2"></a></div>
      
        
      <p>
        The <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-space">lexical space</a> of the <a href="#dfn-cdt-list-datatype" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-datatype-3">cdt:List datatype</a> consists of all strings that are recognized by the <a href="#cdt-grammar-production-List"><code>List</code></a> production of the following grammar (the <a href="https://www.w3.org/TR/xml/#sec-notation"><abbr title="Extended Backus-Naur Form">EBNF</abbr> notation</a> used here is defined in XML 1.0 [<cite><a class="bibref" data-link-type="biblio" href="#bib-ebnf-notation" title="EBNF NOTATION">EBNF-NOTATION</a></cite>]).
      </p>
      <p>
        The grammar uses productions from the grammar of the Turtle serialization format for RDF data [<cite><a class="bibref" data-link-type="biblio" href="#bib-turtle" title="RDF 1.1 Turtle">TURTLE</a></cite>]. In particular, the terminal and nonterminal symbols for which no production rule is provided below (i.e.,
        <a href="https://www.w3.org/TR/turtle/#grammar-production-IRIREF"><code>IRIREF</code></a>,
        <a href="https://www.w3.org/TR/turtle/#grammar-production-BLANK_NODE_LABEL"><code>BLANK_NODE_LABEL</code></a>,
        <a href="https://www.w3.org/TR/turtle/#grammar-production-NumericLiteral"><code>NumericLiteral</code></a>,
        <a href="https://www.w3.org/TR/turtle/#grammar-production-BooleanLiteral"><code>BooleanLiteral</code></a>,
        <a href="https://www.w3.org/TR/turtle/#grammar-production-String"><code>String</code></a>,
        and
        <a href="https://www.w3.org/TR/turtle/#grammar-production-LANGTAG">LANGTAG</a>)
        are defined in the Turtle grammar.
      </p>
      <p>
        The <a href="#cdt-grammar-production-RDFLiteral"><code>RDFLiteral</code></a> production in the given grammar is special as the Turtle grammar also contains a very similar production for the same symbol (see <a href="https://www.w3.org/TR/turtle/#grammar-production-RDFLiteral"><code>RDFLiteral</code></a> in [<cite><a class="bibref" data-link-type="biblio" href="#bib-turtle" title="RDF 1.1 Turtle">TURTLE</a></cite>]). The difference is that the version of the rule in the Turtle grammar permits the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-datatype-iri">datatype IRI</a> of a <a href="https://www.w3.org/TR/rdf11-concepts/#literal">literal</a> to be written as a <a href="https://www.w3.org/TR/turtle/#prefixed-name">prefixed name</a>, whereas the version of the rule as defined below does not permit datatype IRIs written as prefixed names (but only as absolute IRIs and as <a href="https://www.w3.org/TR/turtle/#relative-iri">relative IRIs</a>).
      </p>
      <p>
        An additional restriction that is not explicitly captured in the given grammar is that any occurrence of the <a href="https://www.w3.org/TR/turtle/#grammar-production-IRIREF"><code>IRIREF</code></a> production <em class="rfc2119">MUST</em>—after handling of <a href="https://www.w3.org/TR/turtle/#numeric">escape sequences</a>—also match the (more restrictive) <code>absolute-IRI</code> production of [<cite><a class="bibref" data-link-type="biblio" href="#bib-rfc3987" title="Internationalized Resource Identifiers (IRIs)">RFC3987</a></cite>]. Hence, IRI references in the lexical form of <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-2">cdt:List literals</a> and <a href="#dfn-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-literal-1">cdt:Map literals</a> <em class="rfc2119">MUST</em> be absolute; they cannot be written as <a href="https://www.w3.org/TR/turtle/#prefixed-name">prefixed names</a> (see the previous paragraph about the <a href="#cdt-grammar-production-RDFLiteral"><code>RDFLiteral</code></a> production) nor as <a href="https://www.w3.org/TR/turtle/#relative-iri">relative IRI references</a>.
      </p>

      <table class="grammar">

        <tbody><tr id="cdt-grammar-production-List">
          <td>[1]</td>
          <td><code>List</code></td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <code class="token">'['</code>
            <code>(</code>
            <a href="#cdt-grammar-production-NonEmptyListContent">NonEmptyListContent</a>
            <code>)?</code>
            <code class="token">']'</code>
          </td>
        </tr>

        <tr id="cdt-grammar-production-NonEmptyListContent">
          <td>[2]</td>
          <td><code>NonEmptyListContent</code></td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <a href="#cdt-grammar-production-ListElement">ListElement</a>
            <code>(</code>
            <code class="token">','</code>
            <a href="#cdt-grammar-production-ListElement">ListElement</a>
            <code>)*</code>
          </td>
        </tr>

        <tr id="cdt-grammar-production-ListElement">
          <td>[3]</td>
          <td><code>ListElement</code></td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <a href="https://www.w3.org/TR/turtle/#grammar-production-IRIREF">IRIREF</a>
            <code>|</code>
            <a href="https://www.w3.org/TR/turtle/#grammar-production-BLANK_NODE_LABEL">BLANK_NODE_LABEL</a>
            <code>|</code>
            <a href="#cdt-grammar-production-RDFLiteral">RDFLiteral</a>
            <code>|</code>
            <a href="https://www.w3.org/TR/turtle/#grammar-production-NumericLiteral">NumericLiteral</a>
            <code>|</code>
            <a href="https://www.w3.org/TR/turtle/#grammar-production-BooleanLiteral">BooleanLiteral</a>
            <code>|</code>
            <a href="#cdt-grammar-production-NULL">NULL</a>
            <code>|</code>
            <a href="#cdt-grammar-production-List">List</a>
            <code>|</code>
            <a href="#cdt-grammar-production-Map">Map</a>
          </td>
        </tr>

        <tr id="cdt-grammar-production-Map">
          <td>[4]</td>
          <td><code>Map</code></td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <code class="token">'{'</code>
            <code>(</code>
            <a href="#cdt-grammar-production-NonEmptyMapContent">NonEmptyMapContent</a>
            <code>)?</code>
            <code class="token">'}'</code>
          </td>
        </tr>

        <tr id="cdt-grammar-production-NonEmptyMapContent">
          <td>[5]</td>
          <td><code>NonEmptyMapContent</code></td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <a href="#cdt-grammar-production-MapEntry">MapEntry</a>
            <code>(</code>
            <code class="token">','</code>
            <a href="#cdt-grammar-production-MapEntry">MapEntry</a>
            <code>)*</code>
          </td>
        </tr>

        <tr id="cdt-grammar-production-MapEntry">
          <td>[6]</td>
          <td><code>MapEntry</code></td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <a href="#cdt-grammar-production-MapKey">MapKey</a>
            <code class="token">':'</code>
            <a href="#cdt-grammar-production-MapValue">MapValue</a>
          </td>
        </tr>

        <tr id="cdt-grammar-production-MapKey">
          <td>[7]</td>
          <td><code>MapKey</code></td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <a href="https://www.w3.org/TR/turtle/#grammar-production-IRIREF">IRIREF</a>
            <code>|</code>
            <a href="#cdt-grammar-production-RDFLiteral">RDFLiteral</a>
            <code>|</code>
            <a href="https://www.w3.org/TR/turtle/#grammar-production-NumericLiteral">NumericLiteral</a>
            <code>|</code>
            <a href="https://www.w3.org/TR/turtle/#grammar-production-BooleanLiteral">BooleanLiteral</a>
          </td>
        </tr>

        <tr id="cdt-grammar-production-MapValue">
          <td>[8]</td>
          <td><code>MapValue</code></td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <a href="https://www.w3.org/TR/turtle/#grammar-production-IRIREF">IRIREF</a>
            <code>|</code>
            <a href="https://www.w3.org/TR/turtle/#grammar-production-BLANK_NODE_LABEL">BLANK_NODE_LABEL</a>
            <code>|</code>
            <a href="#cdt-grammar-production-RDFLiteral">RDFLiteral</a>
            <code>|</code>
            <a href="https://www.w3.org/TR/turtle/#grammar-production-NumericLiteral">NumericLiteral</a>
            <code>|</code>
            <a href="https://www.w3.org/TR/turtle/#grammar-production-BooleanLiteral">BooleanLiteral</a>
            <code>|</code>
            <a href="#cdt-grammar-production-NULL">NULL</a>
            <code>|</code>
            <a href="#cdt-grammar-production-List">List</a>
            <code>|</code>
            <a href="#cdt-grammar-production-Map">Map</a>
          </td>
        </tr>

        <tr id="cdt-grammar-production-NULL">
          <td>[9]</td>
          <td><code>NULL</code></td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <code class="token">'null'</code>
          </td>
        </tr>

        <tr id="cdt-grammar-production-RDFLiteral">
          <td>[128s]</td>
          <td><code>RDFLiteral</code></td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <a href="https://www.w3.org/TR/turtle/#grammar-production-String">String</a>
            <code>(</code>
            <a href="https://www.w3.org/TR/turtle/#grammar-production-LANGTAG">LANGTAG</a>
            <code>|</code>
            <code class="token">'^^'</code> <a href="https://www.w3.org/TR/turtle/#grammar-production-IRIREF">IRIREF</a>
            <code>)?</code>
          </td>
        </tr>

      </tbody></table>

      <div class="note" role="note" id="issue-container-generatedID-0"><div role="heading" class="note-title marker" id="h-note-0" aria-level="4"><span>Note</span></div><p class="">
        The complete grammar can be found in <a href="#cdt-ebnf" class="sec-ref"><bdi class="secno">B.1 </bdi>Composite Datatypes <abbr title="Extended Backus-Naur Form">EBNF</abbr> Grammar</a>.
      </p></div>

    </section>

    <section id="list-datatype-lex-to-value-mapping"><div class="header-wrapper"><h3 id="x3-3-lexical-to-value-mapping"><bdi class="secno">3.3 </bdi>Lexical-To-Value Mapping</h3><a class="self-link" href="#list-datatype-lex-to-value-mapping" aria-label="Permalink for Section 3.3"></a></div>
      
        
      <p>
        The <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-to-value-mapping">lexical-to-value mapping</a> of the <a href="#dfn-cdt-list-datatype" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-datatype-4">cdt:List datatype</a> is defined as follows for every string&nbsp;<var>S</var> that is recognized by the <a href="#cdt-grammar-production-List"><code>List</code></a> production of the grammar defined in Section&nbsp;<a href="#list-datatype-lexspace" class="sectionRef sec-ref"><bdi class="secno">3.2 </bdi>Lexical Space</a>.
      </p>
      <p>
        If the string&nbsp;<var>S</var> does <em>not</em> contain a substring that is recognized by the <a href="#cdt-grammar-production-NonEmptyListContent"><code>NonEmptyListContent</code></a> production of the grammar, then <var>S</var> is mapped to the <a href="#dfn-empty-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-list-1">empty term list</a>.
      </p>
      <p>
        Otherwise, let <var>S</var>' be the greatest substring of <var>S</var> that is recognized by the <a href="#cdt-grammar-production-NonEmptyListContent"><code>NonEmptyListContent</code></a> production and let (<var>E</var><sub>1</sub>, ..., <var>E</var><sub><var>n</var></sub>) be the sequence of all substrings of <var>S</var>' that are recognized by the <a href="#cdt-grammar-production-ListElement"><code>ListElement</code></a> production, in the order in which they appear in <var>S</var>'. Then, <var>S</var> is mapped to the <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-2">term list</a>&nbsp;<var>tm</var> that consists of <var>n</var> <a href="#dfn-list-element" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-list-element-4">list elements</a> such that, for all <var>i</var> in {1, ..., <var>n</var>}, the <var>i</var>-th element in <var>tm</var> is the following <a href="#dfn-list-element" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-list-element-5">list element</a>, depending on which of the cases of the <a href="#cdt-grammar-production-ListElement"><code>ListElement</code></a> production recognizes the substring&nbsp;<var>E</var><sub><var>i</var></sub>:
        </p><ul>
          <li>
            If <var>E</var><sub><var>i</var></sub> is recognized by the <a href="https://www.w3.org/TR/turtle/#grammar-production-IRIREF"><code>IRIREF</code></a> production, then the <var>i</var>-th element in <var>tm</var> is the IRI constructed from the substring <var>E</var><sub><var>i</var></sub> according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-turtle" title="RDF 1.1 Turtle">TURTLE</a></cite>].
            <div class="note" role="note" id="issue-container-generatedID-1"><div role="heading" class="note-title marker" id="h-note-1" aria-level="4"><span>Note</span></div><p class="">
            The procedure described in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-turtle" title="RDF 1.1 Turtle">TURTLE</a></cite>] involves unescaping Turtle's <a href="https://www.w3.org/TR/turtle/#numeric">numeric escape sequences</a>.
            If an IRI appears in the lexical form of a <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-3">cdt:List literal</a> in a SPARQL query, it will be subject to <em>both</em> Turtle's numeric escaping <em>and</em> SPARQL's <a href="https://www.w3.org/TR/sparql11-query/#codepointEscape">Codepoint Escape Sequences</a> [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-query" title="SPARQL 1.1 Query Language">SPARQL11-QUERY</a></cite>].
            For example, including <code>BIND("[&lt;http://example.org/\u005cu0041&gt;]"^^cdt:List AS ?list)</code> in a SPARQL query will result in a <a href="#dfn-well-formed-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-list-literal-1">well-formed cdt:List literal</a> whose <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-literal-value">value</a> is a <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-3">term list</a> with the IRI <code>http://example.org/A</code> as element.
            <br><br>
            In contrast, if the literal <code>"[&lt;http://example.org/\u005cu0041&gt;]"^^cdt:List</code> occurs in a Turtle file, then the literal is not pre-processed for SPARQL's codepoint escape sequences but the IRI inside the lexical form of the literal is still subject to unescaping the numeric escape sequences.
            The result of this unescaping is the substring <code>http://example.org/\u0041</code> which is not a valid IRI.
            </p></div>
            
          </li>
          <li>
            If <var>E</var><sub><var>i</var></sub> is recognized by the <a href="https://www.w3.org/TR/turtle/#grammar-production-BLANK_NODE_LABEL"><code>BLANK_NODE_LABEL</code></a> production, then the <var>i</var>-th element in <var>tm</var> is the blank node constructed from the substring <var>E</var><sub><var>i</var></sub> according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-turtle" title="RDF 1.1 Turtle">TURTLE</a></cite>].
          </li>
          <li>
            If <var>E</var><sub><var>i</var></sub> is recognized by the <a href="#cdt-grammar-production-RDFLiteral"><code>RDFLiteral</code></a> production, then the <var>i</var>-th element in <var>tm</var> is a literal that has as its lexical form the string that has matched the first rule argument, <a href="https://www.w3.org/TR/turtle/#grammar-production-String"><code>String</code></a>, and the datatype IRI and language tag of the literal are as follows.
            <ul>
              <li>If the <a href="https://www.w3.org/TR/turtle/#grammar-production-LANGTAG"><code>LANGTAG</code></a> rule matched, the datatype IRI is <code>rdf:langString</code> and the language tag is the string that has matched the <a href="https://www.w3.org/TR/turtle/#grammar-production-LANGTAG"><code>LANGTAG</code></a> rule.</li>
              <li>If the <code>'^^'</code><a href="https://www.w3.org/TR/turtle/#grammar-production-IRIREF"><code>IRIREF</code></a> rule matched, the datatype IRI is the IRI constructed from the <a href="https://www.w3.org/TR/turtle/#grammar-production-IRIREF"><code>IRIREF</code></a> match according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-turtle" title="RDF 1.1 Turtle">TURTLE</a></cite>], and the literal has no language tag.</li>
              <li>If neither matched, the datatype is <code>xsd:string</code> and the literal has no language tag.</li>
            </ul>
          </li>
          <li>
            If <var>E</var><sub><var>i</var></sub> is recognized by either the <a href="https://www.w3.org/TR/turtle/#grammar-production-NumericLiteral"><code>NumericLiteral</code></a> production or the <a href="https://www.w3.org/TR/turtle/#grammar-production-BooleanLiteral"><code>BooleanLiteral</code></a> production, then the <var>i</var>-th element in <var>tm</var> is the literal constructed from the substring <var>E</var><sub><var>i</var></sub> according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-turtle" title="RDF 1.1 Turtle">TURTLE</a></cite>].
          </li>
          <li>
            If <var>E</var><sub><var>i</var></sub> is recognized by the <a href="#cdt-grammar-production-NULL"><code>NULL</code></a> production, then the <var>i</var>-th element in <var>tm</var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-3">null</a>.
          </li>
          <li>
            If <var>E</var><sub><var>i</var></sub> is recognized by the <a href="#cdt-grammar-production-List"><code>List</code></a> production, then the <var>i</var>-th element in <var>tm</var> is the literal that has the string <var>E</var><sub><var>i</var></sub> as its lexical form, the IRI <code>cdt:List</code> as its datatype IRI, and no language tag.
          </li>
          <li>
            If <var>E</var><sub><var>i</var></sub> is recognized by the <a href="#cdt-grammar-production-Map"><code>Map</code></a> production, then the <var>i</var>-th element in <var>tm</var> is the literal that has the string <var>E</var><sub><var>i</var></sub> as its lexical form, the IRI <code>cdt:Map</code> as its datatype IRI, and no language tag.
          </li>
        </ul>
      <p></p>
      <p>
        Since producing the <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-4">term list</a> for <var>S</var> as defined above relies on the capability to construct RDF terms according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-turtle" title="RDF 1.1 Turtle">TURTLE</a></cite>], it requires a parser that maintains state of the <code>bnodeLabels</code> mapping used for parsing Turtle, as defined in <a href="https://www.w3.org/TR/turtle/#sec-parsing-state">Section&nbsp;7.1</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-turtle" title="RDF 1.1 Turtle">TURTLE</a></cite>].
      </p>

      <div class="note" role="note" id="issue-container-generatedID-2"><div role="heading" class="note-title marker" id="h-note-2" aria-level="4"><span>Note</span></div><p class="">
        By the definition of the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-to-value-mapping">lexical-to-value mapping</a> of the <a href="#dfn-cdt-list-datatype" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-datatype-5">cdt:List datatype</a>, there can be no <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-5">term list</a> that contains a <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-4">cdt:List literal</a> whose <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-literal-value">literal value</a> is that same term list.
      </p></div>

    </section>

    <section id="list-datatype-versus-rdflists" class="informative"><div class="header-wrapper"><h3 id="x3-4-relationship-to-rdf-collections"><bdi class="secno">3.4 </bdi>Relationship to RDF Collections</h3><a class="self-link" href="#list-datatype-versus-rdflists" aria-label="Permalink for Section 3.4"></a></div><p><em>This section is non-normative.</em></p>
      

      <p>
        The RDF Collection vocabulary, as introduced in <a href="https://www.w3.org/TR/rdf-schema/#ch_collectionvocab">Section&nbsp;5.2</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-rdf11-schema" title="RDF Schema 1.1">RDF11-SCHEMA</a></cite>], provides vocabulary terms to describe lists of resources explicitly by using RDF triples. For instance, the triples in the following snippet of Turtle (prefix declarations omitted) describe a list consisting of two resources that are denoted by the IRIs <code>http://example.org/alice</code> and <code>http://example.org/bob</code>, respectively.
      </p>
      <div class="example" id="rdf-list-example">
        <div class="marker">
    <a class="self-link" href="#rdf-list-example">Example<bdi> 14</bdi></a>
  </div> <pre data-content-type="text/turtle" class="nohighlight">ex:book1 ex:authors _:b1 .
_:b1 rdf:first &lt;http://example.org/alice&gt; .
_:b1 rdf:rest _:b2 .
_:b2 rdf:first &lt;http://example.org/bob&gt; .
_:b2 rdf:rest rdf:nil .</pre>
      </div>

      <p>
        Some serialization formats for RDF, including Turtle [<cite><a class="bibref" data-link-type="biblio" href="#bib-turtle" title="RDF 1.1 Turtle">TURTLE</a></cite>], provide some form of shorthand notation based on which such lists can be written in a more concise way. For instance, by using the <a href="https://www.w3.org/TR/turtle/#collections">Turtle syntax for collections</a>, the snippet of Turtle as given in the previous example can be shortened as follows.
      </p>
      <div class="example" id="concise-rdf-list-example">
        <div class="marker">
    <a class="self-link" href="#concise-rdf-list-example">Example<bdi> 15</bdi></a>
  </div> <pre data-content-type="text/turtle" class="nohighlight">ex:book1 ex:authors (&lt;http://example.org/alice&gt; &lt;http://example.org/bob&gt;) .</pre>
      </div>

      <p>
        Note that even if the latter snippet of Turtle looks more compact, it still captures the same set of five RDF triples as the snippet of Turtle in <a href="#rdf-list-example" class="exampleRef box-ref">Example<bdi> 14</bdi></a>.
      </p>

      <p>
        Such lists can be converted into <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-5">cdt:List literals</a> and vice versa. The remainder of this section introduces generic approaches to describe such conversions using the SPARQL language. These approaches are generic in the sense that they do not make any assumptions about the given lists that are to be converted (such as assuming knowledge of the list size or of the absence of duplicate entries).
      </p>

      <p>
        To <strong>convert an RDF collection into a cdt:List literal</strong> by using a SPARQL query, this query needs to traverse the corresponding <code>rdf:rest</code> triples using a <a href="https://www.w3.org/TR/sparql11-query/#propertypaths">property path expression</a>, collect the object of each <code>rdf:first</code> triple along the path, and finally combine these objects as <a href="#dfn-list-element" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-list-element-6">list elements</a> of a <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-6">term list</a> for a <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-6">cdt:List literal</a> by using the FOLD aggregate defined in Section&nbsp;<a href="#fold" class="sectionRef sec-ref"><bdi class="secno">10. </bdi>FOLD</a>. Additionally, to preserve the order of the list elements, grouping needs to be used for each position in the given list and the number of path traversal steps to this position need to be counted. The following query illustrates how this approach can be used in the context of the example data above.
      </p>
      <div class="example" id="duplicate-aware-order-preserving-rdf-list-to-cdt-list-example">
        <div class="marker">
    <a class="self-link" href="#duplicate-aware-order-preserving-rdf-list-to-cdt-list-example">Example<bdi> 16</bdi></a>
  </div> <pre data-content-type="application/sparql-query" class="nohighlight">SELECT ( FOLD(?elmt ORDER BY ?index) AS ?cdtList ) WHERE {
  {
    SELECT ?position (COUNT(?step) AS ?index) WHERE {
      ex:book1 ex:authors ?rdfList .
      ?rdfList rdf:rest* ?step .
      ?step rdf:rest* ?position .
    }
    GROUP BY ?position
  }

  ?position rdf:first ?elmt .
}</pre>
      </div>

      <p>
        If the given list is known to be free of duplicates, the query can be slightly simplified:
      </p>
      <div class="example" id="duplicate-free-order-preserving-rdf-list-to-cdt-list-example">
        <div class="marker">
    <a class="self-link" href="#duplicate-free-order-preserving-rdf-list-to-cdt-list-example">Example<bdi> 17</bdi></a>
  </div> <pre data-content-type="application/sparql-query" class="nohighlight">SELECT ( FOLD(?elmt ORDER BY ?index) AS ?cdtList ) WHERE {
  {
    SELECT ?elmt (COUNT(?step) AS ?index) WHERE {
      ex:book1 ex:authors ?rdfList .
      ?rdfList rdf:rest* ?step .
      ?step rdf:rest* ?position .
      ?position rdf:first ?elmt .
    }
    GROUP BY ?elmt
  }
}</pre>
      </div>

      <p>
        If the order of the list elements does not need to be preserved, an even simpler version of the query without grouping and counting can be used (which is also duplicate preserving in case the given list contains duplicate entries):
      </p>
      <div class="example" id="order-agnostic-rdf-list-to-cdt-list-example">
        <div class="marker">
    <a class="self-link" href="#order-agnostic-rdf-list-to-cdt-list-example">Example<bdi> 18</bdi></a>
  </div> <pre data-content-type="application/sparql-query" class="nohighlight">SELECT ( FOLD(?elmt) AS ?cdtList ) WHERE {
  ex:book1 ex:authors ?rdfList .
  ?rdfList rdf:rest/rdf:first ?elmt .
}</pre>
      </div>

      <p>
        To <strong>convert a cdt:List literal into an RDF collection</strong> a <code>CONSTRUCT</code> query needs to be used that produces the relevant RDF triples based on the RDF collection vocabulary. The <code>WHERE</code> clause of such a query needs to use the <code>UNFOLD</code> operator (see Section&nbsp;<a href="#unfold" class="sectionRef sec-ref"><bdi class="secno">11. </bdi>UNFOLD</a>) to obtain each <a href="#dfn-list-element" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-list-element-7">list element</a> together with its position within the <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-7">term list</a> represented by the given cdt:List literal. The positions can then be associated with blank nodes to be used for the various resources based on which the structure of the created RDF collection is built (the following query creates a <a href="#dfn-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-literal-2">cdt:Map literal</a> as an intermediary structure for this purpose). Special care needs to be taken to correctly close the RDF collection with the term <code>rdf:nil</code>, for which the position of each element needs to be compared with the size of the list (as can be obtained with the <code>cdt:size</code> function defined in Section&nbsp;<a href="#func_size" class="sectionRef sec-ref"><bdi class="secno">6.2 </bdi>cdt:size</a>). Finally, to properly handle empty lists as well, the whole query pattern <em>for the non-empty lists</em> needs to be placed within an <code>OPTIONAL</code> block and a second <code>OPTIONAL</code> block needs to be added to cover the cases of empty lists. The following query illustrates this approach for all cdt:List literals in the object positions of triples with the IRI <code>ex:authorList</code> as predicate.
      </p>
      <div class="example" id="complete-cdt-list-to-rdf-list-example">
        <div class="marker">
    <a class="self-link" href="#complete-cdt-list-to-rdf-list-example">Example<bdi> 19</bdi></a>
  </div> <pre data-content-type="application/sparql-query" class="nohighlight">CONSTRUCT {
  ?s ex:authors ?firstStep .
  ?thisStep rdf:first ?elmt .
  ?thisStep rdf:rest ?rest .
}
WHERE {
  OPTIONAL { # for the cases of non-empty lists
    {
      SELECT ?s ?list (FOLD(?pos, BNODE()) AS ?listHeads) WHERE {
        ?s ex:authorList ?list .
        FILTER( DATATYPE(?list) = cdt:List )
        UNFOLD( ?list AS ?elmt, ?pos )
      }
      GROUP BY ?s ?list
    }

    UNFOLD( ?list AS ?elmt, ?pos )
    BIND( cdt:get(?listHeads, ?pos) AS ?thisStep )
    BIND( cdt:size(?list) AS ?size )
    BIND( IF( ?pos=?size,
              rdf:nil,
              cdt:get(?listHeads, ?pos+1)
          ) AS ?rest )
    BIND( cdt:get(?listHeads, 1) AS ?firstStep )
  }
  OPTIONAL { # for the cases of empty lists
    ?s ex:authorList ?list .
    FILTER( DATATYPE(?list) = cdt:List )
    FILTER( cdt:size(?list) = 0 )
    BIND( rdf:nil AS ?firstStep )
  }
}</pre>
      </div>

      <p>
        It needs to be emphasized that, for cdt:List literals that represent term lists with <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-4">null</a> values, the given query creates no <code>rdf:first</code> triples for the corresponding positions in the resulting RDF collection (but the <code>rdf:rest</code> triples for these positions are created by the query). The reason for this is that the <code>UNFOLD</code> operator leaves the variable <code>?elmt</code> unbound for the positions where a term list has a null value.
      </p>

      <p>
        Notice also that the query contains two <code>FILTER</code> clauses (one in each <code>OPTIONAL</code> block) that ensure the datatype of the literals bound to the variable <code>?list</code> is indeed <code>cdt:List</code>. The purpose of these two <code>FILTER</code> clauses is to avoid accidentially creating RDF collections from potentially matching cdt:Map literals (as the <code>UNFOLD</code> operator and the <code>cdt:size</code> function can be applied to such literals as well). For cases in which it is guaranteed, however, that <code>?list</code> would not be bound to any cdt:Map literal, the query can be slightly simplified by removing these two <code>FILTER</code> clauses.
      </p>

      <p>
        Another possible simplification (orthogonal to aforementioned one about removing the two <code>FILTER</code> clauses) can be applied if the cdt:List literals that are to be converted are guaranteed to represent only nonempty term lists. In this case, the whole pattern within the first <code>OPTIONAL</code> block does not need to be wrapped within an <code>OPTIONAL</code> block and the second <code>OPTIONAL</code> block can be removed completely.
      </p>

    </section>

  </section>



  <section id="map-datatype"><div class="header-wrapper"><h2 id="x4-the-cdt-map-datatype"><bdi class="secno">4. </bdi>The cdt:Map Datatype</h2><a class="self-link" href="#map-datatype" aria-label="Permalink for Section 4."></a></div>
    

    <p>
      The <dfn data-lt="cdt:Map datatype" id="dfn-cdt-map-datatype" tabindex="0" aria-haspopup="dialog" data-dfn-type="dfn">cdt:Map datatype</dfn> is the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-datatype">RDF datatype</a> that consists of the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-value-space">value space</a>, the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-space">lexical space</a>, and the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-to-value-mapping">lexical-to-value mapping</a> defined in this section (see Subsections <a href="#map-datatype-valuespace" class="sectionRef sec-ref"><bdi class="secno">4.1 </bdi>Value Space</a>, <a href="#map-datatype-lexspace" class="sectionRef sec-ref"><bdi class="secno">4.2 </bdi>Lexical Space</a>, and <a href="#map-datatype-lex-to-value-mapping" class="sectionRef sec-ref"><bdi class="secno">4.3 </bdi>Lexical-To-Value Mapping</a>, respectively), and that is denoted by the following <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-datatype-iri">datatype IRI</a>:
    </p>
    <p>
      <code>http://w3id.org/awslabs/neptune/SPARQL-CDTs/Map</code>
    </p>
    <p>
      Every <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-literal">literal</a> that has this IRI as its <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-datatype-iri">datatype IRI</a> is called a <dfn data-lt="cdt:Map literal" data-plurals="cdt:map literals" id="dfn-cdt-map-literal" tabindex="0" aria-haspopup="dialog" data-dfn-type="dfn">cdt:Map literal</dfn>. If the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form">lexical form</a> of such a literal is in the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-space">lexical space</a> of the <a href="#dfn-cdt-map-datatype" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-datatype-1">cdt:Map datatype</a>, as defined in Section&nbsp;<a href="#map-datatype-lexspace" class="sectionRef sec-ref"><bdi class="secno">4.2 </bdi>Lexical Space</a>, then the literal is called a <dfn data-lt="well-formed cdt:Map literal" data-plurals="well-formed cdt:map literals" id="dfn-well-formed-cdt-map-literal" tabindex="0" aria-haspopup="dialog" data-dfn-type="dfn">well-formed cdt:Map literal</dfn>. In contrast, a <a href="#dfn-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-literal-3">cdt:Map literal</a> whose lexical form is not in the lexical space of the cdt:Map datatype is called an <dfn data-lt="ill-formed cdt:Map literal" id="dfn-ill-formed-cdt-map-literal" tabindex="0" aria-haspopup="dialog" data-dfn-type="dfn">ill-formed cdt:Map literal</dfn>.
    </p>

    <section id="map-datatype-valuespace"><div class="header-wrapper"><h3 id="x4-1-value-space"><bdi class="secno">4.1 </bdi>Value Space</h3><a class="self-link" href="#map-datatype-valuespace" aria-label="Permalink for Section 4.1"></a></div>
      

      <p>
        The <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-value-space">value space</a> of the <a href="#dfn-cdt-map-datatype" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-datatype-2">cdt:Map datatype</a> consists of all <a href="https://en.wikipedia.org/wiki/Function_(mathematics)">functions</a> that map from a <em>finite</em> set of <a href="#dfn-map-key" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-key-1">map keys</a> to the set of <a href="#dfn-map-value" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-value-2">map values</a>, where the notion of a <dfn data-lt="map key" data-plurals="map keys" id="dfn-map-key" tabindex="0" aria-haspopup="dialog" data-dfn-type="dfn">map key</dfn> is defined as follows:
        </p><ul>
          <li>every <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-iri">IRI</a> is a map key and</li>
          <li>every <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-literal">literal</a> is a map key,</li>
        </ul>
        and the notion of a <dfn data-lt="map value" data-plurals="map values" id="dfn-map-value" tabindex="0" aria-haspopup="dialog" data-dfn-type="dfn">map value</dfn> is defined as follows:
        <ul>
          <li>every <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-rdf-term">RDF term</a> is a map value (i.e., every <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-iri">IRI</a>, <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-literal">literal</a>, and <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-blank-node">blank node</a>) and</li>
          <li><a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-5">null</a> is a map value.</li>
        </ul>
        Any such function is called <dfn data-lt="term map" data-plurals="term maps" id="dfn-term-map" tabindex="0" aria-haspopup="dialog" data-dfn-type="dfn">term map</dfn>, and the <a href="https://en.wikipedia.org/wiki/Function_(mathematics)#empty_function">empty function</a> for the set of <a href="#dfn-map-value" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-value-3">map values</a> (i.e., the function that maps from the empty set to the set of <a href="#dfn-map-value" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-value-4">map values</a>) is the <dfn data-lt="empty term map" id="dfn-empty-term-map" tabindex="0" aria-haspopup="dialog" data-dfn-type="dfn">empty term map</dfn>.
        Moreover, every pair&nbsp;(<var>k</var>,<var>v</var>) consisting of a <a href="#dfn-map-key" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-key-2">map key</a>&nbsp;<var>k</var> and a <a href="#dfn-map-value" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-value-5">map value</a>&nbsp;<var>v</var> is called a <dfn data-lt="map entry" data-plurals="map entries" id="dfn-map-entry" tabindex="0" aria-haspopup="dialog" data-dfn-type="dfn">map entry</dfn> where <var>k</var> is called the <dfn data-lt="key of map entry|key" data-plurals="keys" id="dfn-key-of-map-entry" tabindex="0" aria-haspopup="dialog" data-dfn-type="dfn">key</dfn> of the map entry and <var>v</var> is called the <dfn data-lt="value of map entry|value" id="dfn-value-of-map-entry" tabindex="0" aria-haspopup="dialog" data-dfn-type="dfn">value</dfn> of the map entry.
      <p></p>
      <p>
        Given a <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-1">term map</a>&nbsp;<var>tm</var> and a <a href="#dfn-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-entry-1">map entry</a>&nbsp;(<var>k</var>,<var>v</var>), we say that <var>tm</var> <dfn data-lt="contains map entry|contains" data-plurals="contain" id="dfn-contains-map-entry" tabindex="0" aria-haspopup="dialog" data-dfn-type="dfn">contains</dfn> this map entry if <var>k</var> is in the <a href="https://en.wikipedia.org/wiki/Domain_of_a_function">domain</a> of <var>tm</var> and <var>tm</var> maps <var>k</var> to <var>v</var>; i.e., <var>tm</var>(<var>k</var>)=<var>v</var>.
      </p>

      <div class="note" role="note" id="issue-container-generatedID-3"><div role="heading" class="note-title marker" id="h-note-3" aria-level="4"><span>Note</span></div><p class="">
        The <a href="#dfn-empty-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-map-1">empty term map</a> does not <a href="#dfn-contains-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-contains-map-entry-1">contain</a> any map entries.
      </p></div>

      <div class="note" role="note" id="issue-container-generatedID-4"><div role="heading" class="note-title marker" id="h-note-4" aria-level="4"><span>Note</span></div><div class="">
        <p>
          A <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-2">term map</a> <em class="rfc2119">MAY</em> <a href="#dfn-contains-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-contains-map-entry-2">contain</a> multiple map entries that all have the same <a href="#dfn-value-of-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-value-of-map-entry-1">value</a>, but they <em class="rfc2119">MUST</em> have different <a href="#dfn-key-of-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-key-of-map-entry-1">keys</a>. It is possible, however, that multiple map entries of a term map <em class="rfc2119">MAY</em> have literals with the same <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-literal-value">literal value</a> as their respective keys, as long as all these literals have a different lexical form. For instance, a term map <em class="rfc2119">MAY</em> contain two map entries, (<var>k</var>,<var>v</var>) and (<var>k'</var>,<var>v'</var>), such that <var>k</var> is the literal <code>"0042"^^xsd:integer</code> and <var>k'</var> is the literal <code>"42"^^xsd:integer</code> (using a Turtle representation of these literals for the sake of readability). Clearly, these are two different literals and, thus, two different map keys, but their literal value is the same (the integer&nbsp;42).
        </p>
        <p>
          Distinguishing map keys that are literals based on their lexical form rather than their value is a deliberate design decision. If the distinction was based on the value instead, then the distinction could be made only for literals with <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-recognized-datatype-iris">recognized datatype IRIs</a>. This would not only raise the question of what to do with map keys that are literals with an unrecognized datatype IRI, but it would also make the notion of map keys (and what makes them different from one another) dependent on the set of datatype IRIs recognized by the RDF processing system. Such a dependency may then result in different and potentially incompatible behavior in terms of how cdt:Map literals are handled by different RDF processing systems that support different sets of recognized datatype IRIs. Distinguishing map keys that are literals based on their lexical form avoids such incompatibilities.
        </p>
      </div></div>

    </section>

    <section id="map-datatype-lexspace"><div class="header-wrapper"><h3 id="x4-2-lexical-space"><bdi class="secno">4.2 </bdi>Lexical Space</h3><a class="self-link" href="#map-datatype-lexspace" aria-label="Permalink for Section 4.2"></a></div>
      

      <p>
        The <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-space">lexical space</a> of the <a href="#dfn-cdt-map-datatype" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-datatype-3">cdt:Map datatype</a> consists of all strings that are recognized by the <a href="#cdt-grammar-production-Map"><code>Map</code></a> production of the grammar defined in Section&nbsp;<a href="#list-datatype-lexspace" class="sectionRef sec-ref"><bdi class="secno">3.2 </bdi>Lexical Space</a> and in which all substrings that matched the <a href="#cdt-grammar-production-MapKey"><code>MapKey</code></a> production are different from one another.
      </p>

      <div class="issue" id="issue-container-number-1"><div role="heading" class="issue-title marker" id="h-issue" aria-level="4"><span>Issue 1</span></div><div class="">
        <p>
          The constraint about the substrings is not restrictive enough because the <a href="#cdt-grammar-production-MapKey"><code>MapKey</code></a> production recognizes both the generic way of serializing literals in Turtle and the Turtle shorthand notations for some datatypes. For instance, consider the following string:
        </p>
        <pre class="nohighlight">"{ 42 : 'value1',  '42'^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt; : 'value2' }"</pre>
        <p>
          This string satisfies the definition given above (including the constraint about the substrings) and, thus, would be a valid lexical form for cdt:Map literals. Yet, the keys of the two map entries represented in this string are the exact same literal, which is illegal according to the definition of <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-3">term maps</a>.
        </p>
      </div></div>

    </section>

    <section id="map-datatype-lex-to-value-mapping"><div class="header-wrapper"><h3 id="x4-3-lexical-to-value-mapping"><bdi class="secno">4.3 </bdi>Lexical-To-Value Mapping</h3><a class="self-link" href="#map-datatype-lex-to-value-mapping" aria-label="Permalink for Section 4.3"></a></div>
      

      <p>
        The <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-to-value-mapping">lexical-to-value mapping</a> of the <a href="#dfn-cdt-map-datatype" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-datatype-4">cdt:Map datatype</a> is defined as follows for every string&nbsp;<var>S</var> that is recognized by the <a href="#cdt-grammar-production-Map"><code>Map</code></a> production of the grammar defined in Section&nbsp;<a href="#list-datatype-lexspace" class="sectionRef sec-ref"><bdi class="secno">3.2 </bdi>Lexical Space</a>.
      </p>
      <p>
        If the string&nbsp;<var>S</var> does <em>not</em> contain a substring that is recognized by the <a href="#cdt-grammar-production-NonEmptyMapContent"><code>NonEmptyMapContent</code></a> production of the grammar, then <var>S</var> is mapped to the <a href="#dfn-empty-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-map-2">empty term map</a>.
      </p>
      <p>
        Otherwise, let <var>S</var>' be the greatest substring of <var>S</var> that is recognized by the <a href="#cdt-grammar-production-NonEmptyMapContent"><code>NonEmptyMapContent</code></a> production, let (<var>E</var><sub>1</sub>, ..., <var>E</var><sub><var>n</var></sub>) be the sequence of all substrings of <var>S</var>' that are recognized by the <a href="#cdt-grammar-production-MapEntry"><code>MapEntry</code></a> production, and for every <var>i</var> in {1, ..., <var>n</var>}, let <var>K<sub><var>i</var></sub></var> and <var>V<sub><var>i</var></sub></var> be the substrings of <var>E</var><sub><var>i</var></sub> that are recognized by the <a href="#cdt-grammar-production-MapKey"><code>MapKey</code></a> and the <a href="#cdt-grammar-production-MapValue"><code>MapValue</code></a> productions, respectively.
        Then, <var>S</var> is mapped to the <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-4">term map</a>&nbsp;<var>tm</var> that <a href="#dfn-contains-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-contains-map-entry-3">contains</a> <var>n</var> <a href="#dfn-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-entry-2">map entries</a>, one for each substring&nbsp;<var>E</var><sub><var>i</var></sub>, where <var>i</var> in {1, ..., <var>n</var>}. The particular map entry (<var>k<sub><var>i</var></sub></var>,<var>v<sub><var>i</var></sub></var>) that <var>tm</var> contains for <var>E</var><sub><var>i</var></sub> depends on which of the cases of the <a href="#cdt-grammar-production-MapKey"><code>MapKey</code></a> and the <a href="#cdt-grammar-production-MapValue"><code>MapValue</code></a> productions recognize <var>K<sub><var>i</var></sub></var> and <var>V<sub><var>i</var></sub></var>. In particular, depending on <var>K<sub><var>i</var></sub></var>, <var>k<sub><var>i</var></sub></var> is defined as follows.
        </p><ul>
          <li>
            If <var>K<sub><var>i</var></sub></var> is recognized by the <a href="https://www.w3.org/TR/turtle/#grammar-production-IRIREF"><code>IRIREF</code></a> production, then <var>k<sub><var>i</var></sub></var> is the IRI constructed from the substring <var>K<sub><var>i</var></sub></var> according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-turtle" title="RDF 1.1 Turtle">TURTLE</a></cite>].
          </li>
          <li>
            If <var>K<sub><var>i</var></sub></var> is recognized by the <a href="#cdt-grammar-production-RDFLiteral"><code>RDFLiteral</code></a> production, then <var>k<sub><var>i</var></sub></var> is a literal that has as its lexical form the string that has matched the first rule argument, <a href="https://www.w3.org/TR/turtle/#grammar-production-String"><code>String</code></a>, and the datatype IRI and language tag of the literal are as follows.
            <ul>
              <li>If the <a href="https://www.w3.org/TR/turtle/#grammar-production-LANGTAG"><code>LANGTAG</code></a> rule matched, the datatype IRI is <code>rdf:langString</code> and the language tag is the string that has matched the <a href="https://www.w3.org/TR/turtle/#grammar-production-LANGTAG"><code>LANGTAG</code></a> rule.</li>
              <li>If the <code>'^^'</code><a href="https://www.w3.org/TR/turtle/#grammar-production-IRIREF"><code>IRIREF</code></a> rule matched, the datatype IRI is the IRI constructed from the <a href="https://www.w3.org/TR/turtle/#grammar-production-IRIREF"><code>IRIREF</code></a> match according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-turtle" title="RDF 1.1 Turtle">TURTLE</a></cite>], and the literal has no language tag.</li>
              <li>If neither matched, the datatype is <code>xsd:string</code> and the literal has no language tag.</li>
            </ul>
          </li>
          <li>
            If <var>K<sub><var>i</var></sub></var> is recognized by either the <a href="https://www.w3.org/TR/turtle/#grammar-production-NumericLiteral"><code>NumericLiteral</code></a> production or the <a href="https://www.w3.org/TR/turtle/#grammar-production-BooleanLiteral"><code>BooleanLiteral</code></a> production, then <var>k<sub><var>i</var></sub></var> is the literal constructed from the substring <var>K<sub><var>i</var></sub></var> according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-turtle" title="RDF 1.1 Turtle">TURTLE</a></cite>].
          </li>
        </ul>
        Moreover, depending on <var>V<sub><var>i</var></sub></var>, <var>v<sub><var>i</var></sub></var> is defined as follows.
        <ul>
          <li>
            If <var>V<sub><var>i</var></sub></var> is recognized by the <a href="https://www.w3.org/TR/turtle/#grammar-production-IRIREF"><code>IRIREF</code></a> production, then <var>v<sub><var>i</var></sub></var> is the IRI constructed from the substring <var>V<sub><var>i</var></sub></var> according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-turtle" title="RDF 1.1 Turtle">TURTLE</a></cite>].
          </li>
          <li>
            If <var>V<sub><var>i</var></sub></var> is recognized by the <a href="https://www.w3.org/TR/turtle/#grammar-production-BLANK_NODE_LABEL"><code>BLANK_NODE_LABEL</code></a> production, then <var>v<sub><var>i</var></sub></var> is the blank node constructed from the substring <var>V<sub><var>i</var></sub></var> according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-turtle" title="RDF 1.1 Turtle">TURTLE</a></cite>].
          </li>
          <li>
            If <var>V<sub><var>i</var></sub></var> is recognized by the <a href="#cdt-grammar-production-RDFLiteral"><code>RDFLiteral</code></a> production, then <var>v<sub><var>i</var></sub></var> is a literal that has as its lexical form the string that has matched the first rule argument, <a href="https://www.w3.org/TR/turtle/#grammar-production-String"><code>String</code></a>, and the datatype IRI and language tag of the literal are as follows.
            <ul>
              <li>If the <a href="https://www.w3.org/TR/turtle/#grammar-production-LANGTAG"><code>LANGTAG</code></a> rule matched, the datatype IRI is <code>rdf:langString</code> and the language tag is the string that has matched the <a href="https://www.w3.org/TR/turtle/#grammar-production-LANGTAG"><code>LANGTAG</code></a> rule.</li>
              <li>If the <code>'^^'</code><a href="https://www.w3.org/TR/turtle/#grammar-production-IRIREF"><code>IRIREF</code></a> rule matched, the datatype IRI is the IRI constructed from the <a href="https://www.w3.org/TR/turtle/#grammar-production-IRIREF"><code>IRIREF</code></a> match according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-turtle" title="RDF 1.1 Turtle">TURTLE</a></cite>], and the literal has no language tag.</li>
              <li>If neither matched, the datatype is <code>xsd:string</code> and the literal has no language tag.</li>
            </ul>
          </li>
          <li>
            If <var>V<sub><var>i</var></sub></var> is recognized by either the <a href="https://www.w3.org/TR/turtle/#grammar-production-NumericLiteral"><code>NumericLiteral</code></a> production or the <a href="https://www.w3.org/TR/turtle/#grammar-production-BooleanLiteral"><code>BooleanLiteral</code></a> production, then <var>v<sub><var>i</var></sub></var> is the literal constructed from the substring <var>V<sub><var>i</var></sub></var> according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-turtle" title="RDF 1.1 Turtle">TURTLE</a></cite>].
          </li>
          <li>
            If <var>V<sub><var>i</var></sub></var> is recognized by the <a href="#cdt-grammar-production-NULL"><code>NULL</code></a> production, then <var>v<sub><var>i</var></sub></var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-6">null</a>.
          </li>
          <li>
            If <var>V<sub><var>i</var></sub></var> is recognized by the <a href="#cdt-grammar-production-List"><code>List</code></a> production, then <var>v<sub><var>i</var></sub></var> is the literal that has the string <var>V<sub><var>i</var></sub></var> as its lexical form, the IRI <code>cdt:List</code> as its datatype IRI, and no language tag.
          </li>
          <li>
            If <var>V<sub><var>i</var></sub></var> is recognized by the <a href="#cdt-grammar-production-Map"><code>Map</code></a> production, then <var>v<sub><var>i</var></sub></var> is the literal that has the string <var>V<sub><var>i</var></sub></var> as its lexical form, the IRI <code>cdt:Map</code> as its datatype IRI, and no language tag.
          </li>
        </ul>
      <p></p>
      <p>
        Since producing the <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-5">term map</a> for <var>S</var> as defined above relies on the capability to construct RDF terms according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-turtle" title="RDF 1.1 Turtle">TURTLE</a></cite>], it requires a parser that maintains state of the <code>bnodeLabels</code> mapping used for parsing Turtle, as defined in <a href="https://www.w3.org/TR/turtle/#sec-parsing-state">Section&nbsp;7.1</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-turtle" title="RDF 1.1 Turtle">TURTLE</a></cite>].
      </p>

      <div class="note" role="note" id="issue-container-generatedID-5"><div role="heading" class="note-title marker" id="h-note-5" aria-level="4"><span>Note</span></div><p class="">
        The note about unescaping of IRIs as given in Section&nbsp;<a href="#list-datatype-lex-to-value-mapping" class="sectionRef sec-ref"><bdi class="secno">3.3 </bdi>Lexical-To-Value Mapping</a> applies here too.
      </p></div>

    </section>

    <section id="map-datatype-versus-json" class="informative"><div class="header-wrapper"><h3 id="x4-4-relationship-to-json"><bdi class="secno">4.4 </bdi>Relationship to JSON</h3><a class="self-link" href="#map-datatype-versus-json" aria-label="Permalink for Section 4.4"></a></div><p><em>This section is non-normative.</em></p>
      

      <p>
        By the definition of the lexical space of the <a href="#dfn-cdt-map-datatype" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-datatype-5">cdt:Map datatype</a> (see Section&nbsp;<a href="#map-datatype-lexspace" class="sectionRef sec-ref"><bdi class="secno">4.2 </bdi>Lexical Space</a>), strings that match the <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-4"><code>object</code></a> production of the grammar of the JavaScript Object Notation (JSON) [<cite><a class="bibref" data-link-type="biblio" href="#bib-rfc8259" title="The JavaScript Object Notation (JSON) Data Interchange Format">RFC8259</a></cite>] can generally be used as a lexical form of a <a href="#dfn-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-literal-4">cdt:Map literal</a> (with a few exceptions related to escaping of characters in strings, see the corresponding note in the following list). When doing so, the lexical-to-value mapping of the <a href="#dfn-cdt-map-datatype" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-datatype-6">cdt:Map datatype</a> (see Section&nbsp;<a href="#map-datatype-lex-to-value-mapping" class="sectionRef sec-ref"><bdi class="secno">4.3 </bdi>Lexical-To-Value Mapping</a>) interprets the various elements of the JSON format as follows.
        </p><ul>
          <li>
            The <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-4">JSON object</a> that is used as the lexical form of the given <a href="#dfn-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-literal-5">cdt:Map literal</a> is mapped to a <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-6">term map</a>. Every name-value pair of the JSON object becomes a <a href="#dfn-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-entry-3">map entry</a> that is <a href="#dfn-contains-map-entry" id="ref-for-dfn-contains-map-entry-4">contained</a> in the resulting term map. The <a href="#dfn-map-key" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-key-3">map key</a> of each such map entry is a literal created from the name of the corresponding name-value pair by using the rule for JSON string values as defined below. The <a href="#dfn-map-value" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-value-6">map value</a> of each such map entry depends on the type of the value of the corresponding name-value pair.
          </li>
          <li>
            A <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-3">JSON value</a> that is another <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-4">JSON object</a> is mapped to a <a href="#dfn-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-literal-6">cdt:Map literal</a> that has the JSON object as its lexical form.
          </li>
          <li>
            A <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-3">JSON value</a> that is an <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-5">array</a> is mapped to a <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-7">cdt:List literal</a> that has the JSON object as its lexical form.
          </li>
          <li>
            A <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-3">JSON value</a> that is a <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-6">number</a> is mapped to a literal with the number as the lexical form, no language tag, and a datatype IRI that is determined based on the following rules.
            <ul>
              <li>If the number has an exponent part (see the <code>exp</code> production of the JSON grammar), then the datatype IRI is <code>xsd:double</code>.</li>
              <li>If the number has no exponent part but it has a fraction part (see the <code>frac</code> production of the JSON grammar), then the datatype IRI is <code>xsd:decimal</code>.</li>
              <li>If the number has no exponent part and no fraction part, then the datatype IRI is <code>xsd:integer</code>.</li>
            </ul>
          </li>
          <li>
            A <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-3">JSON value</a> that is a <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-7">string</a> is mapped to a literal with datatype <code>xsd:string</code>, no language tag, and a lexical form that is the result of using the sequence of characters between the first and the last quotation mark of the string and applying Turtle's unescaping of <a href="https://www.w3.org/TR/turtle/#numeric">numeric escape sequences</a> and <a href="https://www.w3.org/TR/turtle/#string">string escape sequences</a> to this sequence of characters.
            <div class="note" role="note" id="issue-container-generatedID-6"><div role="heading" class="note-title marker" id="h-note-6" aria-level="4"><span>Note</span></div><p class="">
              The support for escaping of characters in <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-7">strings</a> in JSON goes beyond the <a href="https://www.w3.org/TR/turtle/#numeric">numeric escape sequences</a> and <a href="https://www.w3.org/TR/turtle/#string">string escape sequences</a> in Turtle. In particular, while both Turtle's string escape sequences and JSON support the two-character sequence '\\' to represent the reverse solidus character (i.e., codepoint <a href="https://util.unicode.org/UnicodeJsps/character.jsp?a=005C">U+005C</a> in Unicode), only JSON supports the two-character sequence '\/' to represent the solidus character (codepoint <a href="https://util.unicode.org/UnicodeJsps/character.jsp?a=002F">U+002F</a>). JSON strings that use this two-character escape sequence cannot be used as a lexical form of a cdt:Map literal; attempting to do so will result in a parser error. Moreover, JSON supports encoding of UTF-16 surrogate pairs using 12-character sequences of the form '\uNNNN\uNNNN' which are not recognized by the numeric escape sequences of Turtle as a singular pair. Hence, when using a JSON string with such surrogate pairs as a lexical form of a cdt:Map literal, then the surrogate pairs are not unescaped correctly.
            </p></div>
          </li>
          <li>
            A <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-3">JSON value</a> that is the name <code>false</code> or the name <code>true</code> is mapped to a literal with datatype <code>xsd:boolean</code>, no language tag, and a lexical form that is the JSON value (i.e., <code>false</code> or <code>true</code>).
          </li>
          <li>
            A <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-3">JSON value</a> that is the name <code>null</code> is mapped to <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-7">null</a>.
          </li>
        </ul>
      <p></p>

    </section>

  </section>



  <section id="extension-of-sparql-operators"><div class="header-wrapper"><h2 id="x5-extensions-of-existing-sparql-operators"><bdi class="secno">5. </bdi>Extensions of Existing SPARQL Operators</h2><a class="self-link" href="#extension-of-sparql-operators" aria-label="Permalink for Section 5."></a></div>
    

    <p>
      This section defines extensions of some of the existing operators of SPARQL. In particular, the <code>=</code> operator and the <code>!=</code> operator are extended both for <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-8">cdt:List literals</a> and for <a href="#dfn-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-literal-7">cdt:Map literals</a>. Implementations of SPARQL that recognize the datatypes defined above <em class="rfc2119">MUST</em> implement these operators with the extensions defined in this section.
    </p>

    <p>
      To define the extensions formally, the operator mapping table for binary operators in <a href="https://www.w3.org/TR/sparql11-query/#OperatorMapping">Section&nbsp;17.3</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-query" title="SPARQL 1.1 Query Language">SPARQL11-QUERY</a></cite>] is extended with the following twelve rows.
    </p>

    <table class="operator">
      <thead>
        <tr>
          <th>Operator</th>
          <th>Type(A)</th>
          <th>Type(B)</th>
          <th>Function</th>
          <th>Result type</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="font-weight:bold">
          <a href="https://www.w3.org/TR/sparql11-query/#rRelationalExpression">A = B</a></td>
          <td>cdt:List</td>
          <td>cdt:List</td>
          <td><a href="#func_list-equal">list-equal</a>(A, B)</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a href="https://www.w3.org/TR/sparql11-query/#rRelationalExpression">A = B</a></td>
          <td>cdt:Map</td>
          <td>cdt:Map</td>
          <td><a href="#func_map-equal">map-equal</a>(A, B)</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a href="https://www.w3.org/TR/sparql11-query/#rRelationalExpression">A != B</a></td>
          <td>cdt:List</td>
          <td>cdt:List</td>
          <td><a href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a href="#func_list-equal">list-equal</a>(A, B))</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a href="https://www.w3.org/TR/sparql11-query/#rRelationalExpression">A != B</a></td>
          <td>cdt:Map</td>
          <td>cdt:Map</td>
          <td><a href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a href="#func_map-equal">map-equal</a>(A, B))</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a href="https://www.w3.org/TR/sparql11-query/#rRelationalExpression">A &lt; B</a></td>
          <td>cdt:List</td>
          <td>cdt:List</td>
          <td><a href="#func_list-less-than">list-less-than</a>(A, B)</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a href="https://www.w3.org/TR/sparql11-query/#rRelationalExpression">A &lt; B</a></td>
          <td>cdt:Map</td>
          <td>cdt:Map</td>
          <td><a href="#func_map-less-than">map-less-than</a>(A, B)</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a href="https://www.w3.org/TR/sparql11-query/#rRelationalExpression">A &gt; B</a></td>
          <td>cdt:List</td>
          <td>cdt:List</td>
          <td><a href="#func_list-less-than">list-less-than</a>(B, A)</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a href="https://www.w3.org/TR/sparql11-query/#rRelationalExpression">A &gt; B</a></td>
          <td>cdt:Map</td>
          <td>cdt:Map</td>
          <td><a href="#func_map-less-than">map-less-than</a>(B, A)</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a href="https://www.w3.org/TR/sparql11-query/#rRelationalExpression">A &lt;= B</a></td>
          <td>cdt:List</td>
          <td>cdt:List</td>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-logical-or">logical-or</a>(<a href="#func_list-less-than">list-less-than</a>(A, B), <a href="#func_list-equal">list-equal</a>(A, B))</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a href="https://www.w3.org/TR/sparql11-query/#rRelationalExpression">A &lt;= B</a></td>
          <td>cdt:Map</td>
          <td>cdt:Map</td>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-logical-or">logical-or</a>(<a href="#func_map-less-than">map-less-than</a>(A, B), <a href="#func_map-equal">map-equal</a>(A, B))</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a href="https://www.w3.org/TR/sparql11-query/#rRelationalExpression">A &gt;= B</a></td>
          <td>cdt:List</td>
          <td>cdt:List</td>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-logical-or">logical-or</a>(<a href="#func_list-less-than">list-less-than</a>(B, A), <a href="#func_list-equal">list-equal</a>(A, B))</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a href="https://www.w3.org/TR/sparql11-query/#rRelationalExpression">A &gt;= B</a></td>
          <td>cdt:Map</td>
          <td>cdt:Map</td>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-logical-or">logical-or</a>(<a href="#func_map-less-than">map-less-than</a>(B, A), <a href="#func_map-equal">map-equal</a>(A, B))</td>
          <td>xsd:boolean</td>
        </tr>
      </tbody>
    </table>

    <p>
      The four new functions used in these table rows are defined in Subsections&nbsp;<a href="#func_list-equal" class="sectionRef sec-ref"><bdi class="secno">5.1 </bdi>list-equal</a>, <a href="#func_map-equal" class="sectionRef sec-ref"><bdi class="secno">5.2 </bdi>map-equal</a>, <a href="#func_list-less-than" class="sectionRef sec-ref"><bdi class="secno">5.3 </bdi>list-less-than</a>, and <a href="#func_map-less-than" class="sectionRef sec-ref"><bdi class="secno">5.4 </bdi>map-less-than</a> below.
    </p>

    <div class="note" role="note" id="issue-container-generatedID-7"><div role="heading" class="note-title marker" id="h-note-7" aria-level="3"><span>Note</span></div><p class="">
      It should be noted that extending the operator mapping table with these twelve rows changes the behavior of the corresponding operators (<code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code>) only for cases in which these operators would otherwise (i.e., without the extension) yield a type error. Therefore, this extension is conformant with the SPARQL specification, as explicitly stated in <a href="https://www.w3.org/TR/sparql11-query/#operatorExtensibility">Section&nbsp;17.3.1</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-query" title="SPARQL 1.1 Query Language">SPARQL11-QUERY</a></cite>].
    </p></div>

    <section id="func_list-equal"><div class="header-wrapper"><h3 id="x5-1-list-equal"><bdi class="secno">5.1 </bdi>list-equal</h3><a class="self-link" href="#func_list-equal" aria-label="Permalink for Section 5.1"></a></div>
      

      <p>
        <code>xsd:boolean </code>
        <code style="color:black;font-weight:bold">list-equal</code>
        (
           <code><a href="#dfn-cdt-list-literal" id="ref-for-dfn-cdt-list-literal-9">cdt:List</a> <var>term<sub>1</sub></var></code>,
           <code><a href="#dfn-cdt-list-literal" id="ref-for-dfn-cdt-list-literal-10">cdt:List</a> <var>term<sub>2</sub></var></code>
        )
      </p>

      <p>
        This function cannot be used directly in expressions. Instead, the purpose of this function is to define the semantics of the <code>=</code> operator when applied to two <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-11">cdt:List literals</a>.
      </p>

      <p>
        If both <var>term<sub>1</sub></var> and <var>term<sub>2</sub></var> are <a href="#dfn-well-formed-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-list-literal-2">well-formed cdt:List literals</a>, then the result of this function is determined by the following algorithm.
      </p>
      <div class="algorithm">
        <ol>
          <li>Let <var>list<sub>1</sub></var> be the <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-8">term list</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a href="#dfn-cdt-list-datatype" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-datatype-6">cdt:List datatype</a> to the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form">lexical form</a> of <var>term<sub>1</sub></var> (i.e., <var>list<sub>1</sub></var> is the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-literal-value">value</a> of <var>term<sub>1</sub></var>).</li>
          <li>Let <var>list<sub>2</sub></var> be the <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-9">term list</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a href="#dfn-cdt-list-datatype" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-datatype-7">cdt:List datatype</a> to the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form">lexical form</a> of <var>term<sub>2</sub></var> (i.e., <var>list<sub>2</sub></var> is the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-literal-value">value</a> of <var>term<sub>2</sub></var>).</li>
          <li>If both <var>list<sub>1</sub></var> and <var>list<sub>2</sub></var> are the <a href="#dfn-empty-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-list-2">empty term list</a>, then return <code>true</code>.</li>
          <li>If the length of <var>list<sub>1</sub></var> is different from the length of <var>list<sub>2</sub></var>, then return <code>false</code>.</li>
          <li>For every integer <var>i</var> from 1 to <var>n</var>, where <var>n</var> is the length of <var>list<sub>1</sub></var>:
            <ol>
              <li>Let <var>elmt<sub>1</sub></var> be the <var>i</var>-th element in <var>list<sub>1</sub></var>.</li>
              <li>Let <var>elmt<sub>2</sub></var> be the <var>i</var>-th element in <var>list<sub>2</sub></var>.</li>
              <li>If <var>elmt<sub>1</sub></var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-8">null</a> and <var>elmt<sub>2</sub></var> is not <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-9">null</a>, return <code>false</code>.</li>
              <li>If <var>elmt<sub>2</sub></var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-10">null</a> and <var>elmt<sub>1</sub></var> is not <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-11">null</a>, return <code>false</code>.</li>
              <li>If neither <var>elmt<sub>1</sub></var> nor <var>elmt<sub>2</sub></var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-12">null</a>, then:
                <ol>
                  <li>If <var>elmt<sub>1</sub></var> is a blank node and <var>elmt<sub>2</sub></var> is a blank node, terminate with an error.</li>
                  <li>If evaluating the SPARQL expression <var>elmt<sub>1</sub></var> = <var>elmt<sub>2</sub></var> results in an error, terminate with an error.</li>
                  <li>If evaluating the SPARQL expression <var>elmt<sub>1</sub></var> = <var>elmt<sub>2</sub></var> results in <code>false</code>, return <code>false</code>.</li>
                </ol>
              </li>
            </ol>
          </li>
          <li>Return <code>true</code>.</li>
        </ol>
      </div>

      <p>
        If <var>term<sub>1</sub></var> or <var>term<sub>2</sub></var> is an <a href="#dfn-ill-formed-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-ill-formed-cdt-list-literal-1">ill-formed cdt:List literal</a>, then this function produces an error.
      </p>

      <div class="note" role="note" id="issue-container-generatedID-8"><div role="heading" class="note-title marker" id="h-note-8" aria-level="4"><span>Note</span></div><div class="">
        Whenever the given algorithm, during its pairwise comparison of the elements of the two given lists, comes across a pair in which both elements are <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-13">null</a>, the algorithm advances to the next pair of elements. In this sense, the algorithm considers null values to be indistinguishable from one another. This behavior is necessary to guarantee that an expression such as the following evaluates to <code>true</code> (rather than to <code>false</code> or to an error).
        <pre data-content-type="application/sparql-query" class="nohighlight">"[null]"^^cdt:List = "[null]"^^cdt:List</pre>
        Guaranteeing that this expression evaluates to <code>true</code> is necessary for the following reason. Notice that the two arguments in this expression are identical (i.e., they are the same literal, with the same lexical form and the same datatype IRI). Therefore, by the definition of the <code>=</code> operator in [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-query" title="SPARQL 1.1 Query Language">SPARQL11-QUERY</a></cite>], the evaluation of the expression is <code>true</code> if <code>cdt:List</code> is <em>not</em> in the set of <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-recognized-datatype-iris">recognized datatype IRIs</a> (i.e., if the RDF processing system does not support <code>cdt:List</code>). Then, the version of the <code>=</code> operator for systems that support <code>cdt:List</code> (i.e., the version of the operator as defined by the list-equal function in this section) must also return <code>true</code>, because "no additional operator may yield a result that replaces any result other than a type error" (see <a href="https://www.w3.org/TR/sparql11-query/#operatorExtensibility">Section&nbsp;17.3.1</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-query" title="SPARQL 1.1 Query Language">SPARQL11-QUERY</a></cite>]).
      </div></div>

    </section>

    <section id="func_map-equal"><div class="header-wrapper"><h3 id="x5-2-map-equal"><bdi class="secno">5.2 </bdi>map-equal</h3><a class="self-link" href="#func_map-equal" aria-label="Permalink for Section 5.2"></a></div>
      

      <p>
        <code>xsd:boolean </code>
        <code style="color:black;font-weight:bold">map-equal</code>
        (
           <code><a href="#dfn-cdt-map-literal" id="ref-for-dfn-cdt-map-literal-8">cdt:Map</a> <var>term<sub>1</sub></var></code>,
           <code><a href="#dfn-cdt-map-literal" id="ref-for-dfn-cdt-map-literal-9">cdt:Map</a> <var>term<sub>2</sub></var></code>
        )
      </p>

      <p>
        This function cannot be used directly in expressions. Instead, the purpose of this function is to define the semantics of the <code>=</code> operator when applied to two <a href="#dfn-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-literal-10">cdt:Map literals</a>.
      </p>

      <p>
        If both <var>term<sub>1</sub></var> and <var>term<sub>2</sub></var> are <a href="#dfn-well-formed-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-map-literal-1">well-formed cdt:Map literals</a>, then the result of this function is determined by the following algorithm.
      </p>
      <div class="algorithm">
        <ol>
          <li>Let <var>map<sub>1</sub></var> be the <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-7">term map</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a href="#dfn-cdt-map-datatype" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-datatype-7">cdt:Map datatype</a> to the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form">lexical form</a> of <var>term<sub>1</sub></var> (i.e., <var>map<sub>1</sub></var> is the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-literal-value">value</a> of <var>term<sub>1</sub></var>).</li>
          <li>Let <var>map<sub>2</sub></var> be the <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-8">term map</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a href="#dfn-cdt-map-datatype" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-datatype-8">cdt:Map datatype</a> to the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form">lexical form</a> of <var>term<sub>2</sub></var> (i.e., <var>map<sub>2</sub></var> is the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-literal-value">value</a> of <var>term<sub>2</sub></var>).</li>
          <li>If both <var>map<sub>1</sub></var> and <var>map<sub>2</sub></var> are the <a href="#dfn-empty-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-map-3">empty term map</a>, then return <code>true</code>.</li>
          <li>If the number of <a href="#dfn-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-entry-4">map entries</a> that <var>map<sub>1</sub></var> <a href="#dfn-contains-map-entry" id="ref-for-dfn-contains-map-entry-5">contains</a> is different from the number of <a href="#dfn-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-entry-5">map entries</a> that <var>map<sub>2</sub></var> <a href="#dfn-contains-map-entry" id="ref-for-dfn-contains-map-entry-6">contains</a>, then return <code>false</code>.</li>
          <li>Let <var>error</var> be a boolean-typed flag that is initialized with the value <code>false</code>.</li>
          <li>For every <a href="#dfn-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-entry-6">map entry</a> (<var>k</var>, <var>v<sub>1</sub></var>) <a href="#dfn-contains-map-entry" id="ref-for-dfn-contains-map-entry-7">contained</a> in <var>map<sub>1</sub></var>:
            <ol>
              <li>If <var>k</var> is not in the domain of <var>map<sub>2</sub></var>, return <code>false</code>.</li>
              <li>Let <var>v<sub>2</sub></var> be the map value <var>map<sub>2</sub></var>(<var>k</var>).</li>
              <li>If <var>v<sub>1</sub></var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-14">null</a> and <var>v<sub>2</sub></var> is not <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-15">null</a>, return <code>false</code>.</li>
              <li>If <var>v<sub>2</sub></var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-16">null</a> and <var>v<sub>1</sub></var> is not <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-17">null</a>, return <code>false</code>.</li>
              <li>If neither <var>v<sub>1</sub></var> nor <var>v<sub>2</sub></var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-18">null</a>, then:
                <ol>
                  <li>If <var>v<sub>1</sub></var> is a blank node and <var>v<sub>2</sub></var> is a blank node, set <var>error</var> to <code>true</code> and move on to the next map entry in <var>map<sub>1</sub></var> (i.e., skip over the remaining instructions within this for loop).</li>
                  <li>If evaluating the SPARQL expression <var>v<sub>2</sub></var> = <var>v<sub>1</sub></var> results in an error, set <var>error</var> to <code>true</code> and move on to the next map entry in <var>map<sub>1</sub></var> (i.e., skip over the remaining instructions within this for loop).</li>
                  <li>If evaluating the SPARQL expression <var>v<sub>2</sub></var> = <var>v<sub>1</sub></var> results in <code>false</code>, return <code>false</code>.</li>
                </ol>
              </li>
            </ol>
          </li>
          <li>If <var>error</var> is <code>true</code>, terminate with an error.</li>
          <li>Return <code>true</code>.</li>
        </ol>
      </div>

      <p>
        If <var>term<sub>1</sub></var> or <var>term<sub>2</sub></var> is an <a href="#dfn-ill-formed-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-ill-formed-cdt-map-literal-1">ill-formed cdt:Map literal</a>, then this function produces an error.
      </p>

    </section>

    <section id="func_list-less-than"><div class="header-wrapper"><h3 id="x5-3-list-less-than"><bdi class="secno">5.3 </bdi>list-less-than</h3><a class="self-link" href="#func_list-less-than" aria-label="Permalink for Section 5.3"></a></div>
      

      <p>
        <code>xsd:boolean </code>
        <code style="color:black;font-weight:bold">list-less-than</code>
        (
           <code><a href="#dfn-cdt-list-literal" id="ref-for-dfn-cdt-list-literal-12">cdt:List</a> <var>term<sub>1</sub></var></code>,
           <code><a href="#dfn-cdt-list-literal" id="ref-for-dfn-cdt-list-literal-13">cdt:List</a> <var>term<sub>2</sub></var></code>
        )
      </p>

      <p>
        This function cannot be used directly in expressions. Instead, the purpose of this function is to define the semantics of the <code>&lt;</code> operator when applied to two <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-14">cdt:List literals</a>.
      </p>

      <p>
        If both <var>term<sub>1</sub></var> and <var>term<sub>2</sub></var> are <a href="#dfn-well-formed-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-list-literal-3">well-formed cdt:List literals</a>, then the result of this function is determined by the following algorithm.
      </p>
      <div class="algorithm">
        <ol>
          <li>Let <var>list<sub>1</sub></var> be the <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-10">term list</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a href="#dfn-cdt-list-datatype" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-datatype-8">cdt:List datatype</a> to the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form">lexical form</a> of <var>term<sub>1</sub></var> (i.e., <var>list<sub>1</sub></var> is the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-literal-value">value</a> of <var>term<sub>1</sub></var>).</li>
          <li>Let <var>list<sub>2</sub></var> be the <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-11">term list</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a href="#dfn-cdt-list-datatype" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-datatype-9">cdt:List datatype</a> to the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form">lexical form</a> of <var>term<sub>2</sub></var> (i.e., <var>list<sub>2</sub></var> is the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-literal-value">value</a> of <var>term<sub>2</sub></var>).</li>
          <li>If both <var>list<sub>1</sub></var> and <var>list<sub>2</sub></var> are the <a href="#dfn-empty-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-list-3">empty term list</a>, then return <code>false</code>.</li>
          <li>For every integer <var>i</var> from 1 to <var>n</var>, where <var>n</var> is the minimum of the length of <var>list<sub>1</sub></var> and the length of <var>list<sub>2</sub></var>:
            <ol>
              <li>Let <var>elmt<sub>1</sub></var> be the <var>i</var>-th element in <var>list<sub>1</sub></var>.</li>
              <li>Let <var>elmt<sub>2</sub></var> be the <var>i</var>-th element in <var>list<sub>2</sub></var>.</li>
              <li>If <var>elmt<sub>1</sub></var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-19">null</a> and <var>elmt<sub>2</sub></var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-20">null</a>, return <code>false</code>.</li>
              <li>If <var>elmt<sub>1</sub></var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-21">null</a> or <var>elmt<sub>2</sub></var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-22">null</a>, terminate with an error.</li>
              <li>If <var>elmt<sub>1</sub></var> is a blank node and <var>elmt<sub>2</sub></var> is a blank node, terminate with an error.</li>
              <li>If evaluating the SPARQL expression <var>elmt<sub>1</sub></var> <code>&lt;</code> <var>elmt<sub>2</sub></var> results in <code>true</code> or in <code>false</code> (i.e., not in an error), return this result.</li>
              <li>If evaluating the SPARQL expression <var>elmt<sub>1</sub></var> <code>=</code> <var>elmt<sub>2</sub></var> results in an error, terminate with an error.</li>
              <li>If evaluating the SPARQL expression <var>elmt<sub>1</sub></var> <code>=</code> <var>elmt<sub>2</sub></var> results in <code>false</code>, return <code>false</code>.</li>
            </ol>
          </li>
          <li>If the length of <var>list<sub>1</sub></var> is smaller than the length of <var>list<sub>2</sub></var>, return <code>true</code>.</li>
          <li>Return <code>false</code>.</li>
        </ol>
      </div>

      <p>
        If <var>term<sub>1</sub></var> or <var>term<sub>2</sub></var> is an <a href="#dfn-ill-formed-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-ill-formed-cdt-list-literal-2">ill-formed cdt:List literal</a>, then this function produces an error.
      </p>

    </section>

    <section id="func_map-less-than"><div class="header-wrapper"><h3 id="x5-4-map-less-than"><bdi class="secno">5.4 </bdi>map-less-than</h3><a class="self-link" href="#func_map-less-than" aria-label="Permalink for Section 5.4"></a></div>
      

      <p>
        <code>xsd:boolean </code>
        <code style="color:black;font-weight:bold">map-less-than</code>
        (
           <code><a href="#dfn-cdt-map-literal" id="ref-for-dfn-cdt-map-literal-11">cdt:Map</a> <var>term<sub>1</sub></var></code>,
           <code><a href="#dfn-cdt-map-literal" id="ref-for-dfn-cdt-map-literal-12">cdt:Map</a> <var>term<sub>2</sub></var></code>
        )
      </p>

      <p>
        This function cannot be used directly in expressions. Instead, the purpose of this function is to define the semantics of the <code>&lt;</code> operator when applied to two <a href="#dfn-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-literal-13">cdt:Map literals</a>.
      </p>

      <p>
        If both <var>term<sub>1</sub></var> and <var>term<sub>2</sub></var> are <a href="#dfn-well-formed-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-map-literal-2">well-formed cdt:Map literals</a>, then the result of this function is determined by the following algorithm.
      </p>
      <div class="algorithm">
        <ol>
          <li>Let <var>map<sub>1</sub></var> be the <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-9">term map</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a href="#dfn-cdt-map-datatype" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-datatype-9">cdt:Map datatype</a> to the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form">lexical form</a> of <var>term<sub>1</sub></var> (i.e., <var>map<sub>1</sub></var> is the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-literal-value">value</a> of <var>term<sub>1</sub></var>).</li>
          <li>Let <var>map<sub>2</sub></var> be the <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-10">term map</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a href="#dfn-cdt-map-datatype" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-datatype-10">cdt:Map datatype</a> to the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form">lexical form</a> of <var>term<sub>2</sub></var> (i.e., <var>map<sub>2</sub></var> is the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-literal-value">value</a> of <var>term<sub>2</sub></var>).</li>
          <li>If both <var>map<sub>1</sub></var> and <var>map<sub>2</sub></var> are the <a href="#dfn-empty-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-map-4">empty term map</a>, then return <code>false</code>.</li>
          <li>Let <var>entryset<sub>1</sub></var> be the set of all <a href="#dfn-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-entry-7">map entries</a> that are <a href="#dfn-contains-map-entry" id="ref-for-dfn-contains-map-entry-8">contained</a> in <var>map<sub>1</sub></var>.</li>
          <li>Let <var>entryset<sub>2</sub></var> be the set of all <a href="#dfn-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-entry-8">map entries</a> that are <a href="#dfn-contains-map-entry" id="ref-for-dfn-contains-map-entry-9">contained</a> in <var>map<sub>2</sub></var>.</li>
          <li>Let <var>entrylist<sub>1</sub></var> be a list of all map entries in <var>entryset<sub>1</sub></var>, ordered based on their respective <a href="#dfn-map-key" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-key-4">map keys</a> by using the following order:
            <ul>
              <li>Map entries with map keys that are IRIs are listed first, ordered based on comparing the string representation of these IRIs using the <code>&lt;</code> operator (i.e., the IRIs are used as the lexical form of literals with the datatype <code>xsd:string</code> and the order is then determined by comparing these literals using the <code>&lt;</code> operator)</li>
              <li>The remaining map entries have map keys that are literals. They are primarily ordered based on the string representation of their datatype IRIs (i.e., using these datatype IRIs as the lexical form of literals with the datatype <code>xsd:string</code> and, then, determining the order by comparing these string literals using the <code>&lt;</code> operator). Literals of the same datatype are ordered based on their lexical form (i.e., replacing their datatype IRI by <code>xsd:string</code> and, then, using the <code>&lt;</code> operator for the resulting string literals). Finally, literals with datatype <code>rdf:langString</code> that have the same lexical form are sorted based on the string representation of their language tags.
              </li>
              <div class="note" role="note" id="issue-container-generatedID-9"><div role="heading" class="note-title marker" id="h-note-9" aria-level="4"><span>Note</span></div><div class="">The process of ordering the map entries is equivalent to performing the following query (in which <code>term1</code> is <var>term<sub>1</sub></var>).
                <pre data-content-type="application/sparql-query" class="nohighlight">SELECT ?k ?v WHERE {
  UNFOLD( term1 AS ?k, ?v )
}
ORDER BY  ISLITERAL(?k)  STR(DATATYPE(?k))  STR(?k)  LANG(?k)</pre>
              </div></div>
            </ul>
          </li>
          <li>Let <var>entrylist<sub>2</sub></var> be a list of all map entries in <var>entryset<sub>2</sub></var>, ordered in the same way as <var>entrylist<sub>1</sub></var>.</li>
          <li>For every integer <var>i</var> from 1 to <var>n</var>, where <var>n</var> is the minimum of the respective length of <var>entrylist<sub>1</sub></var> and of <var>entrylist<sub>2</sub></var>:
            <ol>
              <li>Let (<var>k<sub>1</sub></var>, <var>v<sub>1</sub></var>) be the <var>i</var>-th <a href="#dfn-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-entry-9">map entry</a> in <var>entrylist<sub>1</sub></var>.</li>
              <li>Let (<var>k<sub>2</sub></var>, <var>v<sub>2</sub></var>) be the <var>i</var>-th <a href="#dfn-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-entry-10">map entry</a> in <var>entrylist<sub>2</sub></var>.</li>
              <li>If evaluating the SPARQL expression <a href="https://www.w3.org/TR/sparql11-query/#func-sameTerm"><code>SAMETERM</code></a>(<var>k<sub>1</sub></var>, <var>k<sub>2</sub></var>) results in <code>false</code>, then:
                <ol>
                  <li>Return <code>true</code> if <var>k<sub>1</sub></var> is ordered before <var>k<sub>2</sub></var> according to the ordering of map keys as defined above for creating <var>entrylist<sub>1</sub></var>.</li>
                  <li>Return <code>false</code>.</li>
                </ol>
              </li>
              <li>If <var>v<sub>1</sub></var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-23">null</a> and <var>v<sub>2</sub></var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-24">null</a>, return <code>false</code>.</li>
              <li>If <var>v<sub>1</sub></var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-25">null</a> or <var>v<sub>2</sub></var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-26">null</a>, terminate with an error.</li>
              <li>If evaluating the SPARQL expression <var>v<sub>1</sub></var> &lt; <var>v<sub>2</sub></var> results in <code>true</code> or in <code>false</code> (i.e., not an error), return this result.</li>

              <li>If evaluating the SPARQL expression <var>v<sub>1</sub></var> = <var>v<sub>2</sub></var> results in an error, terminate with an error.</li>
              <li>If evaluating the SPARQL expression <var>v<sub>1</sub></var> = <var>v<sub>2</sub></var> results in <code>false</code>, return <code>false</code>.</li>
            </ol>
          </li>
          <li>Return <code>true</code> if the length of <var>entrylist<sub>1</sub></var> is smaller than the length of <var>entrylist<sub>2</sub></var>.</li>
          <li>Return <code>false</code>.</li>
        </ol>
      </div>

      <p>
        If <var>term<sub>1</sub></var> or <var>term<sub>2</sub></var> is an <a href="#dfn-ill-formed-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-ill-formed-cdt-map-literal-2">ill-formed cdt:Map literal</a>, then this function produces an error.
      </p>

    </section>

  </section>


  <section id="combined-functions"><div class="header-wrapper"><h2 id="x6-functions-on-lists-and-maps"><bdi class="secno">6. </bdi>Functions on Lists and Maps</h2><a class="self-link" href="#combined-functions" aria-label="Permalink for Section 6."></a></div>
    

    <p>
      This section defines <a href="https://www.w3.org/TR/sparql11-query/#extensionFunctions">SPARQL extension functions</a> which operate over both <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-15">cdt:List literals</a> and <a href="#dfn-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-literal-14">cdt:Map literals</a>. These functions can be used in SPARQL expressions for testing values in FILTER clauses and for assigning values in, e.g., BIND clauses and SELECT expressions.
    </p>

    <p>
      These extension functions are evaluated as defined in <a href="https://www.w3.org/TR/sparql11-query/#invocation">Section&nbsp;17.2.1</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-query" title="SPARQL 1.1 Query Language">SPARQL11-QUERY</a></cite>].
    </p>

    <section id="func_get"><div class="header-wrapper"><h3 id="x6-1-cdt-get"><bdi class="secno">6.1 </bdi>cdt:get</h3><a class="self-link" href="#func_get" aria-label="Permalink for Section 6.1"></a></div>
      

      <p>
        <code><a href="https://www.w3.org/TR/rdf11-concepts/#dfn-rdf-term">RDF term</a> </code>
        <code style="color:black;font-weight:bold">cdt:get</code>
        (
           <code><a href="#dfn-cdt-list-literal" id="ref-for-dfn-cdt-list-literal-16">cdt:List</a> <var>term</var></code>,
           <code>xsd:integer <var>idx</var></code>
        )
      </p>

      <p>
        If <var>term</var> is a <a href="#dfn-well-formed-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-list-literal-4">well-formed cdt:List literal</a>, the value of <var>idx</var> is greater than 0 (zero) and smaller or equal than the number of elements of the <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-12">term list</a> represented by <var>term</var>, and the element at the <var>idx</var>-th position of the term list represented by <var>term</var> is an <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-rdf-term">RDF term</a> (i.e., not <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-27">null</a>), then the result of this function is that RDF term at the <var>idx</var>-th position of the term list represented by <var>term</var>. In all other cases an error is raised.
      </p>

      <p>
        <code><a href="https://www.w3.org/TR/rdf11-concepts/#dfn-rdf-term">RDF term</a> </code>
        <code style="color:black;font-weight:bold">cdt:get</code>
        (
           <code><a href="#dfn-cdt-map-literal" id="ref-for-dfn-cdt-map-literal-15">cdt:Map</a> <var>term</var></code>,
           <code><a href="https://www.w3.org/TR/rdf11-concepts/#dfn-rdf-term">RDF term</a> <var>key</var></code>
        )
      </p>

      <p>
        If <var>term</var> is a <a href="#dfn-well-formed-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-map-literal-3">well-formed cdt:Map literal</a>, and there exists a <a href="#dfn-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-entry-11">map entry</a> (<var>k</var>,<var>v</var>) in the <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-11">term map</a> represented by <var>term</var> where <var>k</var> is the same term as <var>key</var> and <var>v</var> is an <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-rdf-term">RDF term</a> (i.e., not <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-28">null</a>), then the result of this function is <var>v</var>. In all other cases an error is raised.
      </p>


      <aside class="example" id="example-20"><div class="marker">
    <a class="self-link" href="#example-20">Example<bdi> 20</bdi></a>
  </div>
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">cdt:get( "[&lt;http://example.org/a&gt;, &lt;http://example.org/b&gt;]"^^cdt:List, 2 )</pre>
        <p>
          results in the IRI <code>http://example.org/b</code>.
      </p></aside>

      <aside class="example" id="example-21"><div class="marker">
    <a class="self-link" href="#example-21">Example<bdi> 21</bdi></a>
  </div>
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">cdt:get( "{2: &lt;http://example.org/a&gt;, 1: &lt;http://example.org/b&gt;}"^^cdt:Map, 2 )</pre>
        <p>
          results in the IRI <code>http://example.org/a</code>.
      </p></aside>

      <div class="note" role="note" id="issue-container-generatedID-10"><div role="heading" class="note-title marker" id="h-note-10" aria-level="4"><span>Note</span></div><div class="">
        By its definition as given above, <code>cdt:get</code> for cdt:List literals raises an error not only if the given cdt:List literal is not well-formed but also in the following cases:
        <ul>
          <li>if <var>term</var> is a well-formed cdt:List literal that represents the <a href="#dfn-empty-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-list-4">empty term list</a>,</li>
          <li>if the value of <var>idx</var> is out of the bounds of the term list represented by <var>term</var>, and</li>
          <li>if the element at the <var>idx</var>-th position of the term list represented by <var>term</var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-29">null</a>.</li>
        </ul>
        Similarly, <code>cdt:get</code> for cdt:Map literals raises an error not only if the given cdt:Map literal is not well-formed but also in the following cases:
        <ul>
          <li>if <var>term</var> is a well-formed cdt:Map literal that represents the <a href="#dfn-empty-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-map-5">empty term map</a>,</li>
          <li>if <var>key</var> is not a map key in the term map represented by <var>term</var>, and</li>
          <li>if the value associated with <var>key</var> in the term map represented by <var>term</var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-30">null</a>.</li>
        </ul>
      </div></div>

      <div class="note" role="note" id="issue-container-generatedID-11"><div role="heading" class="note-title marker" id="h-note-11" aria-level="4"><span>Note</span></div><p class="">
        The list version of the function uses a 1-based numbering scheme to address the elements in term list (i.e., the first element of a term list is addressed by an <var>idx</var> value of 1), in contrast to a 0-based numbering scheme which is common for addressing elements of arrays in many programming languages. The reason for using 1-based numbering for this function is to remain consistent with existing build-in functions of SPARQL, which are also 1-based (e.g., <a href="https://www.w3.org/TR/sparql11-query/#func-substr">substr</a> for string literals). Moreover, the 1-based numbering scheme is also used by functions of other W3C languages such as XPath (see, e.g., the XPath <a href="https://www.w3.org/TR/xpath-functions/#func-array-get">array:get</a> function which is similar to cdt:get).
      </p></div>

    </section>

    <section id="func_size"><div class="header-wrapper"><h3 id="x6-2-cdt-size"><bdi class="secno">6.2 </bdi>cdt:size</h3><a class="self-link" href="#func_size" aria-label="Permalink for Section 6.2"></a></div>
      

      <p>
        <code>xsd:integer </code>
        <code style="color:black;font-weight:bold">cdt:size</code>
        (
           <code><a href="#dfn-cdt-list-literal" id="ref-for-dfn-cdt-list-literal-17">cdt:List</a> <var>term</var></code>
        )
      </p>

      <p>
        If <var>term</var> is a <a href="#dfn-well-formed-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-list-literal-5">well-formed cdt:List literal</a>, then the result of this function is the number of elements that the <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-13">term list</a> represented by <var>term</var> contains.
      </p>
      <p>
        An error is raised if <var>term</var> is not a <a href="#dfn-well-formed-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-list-literal-6">well-formed cdt:List literal</a>.
      </p>

      <p>
        <code>xsd:integer </code>
        <code style="color:black;font-weight:bold">cdt:size</code>
        (
           <code><a href="#dfn-cdt-map-literal" id="ref-for-dfn-cdt-map-literal-16">cdt:Map</a> <var>term</var></code>
        )
      </p>

      <p>
        If <var>term</var> is a <a href="#dfn-well-formed-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-map-literal-4">well-formed cdt:Map literal</a>, then the result of this function is the number of map entries in the <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-12">term map</a> represented by <var>term</var>.
      </p>
      <p>
        An error is raised if <var>term</var> is not a <a href="#dfn-well-formed-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-map-literal-5">well-formed cdt:Map literal</a>.
      </p>

      <aside class="example" id="example-22"><div class="marker">
    <a class="self-link" href="#example-22">Example<bdi> 22</bdi></a>
  </div>
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">cdt:size( "[1,'a','a',4]"^^cdt:List )</pre>
        <p>
          results in a literal with the datatype IRI <code>xsd:integer</code> and the value 4.
        </p>
      </aside>

      <aside class="example" id="example-23"><div class="marker">
    <a class="self-link" href="#example-23">Example<bdi> 23</bdi></a>
  </div>
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">cdt:size( "{1:'a','a':4}"^^cdt:Map )</pre>
        <p>
          results in a literal with the datatype IRI <code>xsd:integer</code> and the value 2.
        </p>
      </aside>

    </section>

  </section>

  <section id="list-functions"><div class="header-wrapper"><h2 id="x7-functions-on-lists"><bdi class="secno">7. </bdi>Functions on Lists</h2><a class="self-link" href="#list-functions" aria-label="Permalink for Section 7."></a></div>
    

    <p>
      This section defines <a href="https://www.w3.org/TR/sparql11-query/#extensionFunctions">SPARQL extension functions</a> specifically for <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-18">cdt:List literals</a>. These functions can be used in SPARQL expressions for testing values in FILTER clauses and for assigning values in, e.g., BIND clauses and SELECT expressions.
    </p>

    <p>
      Except for <a href="#func_list">cdt:List</a>, these extension functions are evaluated as defined in <a href="https://www.w3.org/TR/sparql11-query/#invocation">Section&nbsp;17.2.1</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-query" title="SPARQL 1.1 Query Language">SPARQL11-QUERY</a></cite>]. In contrast, <a href="#func_list">cdt:List</a> is a so-called <a href="https://www.w3.org/TR/sparql11-query/#func-forms">functional form</a> which has specific evaluation rules (as defined in Section&nbsp;<a href="#func_list" class="sectionRef sec-ref"><bdi class="secno">7.1 </bdi>cdt:List</a>).
    </p>

    <section id="func_list"><div class="header-wrapper"><h3 id="x7-1-cdt-list"><bdi class="secno">7.1 </bdi>cdt:List</h3><a class="self-link" href="#func_list" aria-label="Permalink for Section 7.1"></a></div>
      

      <p>
        <code><a href="#dfn-cdt-list-literal" id="ref-for-dfn-cdt-list-literal-19">cdt:List</a> </code>
        <code style="color:black;font-weight:bold">cdt:List</code>
        (
           <code><a href="https://www.w3.org/TR/sparql11-query/#expressions">SPARQL expression</a> <var>expr<sub>1</sub></var></code>,
           ...,
           <code><a href="https://www.w3.org/TR/sparql11-query/#expressions">SPARQL expression</a> <var>expr<sub><var>n</var></sub></var></code>
        )
      </p>

      <p>
        The result of this function is a <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-20">cdt:List literal</a> that represents a <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-14">term list</a>&nbsp;<var>tm</var> that contains <var>n</var> elements where, for every <var>i</var> in {1, ..., <var>n</var>}, the element at the <var>i</var>-th position of <var>tm</var> is constructed as follows. Evaluate the <var>i</var>-th expression, <var>expr<sub><var>i</var></sub></var>, as defined in [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-query" title="SPARQL 1.1 Query Language">SPARQL11-QUERY</a></cite>]. If evaluating <var>expr<sub><var>i</var></sub></var> raises an error, then the element at the <var>i</var>-th position of <var>tm</var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-31">null</a>. Otherwise, the element at the <var>i</var>-th position of <var>tm</var> is the RDF term resulting from the evaluation of <var>expr<sub><var>i</var></sub></var>.
      </p>
      <p>
        If the function is called without arguments, then the result is a <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-21">cdt:List literal</a> that represents the <a href="#dfn-empty-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-list-5">empty term list</a>.
      </p>

      <aside class="example" id="example-24"><div class="marker">
    <a class="self-link" href="#example-24">Example<bdi> 24</bdi></a>
  </div>
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">cdt:List( 'hello', ?x, ?x+1, ?y, &lt;http://example.org/a&gt; )</pre>
        <p>
          for the solution mapping <var>μ</var>&nbsp;=&nbsp;{?x → "2"^^xsd:integer} results in the following cdt:List literal.
        </p>
        <pre class="nohighlight">"['hello', 2, 3, null, &lt;http://example.org/a&gt;]"^^cdt:List</pre>
      </aside>

    </section>

    <section id="func_concat"><div class="header-wrapper"><h3 id="x7-2-cdt-concat"><bdi class="secno">7.2 </bdi>cdt:concat</h3><a class="self-link" href="#func_concat" aria-label="Permalink for Section 7.2"></a></div>
      

      <p>
        <code><a href="#dfn-cdt-list-literal" id="ref-for-dfn-cdt-list-literal-22">cdt:List</a> </code>
        <code style="color:black;font-weight:bold">cdt:concat</code>
        (
           <code><a href="#dfn-cdt-list-literal" id="ref-for-dfn-cdt-list-literal-23">cdt:List</a> <var>term<sub>1</sub></var></code>,
           ...,
           <code><a href="#dfn-cdt-list-literal" id="ref-for-dfn-cdt-list-literal-24">cdt:List</a> <var>term<sub>n</sub></var></code>
        )
      </p>

      <p>
        If all arguments (i.e., <var>term<sub>1</sub></var>, ..., <var>term<sub>n</sub></var>) are <a href="#dfn-well-formed-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-list-literal-7">well-formed cdt:List literals</a>, then the result of this function is a <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-25">cdt:List literal</a> that represents the <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-15">term list</a> that is the concatenation of the term lists represented by <var>term<sub>1</sub></var> to <var>term<sub>n</sub></var> (in the order in which these arguments are given). If the function is called without arguments, then the result is a <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-26">cdt:List literal</a> that represents the <a href="#dfn-empty-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-list-6">empty term list</a>. If the function is called with a single argument and that argument is a well-formed cdt:List literal, then this literal is the result of this function.
      </p>
      <p>
        An error is raised if any of the arguments is not a <a href="#dfn-well-formed-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-list-literal-8">well-formed cdt:List literal</a>.
      </p>

      <div class="issue" id="issue-container-number-2"><div role="heading" class="issue-title marker" id="h-issue-0" aria-level="4"><span>Issue 2</span></div><p class="">
        We should define the notion of "represents" as used in this definition!
      </p></div>

      <aside class="example" id="example-25"><div class="marker">
    <a class="self-link" href="#example-25">Example<bdi> 25</bdi></a>
  </div>
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">cdt:concat( "[1,2,3]"^^cdt:List, "['a',null,'a',2,3]"^^cdt:List )</pre>
        <p>
          results in the following cdt:List literal.
        </p>
        <pre class="nohighlight">"[1,2,3,'a',null,'a',2,3]"^^cdt:List</pre>
      </aside>

    </section>

    <section id="func_contains"><div class="header-wrapper"><h3 id="x7-3-cdt-contains"><bdi class="secno">7.3 </bdi>cdt:contains</h3><a class="self-link" href="#func_contains" aria-label="Permalink for Section 7.3"></a></div>
      

      <p>
        <code>xsd:boolean </code>
        <code style="color:black;font-weight:bold">cdt:contains</code>
        (
           <code><a href="#dfn-cdt-list-literal" id="ref-for-dfn-cdt-list-literal-27">cdt:List</a> <var>term<sub>1</sub></var></code>,
           <code><a href="https://www.w3.org/TR/rdf11-concepts/#dfn-rdf-term">RDF term</a> <var>term<sub>2</sub></var></code>
        )
      </p>

      <p>
        If <var>term<sub>1</sub></var> is a <a href="#dfn-well-formed-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-list-literal-9">well-formed cdt:List literal</a>, then the result of this function is determined by the following algorithm.
      </p>
      <div class="algorithm">
        <ol>
          <li>If <var>term<sub>2</sub></var> is a blank node, return <code>false</code>.</li>
          <li>If the <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-16">term list</a> represented by <var>term<sub>1</sub></var> contains an <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-rdf-term">RDF term</a> <var>term'</var> such that evaluating the SPARQL expression <var>term'</var> = <var>term<sub>2</sub></var> results in <code>true</code>, return <code>true</code>.</li>
          <li>Return <code>false</code>.</li>
        </ol>
      </div>

      <p>
        An error is raised if <var>term<sub>1</sub></var> is not a <a href="#dfn-well-formed-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-list-literal-10">well-formed cdt:List literal</a>.
      </p>

      <aside class="example" id="example-26"><div class="marker">
    <a class="self-link" href="#example-26">Example<bdi> 26</bdi></a>
  </div>
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">cdt:contains( "[1,2,3]"^^cdt:List, "02"^^xsd:integer )</pre>
        <p>
          results in <code>true</code>, whereas the expression
        </p>
        <pre class="nohighlight">cdt:contains( "[1,2,3]"^^cdt:List, "2" )</pre>
        <p>
          results in <code>false</code>.
      </p></aside>

    </section>

    <section id="func_head"><div class="header-wrapper"><h3 id="x7-4-cdt-head"><bdi class="secno">7.4 </bdi>cdt:head</h3><a class="self-link" href="#func_head" aria-label="Permalink for Section 7.4"></a></div>
      

      <p>
        <code><a href="https://www.w3.org/TR/rdf11-concepts/#dfn-rdf-term">RDF term</a> </code>
        <code style="color:black;font-weight:bold">cdt:head</code>
        (
           <code><a href="#dfn-cdt-list-literal" id="ref-for-dfn-cdt-list-literal-28">cdt:List</a> <var>term</var></code>
        )
      </p>

      <p>
        If <var>term</var> is a <a href="#dfn-well-formed-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-list-literal-11">well-formed cdt:List literal</a>, the <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-17">term list</a> represented by <var>term</var> contains at least one element, and the element at the first position of this term list is an <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-rdf-term">RDF term</a> (i.e., not <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-32">null</a>), then the result of this function is that RDF term. In all other cases an error is raised.
      </p>

      <aside class="example" id="example-27"><div class="marker">
    <a class="self-link" href="#example-27">Example<bdi> 27</bdi></a>
  </div>
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">cdt:head( "[&lt;http://example.org/a&gt;, &lt;http://example.org/b&gt;]"^^cdt:List )</pre>
        <p>
          results in the IRI <code>http://example.org/a</code>.
      </p></aside>

      <div class="note" role="note" id="issue-container-generatedID-12"><div role="heading" class="note-title marker" id="h-note-12" aria-level="4"><span>Note</span></div><div class="">
        By its definition as given above, <code>cdt:head</code> raises an error not only if the given cdt:List literal is not well-formed but also in the following cases:
        <ul>
          <li>if <var>term</var> is a well-formed cdt:List literal that represents the <a href="#dfn-empty-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-list-7">empty term list</a>, and</li>
          <li>if the element at the first position of the term list represented by <var>term</var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-33">null</a>.</li>
        </ul>
      </div></div>
    </section>

    <section id="func_reverse"><div class="header-wrapper"><h3 id="x7-5-cdt-reverse"><bdi class="secno">7.5 </bdi>cdt:reverse</h3><a class="self-link" href="#func_reverse" aria-label="Permalink for Section 7.5"></a></div>
      

      <p>
        <code><a href="#dfn-cdt-list-literal" id="ref-for-dfn-cdt-list-literal-29">cdt:List</a> </code>
        <code style="color:black;font-weight:bold">cdt:reverse</code>
        (
           <code><a href="#dfn-cdt-list-literal" id="ref-for-dfn-cdt-list-literal-30">cdt:List</a> <var>term</var></code>
        )
      </p>

      <p>
        If <var>term</var> is a <a href="#dfn-well-formed-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-list-literal-12">well-formed cdt:List literal</a>, then the result of this function is a <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-31">cdt:List literal</a> that represents the <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-18">term list</a> that contains all elements of the term list represented by <var>term</var>, in the reverse order (e.g., the first element of the term list of <var>term</var> becomes the last element of the term list represented by the resulting cdt:List literal). This definition implies that
      </p>
      <ul>
        <li>if the term list of <var>term</var> consists of a single element, then the resulting cdt:List literal represents the same term list (with the same element), and</li>
        <li>if <var>term</var> represents the <a href="#dfn-empty-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-list-8">empty term list</a>, then the resulting cdt:List literal also represents the empty term list.</li>
      </ul>
      <p>
        An error is raised if <var>term</var> is not a <a href="#dfn-well-formed-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-list-literal-13">well-formed cdt:List literal</a>.
      </p>

      <aside class="example" id="example-28"><div class="marker">
    <a class="self-link" href="#example-28">Example<bdi> 28</bdi></a>
  </div>
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">cdt:reverse( "['a',2,null,4]"^^cdt:List )</pre>
        <p>
          results in the following cdt:List literal.
        </p>
        <pre class="nohighlight">"[4,null,2,'a']"^^cdt:List</pre>
      </aside>

    </section>

    <section id="func_subseq"><div class="header-wrapper"><h3 id="x7-6-cdt-subseq"><bdi class="secno">7.6 </bdi>cdt:subseq</h3><a class="self-link" href="#func_subseq" aria-label="Permalink for Section 7.6"></a></div>
      

      <p>
        <code><a href="#dfn-cdt-list-literal" id="ref-for-dfn-cdt-list-literal-32">cdt:List</a> </code>
        <code style="color:black;font-weight:bold">cdt:subseq</code>
        (
           <code><a href="#dfn-cdt-list-literal" id="ref-for-dfn-cdt-list-literal-33">cdt:List</a> <var>term</var></code>,
           <code>xsd:integer <var>idx</var></code>
        )
      </p>

      <p>
        <code><a href="#dfn-cdt-list-literal" id="ref-for-dfn-cdt-list-literal-34">cdt:List</a> </code>
        <code style="color:black;font-weight:bold">cdt:subseq</code>
        (
           <code><a href="#dfn-cdt-list-literal" id="ref-for-dfn-cdt-list-literal-35">cdt:List</a> <var>term</var></code>,
           <code>xsd:integer <var>idx</var></code>,
           <code>xsd:integer <var>length</var></code>
        )
      </p>

      <p>
        If <var>term</var> is a <a href="#dfn-well-formed-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-list-literal-14">well-formed cdt:List literal</a>, then the result of this function is determined as follows. Let <var>tm</var> be the <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-19">term list</a> represented by <var>term</var> and let <var>n</var> be the number of elements contained in <var>tm</var>.
      </p>
      <ul>
        <li>If the value of <var>idx</var> is greater than 0 (zero) and smaller than <var>n</var>+1, and <var>length</var> is not given, then the result of this function is a <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-36">cdt:List literal</a> that represents the term list that is the sub-sequence of <var>tm</var>, starting with the element at the <var>idx</var>-th position of <var>tm</var> and ending with the last element of <var>tm</var>.</li>
        <li>If the value of <var>idx</var> is greater than 0 (zero) and smaller than <var>n</var>+1, and the value of <var>length</var> is greater than 0 (zero) and smaller than <var>n</var>−<var>idx</var>+1, then the result of this function is a <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-37">cdt:List literal</a> that represents the term list that is the sub-sequence of <var>tm</var>, starting with the element at the <var>idx</var>-th position of <var>tm</var> and ending with the element at position <var>idx</var>+<var>length</var>−1 of <var>tm</var>.</li>
        <li>If the value of <var>idx</var> is greater than 0 (zero) and smaller than <var>n</var>+1, and the value of <var>length</var> is 0 (zero), then the result of this function is a <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-38">cdt:List literal</a> that represents the <a href="#dfn-empty-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-list-9">empty term list</a>.</li>
        <li>If the value of <var>idx</var> is equal to <var>n</var>+1, and either <var>length</var> is not given or the value of <var>length</var> is 0 (zero), then the result of this function is a <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-39">cdt:List literal</a> that represents the <a href="#dfn-empty-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-list-10">empty term list</a>.</li>
      </ul>
      <p>
        In all other cases an error is raised, including the case that <var>term</var> is not a <a href="#dfn-well-formed-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-list-literal-15">well-formed cdt:List literal</a>.
      </p>

      <aside class="example" id="example-29"><div class="marker">
    <a class="self-link" href="#example-29">Example<bdi> 29</bdi></a>
  </div>
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">cdt:subseq( "['a',2,null,4]"^^cdt:List, 2 )</pre>
        <p>
          results in the following cdt:List literal.
        </p>
        <pre class="nohighlight">"[2,null,4]"^^cdt:List</pre>
      </aside>

      <aside class="example" id="example-30"><div class="marker">
    <a class="self-link" href="#example-30">Example<bdi> 30</bdi></a>
  </div>
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">cdt:subseq( "['a',2,null,4]"^^cdt:List, 2, 2 )</pre>
        <p>
          results in the following cdt:List literal.
        </p>
        <pre class="nohighlight">"[2,null]"^^cdt:List</pre>
      </aside>

      <aside class="example" id="example-31"><div class="marker">
    <a class="self-link" href="#example-31">Example<bdi> 31</bdi></a>
  </div>
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">cdt:subseq( "['a',2,null,4]"^^cdt:List, 2, 0 )</pre>
        <p>
          results in the following cdt:List literal.
        </p>
        <pre class="nohighlight">"[]"^^cdt:List</pre>
      </aside>

      <div class="note" role="note" id="issue-container-generatedID-13"><div role="heading" class="note-title marker" id="h-note-13" aria-level="4"><span>Note</span></div><p class="">
        As the <a href="#func_get"><code>cdt:get</code></a> function, this function uses a 1-based numbering scheme to address the elements in term maps (i.e., the first element of a term map is addressed by an <var>idx</var> value of 1) in order to be consistent with existing build-in functions of SPARQL (e.g., <a href="https://www.w3.org/TR/sparql11-query/#func-substr">substr</a>) and with functions in other W3C languages such as XPath (e.g., <a href="https://www.w3.org/TR/xpath-functions/#func-array-subarray">array:subarray</a>).
      </p></div>

      <div class="note" role="note" id="issue-container-generatedID-14"><div role="heading" class="note-title marker" id="h-note-14" aria-level="4"><span>Note</span></div><p class="">
        This function corresponds to the XPath <a href="https://www.w3.org/TR/xpath-functions/#func-array-subarray">array:subarray</a> function and, for the sake of consistency, is defined using the same rules and error conditions. As a consequence, the following special case of arguments is permitted for this function. For term maps with a size <var>n</var>&gt;0, it is permitted to call the function with an <var>idx</var> value equal to <var>n</var>+1 as long as the value of <var>length</var> is 0 or <var>length</var> is omitted. When doing so, the result is a <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-40">cdt:List literal</a> that represents the <a href="#dfn-empty-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-list-11">empty term list</a>.
      </p></div>

    </section>

    <section id="func_tail"><div class="header-wrapper"><h3 id="x7-7-cdt-tail"><bdi class="secno">7.7 </bdi>cdt:tail</h3><a class="self-link" href="#func_tail" aria-label="Permalink for Section 7.7"></a></div>
      

      <p>
        <code><a href="#dfn-cdt-list-literal" id="ref-for-dfn-cdt-list-literal-41">cdt:List</a> </code>
        <code style="color:black;font-weight:bold">cdt:tail</code>
        (
           <code><a href="#dfn-cdt-list-literal" id="ref-for-dfn-cdt-list-literal-42">cdt:List</a> <var>term</var></code>
        )
      </p>

      <p>
        If <var>term</var> is a <a href="#dfn-well-formed-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-list-literal-16">well-formed cdt:List literal</a> and the <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-20">term list</a> represented by <var>term</var> contains at least one element, then the result of this function is a <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-43">cdt:List literal</a> that represents the <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-21">term list</a> that contains all but the first element of the term list represented by <var>term</var>, where the remaining elements are kept in the same order. This definition implies that, if the term list of <var>term</var> consists of a single element, the resulting cdt:List literal must represent the <a href="#dfn-empty-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-list-12">empty term list</a>.
      </p>
      <p>
        An error is raised if <var>term</var> is not a well-formed cdt:List literal or if it is a well-formed cdt:List literal that represents the empty term list.
      </p>

      <aside class="example" id="example-32"><div class="marker">
    <a class="self-link" href="#example-32">Example<bdi> 32</bdi></a>
  </div>
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">cdt:tail( "['a',2,null,4]"^^cdt:List )</pre>
        <p>
          results in the following cdt:List literal.
        </p>
        <pre class="nohighlight">"[2,null,4]"^^cdt:List</pre>
      </aside>

    </section>

  </section>



  <section id="map-functions"><div class="header-wrapper"><h2 id="x8-functions-on-maps"><bdi class="secno">8. </bdi>Functions on Maps</h2><a class="self-link" href="#map-functions" aria-label="Permalink for Section 8."></a></div>
    

    <p>
      This section defines <a href="https://www.w3.org/TR/sparql11-query/#extensionFunctions">SPARQL extension functions</a> specifically for <a href="#dfn-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-literal-17">cdt:Map literals</a>. These functions can be used in SPARQL expressions for testing values in FILTER clauses and for assigning values in, e.g., BIND clauses and SELECT expressions.
    </p>

    <p>
      Except for <a href="#func_map">cdt:Map</a> and <a href="#func_put">cdt:put</a>, these extension functions are evaluated as defined in <a href="https://www.w3.org/TR/sparql11-query/#invocation">Section&nbsp;17.2.1</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-query" title="SPARQL 1.1 Query Language">SPARQL11-QUERY</a></cite>]. In contrast, <a href="#func_map">cdt:Map</a> and <a href="#func_put">cdt:put</a> are so-called <a href="https://www.w3.org/TR/sparql11-query/#func-forms">functional forms</a> which have specific evaluation rules (as defined in Section&nbsp;<a href="#func_map" class="sectionRef sec-ref"><bdi class="secno">8.1 </bdi>cdt:Map</a> and Section&nbsp;<a href="#func_put" class="sectionRef sec-ref"><bdi class="secno">8.5 </bdi>cdt:put</a>, respectively).
    </p>

    <section id="func_map"><div class="header-wrapper"><h3 id="x8-1-cdt-map"><bdi class="secno">8.1 </bdi>cdt:Map</h3><a class="self-link" href="#func_map" aria-label="Permalink for Section 8.1"></a></div>
      

      <p>
        <code><a href="#dfn-cdt-map-literal" id="ref-for-dfn-cdt-map-literal-18">cdt:Map</a> </code>
        <code style="color:black;font-weight:bold">cdt:Map</code>
        (
           <code><a href="https://www.w3.org/TR/sparql11-query/#expressions">SPARQL expression</a> <var>expr<sub>1</sub></var></code>,
           ...,
           <code><a href="https://www.w3.org/TR/sparql11-query/#expressions">SPARQL expression</a> <var>expr<sub><var>n</var></sub></var></code>
        )
      </p>

      <p>
        If <var>n</var> is an even number, then the result of this function is a <a href="#dfn-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-literal-19">cdt:Map literal</a> that represents a <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-13">term map</a>&nbsp;<var>tm</var> that contains up to <var>n</var>/2 map entries, produced by the following algorithm.
      </p>
      <div class="algorithm">
        <ol>
          <li>Initialize <var>tm</var> as the <a href="#dfn-empty-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-map-6">empty term map</a>.</li>
          <li>For every integer <var>i</var> from 1 to <var>n</var>/2:
            <ol>
              <li>Evaluate the (2<var>i</var>-1)-th expression, <var>expr<sub>2<var>i</var>-1</sub></var>, as defined in [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-query" title="SPARQL 1.1 Query Language">SPARQL11-QUERY</a></cite>].</li>
              <li>If evaluating <var>expr<sub>2<var>i</var>-1</sub></var> did not raise an error and the RDF term resulting from this evaluation is a <a href="#dfn-map-key" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-key-5">map key</a>, then:
                <ol>
                  <li>Let <var>k</var> be the RDF term resulting from the evaluation of <var>expr<sub>2<var>i</var>-1</sub></var>.</li>
                  <li>Evaluate the 2<var>i</var>-th expression, <var>expr<sub>2<var>i</var></sub></var>, as defined in [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-query" title="SPARQL 1.1 Query Language">SPARQL11-QUERY</a></cite>].</li>
                  <li>Let <var>v</var> be the RDF term resulting from the evaluation of <var>expr<sub>2<var>i</var></sub></var> if this evaluation did not raise and error; otherwise, let <var>v</var> be <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-34">null</a>.</li>
                  <li>If <var>tm</var> contains a <a href="#dfn-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-entry-12">map entry</a> (<var>k'</var>,<var>v'</var>) such that <var>k</var>=<var>k'</var>, then replace this map entry (<var>k'</var>,<var>v'</var>) by the map entry (<var>k</var>,<var>v</var>). Otherwise, add the map entry (<var>k</var>,<var>v</var>) to <var>tm</var>.</li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </div>
        
      <p>
        If <var>n</var> is an odd number, an error is raised.
      </p>

      <div class="note" role="note" id="issue-container-generatedID-15"><div role="heading" class="note-title marker" id="h-note-15" aria-level="4"><span>Note</span></div><p class="">
        By the given definition, every argument to this function that is meant to produce the <a href="#dfn-map-key" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-key-6">map key</a> of a <a href="#dfn-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-entry-13">map entry</a> for the constructed <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-14">term map</a> but that evaluates to an error or to an RDF term that is not a map key is ignored, and so is the directly following argument (i.e., the expression that is meant to produce the corresponding <a href="#dfn-map-value" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-value-7">map value</a>).
      </p></div>

      <aside class="example" id="example-33"><div class="marker">
    <a class="self-link" href="#example-33">Example<bdi> 33</bdi></a>
  </div>
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">cdt:Map( 'hello', ?x, ?x+1, ?y )</pre>
        <p>
          for the solution mapping <var>μ</var>&nbsp;=&nbsp;{?x → "2"^^xsd:integer} results in the following cdt:List literal.
        </p>
        <pre class="nohighlight">"{'hello': 2, 3: null}"^^cdt:Map</pre>
      </aside>

      <div class="note" role="note" id="issue-container-generatedID-16"><div role="heading" class="note-title marker" id="h-note-16" aria-level="4"><span>Note</span></div><p class="">
        If the <code>cdt:Map</code> function is called without arguments (i.e., <var>n</var>=0), then the result is a <a href="#dfn-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-literal-20">cdt:Map literal</a> that represents the <a href="#dfn-empty-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-map-7">empty term map</a>.
      </p></div>

    </section>

    <section id="func_containsKey"><div class="header-wrapper"><h3 id="x8-2-cdt-containskey"><bdi class="secno">8.2 </bdi>cdt:containsKey</h3><a class="self-link" href="#func_containsKey" aria-label="Permalink for Section 8.2"></a></div>
      

      <p>
        <code>xsd:boolean </code>
        <code style="color:black;font-weight:bold">cdt:containsKey</code>
        (
           <code><a href="#dfn-cdt-map-literal" id="ref-for-dfn-cdt-map-literal-21">cdt:Map</a> <var>term<sub>1</sub></var></code>,
           <code><a href="https://www.w3.org/TR/rdf11-concepts/#dfn-rdf-term">RDF term</a> <var>term<sub>2</sub></var></code>
        )
      </p>

      <p>
        If <var>term<sub>1</sub></var> is a <a href="#dfn-well-formed-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-map-literal-6">well-formed cdt:Map literal</a>, then the result of this function is determined by the following algorithm.
      </p>
      <div class="algorithm">
        <ol>
          <li>If the <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-15">term map</a> represented by <var>term<sub>1</sub></var> contains a <a href="#dfn-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-entry-14">map entry</a> (<var>k</var>,<var>v</var>) such that <var>k</var> is the same term as <var>term<sub>2</sub></var>, return <code>true</code>.</li>
          <li>Return <code>false</code>.</li>
        </ol>
      </div>

      <p>
        An error is raised if <var>term<sub>1</sub></var> is not a <a href="#dfn-well-formed-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-map-literal-7">well-formed cdt:Map literal</a>.
      </p>

      <aside class="example" id="example-34"><div class="marker">
    <a class="self-link" href="#example-34">Example<bdi> 34</bdi></a>
  </div>
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">cdt:containsKey( "{'02'^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;: 'two'}"^^cdt:Map, "02"^^xsd:integer )</pre>
        <p>
          results in <code>true</code>, whereas the expression
        </p>
        <pre class="nohighlight">cdt:containsKey( "{'02'^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;: 'two'}"^^cdt:Map, 2 )</pre>
        <p>
          results in <code>false</code>.
      </p></aside>

    </section>

    <section id="func_keys"><div class="header-wrapper"><h3 id="x8-3-cdt-keys"><bdi class="secno">8.3 </bdi>cdt:keys</h3><a class="self-link" href="#func_keys" aria-label="Permalink for Section 8.3"></a></div>
      

      <p>
        <code><a href="#dfn-cdt-list-literal" id="ref-for-dfn-cdt-list-literal-44">cdt:List</a> </code>
        <code style="color:black;font-weight:bold">cdt:keys</code>
        (
           <code><a href="#dfn-cdt-map-literal" id="ref-for-dfn-cdt-map-literal-22">cdt:Map</a> <var>term</var></code>
        )
      </p>

      <p>
        If <var>term</var> is a <a href="#dfn-well-formed-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-map-literal-8">well-formed cdt:Map literal</a>, then the result of this function is a <a href="#dfn-cdt-list-literal" id="ref-for-dfn-cdt-list-literal-45">cdt:List literal</a> that represents a <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-22">term list</a> that consists of all <a href="#dfn-map-key" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-key-7">map keys</a> of the <a href="#dfn-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-entry-15">map entries</a> contained in the <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-16">term map</a> represented by <var>term</var>.
        The order of the elements in this term list is undefined.
      </p>

      <p>
        If <var>term</var> is an <a href="#dfn-ill-formed-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-ill-formed-cdt-map-literal-3">ill-formed cdt:Map literal</a>, then this function produces an error.
      </p>

      <aside class="example" id="example-35"><div class="marker">
    <a class="self-link" href="#example-35">Example<bdi> 35</bdi></a>
  </div>
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">cdt:keys( "{'02'^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;: 'two', 2: 'also two'}"^^cdt:Map )</pre>
        <p>
          results in one of the following two cdt:List literals (either ordering of keys is acceptable).
        </p>
        <pre class="nohighlight">"['02'^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;, '2'^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;]"^^cdt:List
"['2'^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;, '02'^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;]"^^cdt:List</pre>
        <p>
          Note that, beyond the ordering variations, the lexical forms of the literals within the resulting lists may also vary as long as the resulting cdt:list literal is equal to any of the two aforementioned cdt:List literals. For instance, the following cdt:List literal is also a valid result.
        </p>
        <pre class="nohighlight">"['02'^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;, 2]"^^cdt:List</pre>
      </aside>

      <div class="note" role="note" id="issue-container-generatedID-17"><div role="heading" class="note-title marker" id="h-note-17" aria-level="4"><span>Note</span></div><p class="">
        If the <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-17">term map</a> represented by <var>term</var> is the <a href="#dfn-empty-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-map-8">empty term map</a>, then the resulting <a href="#dfn-cdt-list-literal" id="ref-for-dfn-cdt-list-literal-46">cdt:List literal</a> represents the <a href="#dfn-empty-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-list-13">empty term list</a>.
      </p></div>

    </section>

    <section id="func_merge"><div class="header-wrapper"><h3 id="x8-4-cdt-merge"><bdi class="secno">8.4 </bdi>cdt:merge</h3><a class="self-link" href="#func_merge" aria-label="Permalink for Section 8.4"></a></div>
      

      <p>
        <code><a href="#dfn-cdt-map-literal" id="ref-for-dfn-cdt-map-literal-23">cdt:Map</a> </code>
        <code style="color:black;font-weight:bold">cdt:merge</code>
        (
           <code><a href="#dfn-cdt-map-literal" id="ref-for-dfn-cdt-map-literal-24">cdt:Map</a> <var>term<sub>1</sub></var></code>,
           <code><a href="#dfn-cdt-map-literal" id="ref-for-dfn-cdt-map-literal-25">cdt:Map</a> <var>term<sub>2</sub></var></code>
        )
      </p>

      <p>
        If <var>term<sub>1</sub></var> is a <a href="#dfn-well-formed-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-map-literal-9">well-formed cdt:Map literal</a> and <var>term<sub>2</sub></var> is a <a href="#dfn-well-formed-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-map-literal-10">well-formed cdt:Map literal</a>, then the result of this function is a <a href="#dfn-cdt-map-literal" id="ref-for-dfn-cdt-map-literal-26">cdt:Map literal</a> that represents a <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-18">term map</a> containing all <a href="#dfn-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-entry-16">map entries</a> contained in the term map represented by <var>term<sub>1</sub></var>, together with every map entry (<var>k</var>,<var>v</var>) that is contained in the term map represented by <var>term<sub>2</sub></var> and that has a <a href="#dfn-map-key" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-key-8">map key</a>&nbsp;<var>k</var> that is not in the domain of the term map of <var>term<sub>1</sub></var>.
      </p>

      <p>
        If <var>term<sub>1</sub></var> is an <a href="#dfn-ill-formed-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-ill-formed-cdt-map-literal-4">ill-formed cdt:Map literal</a> or <var>term<sub>2</sub></var> is an <a href="#dfn-ill-formed-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-ill-formed-cdt-map-literal-5">ill-formed cdt:Map literal</a>, then this function produces an error.
      </p>

      <aside class="example" id="example-36"><div class="marker">
    <a class="self-link" href="#example-36">Example<bdi> 36</bdi></a>
  </div>
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">cdt:merge( "{1: 'one', 2: 'two'}"^^cdt:Map, "{1: 'another one', 3: 'three'}"^^cdt:Map )</pre>
        <p>
          results in the following cdt:Map literal (or any other cdt:Map literal that is <a href="#func_map-equal">equal</a> to the given one).
        </p>
        <pre class="nohighlight">"{1: 'one', 2: 'two', 3: 'three'}"^^cdt:Map</pre>
      </aside>

      <div class="note" role="note" id="issue-container-generatedID-18"><div role="heading" class="note-title marker" id="h-note-18" aria-level="4"><span>Note</span></div><p class="">
        By the definition of the <code>cdt:merge</code> function, and as illustrated in the example above, if the term maps of the two given cdt:Map literals contain map entries with the same key, then the respective map entry from the first of the two literals is used for the resulting merged term map. The rationale for defining <code>cdt:merge</code> in this way is to be consistent with the default way in which the XPath <a href="https://www.w3.org/TR/xpath-functions/#func-map-merge">map:merge</a> function handles duplicate keys.
      </p></div>

      <div class="note" role="note" id="issue-container-generatedID-19"><div role="heading" class="note-title marker" id="h-note-19" aria-level="4"><span>Note</span></div><p class="">
        If the term map represented by any of the two given cdt:Map literals is the <a href="#dfn-empty-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-map-9">empty term map</a>, then the cdt:Map literal returned by this function represents exactly the same term map as the other of the two given cdt:Map literals (which may, of course, be the empty term map as well).
      </p></div>

    </section>

    <section id="func_put"><div class="header-wrapper"><h3 id="x8-5-cdt-put"><bdi class="secno">8.5 </bdi>cdt:put</h3><a class="self-link" href="#func_put" aria-label="Permalink for Section 8.5"></a></div>
      

      <p>
        <code><a href="#dfn-cdt-map-literal" id="ref-for-dfn-cdt-map-literal-27">cdt:Map</a> </code>
        <code style="color:black;font-weight:bold">cdt:put</code>
        (
           <code><a href="https://www.w3.org/TR/sparql11-query/#expressions">SPARQL expression</a> <var>expr<sub>1</sub></var></code>,
           <code><a href="https://www.w3.org/TR/sparql11-query/#expressions">SPARQL expression</a> <var>expr<sub>2</sub></var></code>
        )
      </p>

      <p>
        <code><a href="#dfn-cdt-map-literal" id="ref-for-dfn-cdt-map-literal-28">cdt:Map</a> </code>
        <code style="color:black;font-weight:bold">cdt:put</code>
        (
           <code><a href="https://www.w3.org/TR/sparql11-query/#expressions">SPARQL expression</a> <var>expr<sub>1</sub></var></code>,
           <code><a href="https://www.w3.org/TR/sparql11-query/#expressions">SPARQL expression</a> <var>expr<sub>2</sub></var></code>,
           <code><a href="https://www.w3.org/TR/sparql11-query/#expressions">SPARQL expression</a> <var>expr<sub>3</sub></var></code>
        )
      </p>

      <p>
        If evaluating the expression <var>expr<sub>1</sub></var> results in a <a href="#dfn-well-formed-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-map-literal-11">well-formed cdt:Map literal</a>, hereafter denoted by <var>lit</var>, and evaluating the expression <var>expr<sub>2</sub></var> results in a <a href="#dfn-map-key" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-key-9">map key</a>, hereafter denoted by <var>key</var>, then the result of this function is a <a href="#dfn-cdt-map-literal" id="ref-for-dfn-cdt-map-literal-29">cdt:Map literal</a> that represents a <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-19">term map</a>&nbsp;<var>tm</var> produced by the following algorithm.
      </p>
      <div class="algorithm">
        <ol>
          <li>Initialize <var>tm</var> as the <a href="#dfn-empty-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-map-10">empty term map</a>.</li>
          <li>Let <var>tm'</var> be the <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-20">term map</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a href="#dfn-cdt-map-datatype" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-datatype-11">cdt:Map datatype</a> to the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form">lexical form</a> of <var>lit</var> (i.e., <var>tm'</var> is the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-literal-value">value</a> of <var>lit</var>).</li>
          <li>For every <a href="#dfn-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-entry-17">map entry</a> (<var>k</var>,<var>v</var>) that is <a href="#dfn-contains-map-entry" id="ref-for-dfn-contains-map-entry-10">contained</a> in <var>tm'</var>:
            <ol>
              <li>If <var>k</var> is not the same term as <var>key</var>, add the map entry (<var>k</var>,<var>v</var>) to <var>tm</var>.</li>
            </ol>
          </li>
          <li>If the expression <var>expr<sub>3</sub></var> is given and evaluating this expression does not result in an error, then add the map entry (<var>key</var>,&nbsp;<var>term</var>) to <var>tm</var>, where <var>term</var> is the RDF terms resulting from the evaluation of <var>expr<sub>3</sub></var>.</li>
          <li>If the expression <var>expr<sub>3</sub></var> is not given or evaluating this expression results in an error, then add the map entry (<var>key</var>,&nbsp;<a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-35">null</a>) to <var>tm</var>.</li>
        </ol>
      </div>

      <p>
        In all other cases an error is raised.
      </p>

      <aside class="example" id="example-37"><div class="marker">
    <a class="self-link" href="#example-37">Example<bdi> 37</bdi></a>
  </div>
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">cdt:put( "{1: 'one'}"^^cdt:Map, 2 )</pre>
        <p>
          results in the following cdt:Map literal (or any other cdt:Map literal that is <a href="#func_map-equal">equal</a> to the given one).
        </p>
        <pre class="nohighlight">"{1: 'one', 2: null}"^^cdt:Map</pre>
      </aside>

      <aside class="example" id="example-38"><div class="marker">
    <a class="self-link" href="#example-38">Example<bdi> 38</bdi></a>
  </div>
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">cdt:put( "{1: 'one', 2: null}"^^cdt:Map, 2, "two" )</pre>
        <p>
          results in the following cdt:Map literal (or any other cdt:Map literal that is <a href="#func_map-equal">equal</a> to the given one).
        </p>
        <pre class="nohighlight">"{1: 'one', 2: 'two'}"^^cdt:Map</pre>
      </aside>

      <div class="note" role="note" id="issue-container-generatedID-20"><div role="heading" class="note-title marker" id="h-note-20" aria-level="4"><span>Note</span></div><p class="">
        If the <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-21">term map</a> <var>tm'</var> represented by <var>lit</var> contains a map entry&nbsp;(<var>k</var>,<var>v</var>) such that <var>k</var> is the same term as <var>key</var> and <var>v</var> is the same term as the result of evaluating <var>expr<sub>3</sub></var> (resp. <var>v</var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-36">null</a> and either <var>expr<sub>3</sub></var> is not given or evaluating <var>expr<sub>3</sub></var> results in an error), then the <a href="#dfn-cdt-map-literal" id="ref-for-dfn-cdt-map-literal-30">cdt:Map literal</a> returned by this function represents exactly the same term map as <var>lit</var>; i.e., <var>tm'</var>.
      </p></div>

    </section>

    <section id="func_remove"><div class="header-wrapper"><h3 id="x8-6-cdt-remove"><bdi class="secno">8.6 </bdi>cdt:remove</h3><a class="self-link" href="#func_remove" aria-label="Permalink for Section 8.6"></a></div>
      

      <p>
        <code><a href="#dfn-cdt-map-literal" id="ref-for-dfn-cdt-map-literal-31">cdt:Map</a> </code>
        <code style="color:black;font-weight:bold">cdt:remove</code>
        (
           <code><a href="#dfn-cdt-map-literal" id="ref-for-dfn-cdt-map-literal-32">cdt:Map</a> <var>term<sub>1</sub></var></code>,
           <code><a href="https://www.w3.org/TR/rdf11-concepts/#dfn-rdf-term">RDF term</a> <var>term<sub>2</sub></var></code>
        )
      </p>

      <p>
        If <var>term<sub>1</sub></var> is a <a href="#dfn-well-formed-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-map-literal-12">well-formed cdt:Map literal</a> and <var>term<sub>2</sub></var> is a <a href="#dfn-map-key" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-key-10">map key</a>, then the result of this function is a <a href="#dfn-cdt-map-literal" id="ref-for-dfn-cdt-map-literal-33">cdt:Map literal</a> that represents a <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-22">term map</a> containing all <a href="#dfn-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-entry-18">map entries</a> contained in the term map represented by <var>term<sub>1</sub></var>, except for any map entry whose map key is the same term as <var>term<sub>2</sub></var>.
      </p>

      <p>
        If <var>term<sub>1</sub></var> is a <a href="#dfn-well-formed-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-map-literal-13">well-formed cdt:Map literal</a> and <var>term<sub>2</sub></var> is not a <a href="#dfn-map-key" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-key-11">map key</a>, then the result of this function is <var>term<sub>1</sub></var>.
      </p>

      <p>
        If <var>term<sub>1</sub></var> is an <a href="#dfn-ill-formed-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-ill-formed-cdt-map-literal-6">ill-formed cdt:Map literal</a>, then this function produces an error.
      </p>

      <aside class="example" id="example-39"><div class="marker">
    <a class="self-link" href="#example-39">Example<bdi> 39</bdi></a>
  </div>
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">cdt:remove( "{1: 'one', 2: null}"^^cdt:Map, 2 )</pre>
        <p>
          results in the following cdt:Map literal (or any other cdt:Map literal that is <a href="#func_map-equal">equal</a> to the given one).
        </p>
        <pre class="nohighlight">"{1: 'one'}"^^cdt:Map</pre>
      </aside>

      <aside class="example" id="example-40"><div class="marker">
    <a class="self-link" href="#example-40">Example<bdi> 40</bdi></a>
  </div>
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">cdt:remove( "{1: 'one'}"^^cdt:Map, 1 )</pre>
        <p>
          results in a cdt:Map literal that represents the <a href="#dfn-empty-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-map-11">empty term map</a>.
        </p>
      </aside>

      <aside class="example" id="example-41"><div class="marker">
    <a class="self-link" href="#example-41">Example<bdi> 41</bdi></a>
  </div>
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">cdt:remove( "{'01'^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;: 'one'}"^^cdt:Map, '1'^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt; )</pre>
        <p>
          results in the cdt:Map literal given as the first argument (or any other cdt:Map literal that is <a href="#func_map-equal">equal</a> to the given one). The fact that the term map represented by the given cdt:Map literal is not changed in this case is because the map key of the map entry in this term map is not the same term as the second argument given to the function (while both are literals that even represent the same <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-literal-value">value</a>, they having different <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form">lexical forms</a>).
        </p>
      </aside>

      <aside class="example" id="example-42"><div class="marker">
    <a class="self-link" href="#example-42">Example<bdi> 42</bdi></a>
  </div>
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">cdt:remove( "{'01'^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;: 'one'}"^^cdt:Map, BNODE() )</pre>
        <p>
          results in the cdt:Map literal given as the first argument, because the second argument is a blank node, which is not a <a href="#dfn-map-key" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-key-12">map key</a>.
        </p>
      </aside>

    </section>

  </section>


  <section id="extension-of-order-by"><div class="header-wrapper"><h2 id="x9-extension-of-order-by"><bdi class="secno">9. </bdi>Extension of ORDER BY</h2><a class="self-link" href="#extension-of-order-by" aria-label="Permalink for Section 9."></a></div>
    

    <p>
      This section extends the definition of the <a href="https://www.w3.org/TR/sparql11-query/#modOrderBy"><code>ORDER BY</code> clause of SPARQL</a> to explicitly define the relative order of two RDF terms that both are <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-47">cdt:List literals</a> or <a href="#dfn-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-literal-34">cdt:Map literals</a>.
    </p>

    <p>
      According to the definition of <code>ORDER BY</code> ordering in <a href="https://www.w3.org/TR/sparql11-query/#modOrderBy">Section&nbsp;15.1</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-query" title="SPARQL 1.1 Query Language">SPARQL11-QUERY</a></cite>], <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-48">cdt:List literals</a> and <a href="#dfn-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-literal-35">cdt:Map literals</a> are ordered higher than any blank node and any IRI (because they are RDF literals).
    </p>

    <section id="relative-order-of-list-literals"><div class="header-wrapper"><h3 id="x9-1-relative-order-of-cdt-list-literals"><bdi class="secno">9.1 </bdi>Relative Order of cdt:List Literals</h3><a class="self-link" href="#relative-order-of-list-literals" aria-label="Permalink for Section 9.1"></a></div>
      

      <p>
        Given two <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-49">cdt:List literals</a> <var>lit<sub>1</sub></var> and <var>lit<sub>2</sub></var>, if they both are <a href="#dfn-well-formed-cdt-list-literal" id="ref-for-dfn-well-formed-cdt-list-literal-17">well-formed</a>, the relative order of these two literals is determined by the algorithm listed below. In brief, the algorithm operates as follows: It iterates over the <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-23">term lists</a> of both literals and compares their elements pairwise. For every pair for which both elements are <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-37">null</a>, the algorithm advances to the next pair. Once the algorithm comes across a pair with only one null value, the corresponding cdt:List literal that contains this null value is ordered lower than the other cdt:List literal. If none of the two elements in the current pair is null, and one of the two elements is ordered higher than the other element, then the cdt:List literal from which this higher-ordered element originates is defined as ordered higher than the other cdt:List literal. It may also be possible that the relative order of the two elements in such a pair is undefined. In such a case the relative order of the two cdt:List literals is undefined as well, unless the two elements are equal, in which case the algorithm also advances to the next pair. If the algorithm reaches the end of at least one of the two term lists and the other term list contains further elements, then the cdt:List literal with the larger term list is ordered higher. If no decision can be made based on any of the aforementioned conditions, then the relative order of the two literals is determined based on their lexical forms.
      </p>
      <div class="algorithm">
        <ol>
          <li>Let <var>list<sub>1</sub></var> be the <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-24">term list</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a href="#dfn-cdt-list-datatype" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-datatype-10">cdt:List datatype</a> to the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form">lexical form</a> of <var>lit<sub>1</sub></var> (i.e., <var>list<sub>1</sub></var> is the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-literal-value">value</a> of <var>lit<sub>1</sub></var>).</li>
          <li>Let <var>list<sub>2</sub></var> be the <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-25">term list</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a href="#dfn-cdt-list-datatype" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-datatype-11">cdt:List datatype</a> to the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form">lexical form</a> of <var>lit<sub>2</sub></var> (i.e., <var>list<sub>2</sub></var> is the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-literal-value">value</a> of <var>lit<sub>2</sub></var>).</li>

          <li>For every integer <var>i</var> from 1 to <var>n</var>, where <var>n</var> is the minimum of the length of <var>list<sub>1</sub></var> and the length of <var>list<sub>2</sub></var>:
            <ol>
              <li>Let <var>elmt<sub>1</sub></var> be the <var>i</var>-th element in <var>list<sub>1</sub></var>.</li>
              <li>Let <var>elmt<sub>2</sub></var> be the <var>i</var>-th element in <var>list<sub>2</sub></var>.</li>
              <li>If <var>elmt<sub>1</sub></var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-38">null</a> and <var>elmt<sub>2</sub></var> is not null, then <var>lit<sub>2</sub></var> is ordered higher than <var>lit<sub>1</sub></var>.</li>
              <li>If <var>elmt<sub>2</sub></var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-39">null</a> and <var>elmt<sub>1</sub></var> is not null, then <var>lit<sub>1</sub></var> is ordered higher than <var>lit<sub>2</sub></var>.</li>
              <li>If neither <var>elmt<sub>1</sub></var> nor <var>elmt<sub>2</sub></var> is null (i.e., both are RDF terms), then:
                <ol>
                  <li>If the relative order of <var>elmt<sub>1</sub></var> and <var>elmt<sub>2</sub></var> is defined such that <var>elmt<sub>1</sub></var> is ordered higher than <var>elmt<sub>2</sub></var>&nbsp;(according to the definition in <a href="https://www.w3.org/TR/sparql11-query/#modOrderBy">Section&nbsp;15.1</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-query" title="SPARQL 1.1 Query Language">SPARQL11-QUERY</a></cite>], and also considering the extension of this definition as provided in this section), then <var>lit<sub>1</sub></var> is ordered higher than <var>lit<sub>2</sub></var>.</li>
                  <li>If the relative order of <var>elmt<sub>1</sub></var> and <var>elmt<sub>2</sub></var> is defined such that <var>elmt<sub>2</sub></var> is ordered higher than <var>elmt<sub>1</sub></var>, then <var>lit<sub>2</sub></var> is ordered higher than <var>lit<sub>1</sub></var>.</li>
                  <li>If evaluating the SPARQL expression <var>elmt<sub>1</sub></var> = <var>elmt<sub>2</sub></var> results in <code>false</code> or in an error, then the relative order of <var>lit<sub>1</sub></var> and <var>lit<sub>2</sub></var> is undefined.</li>
                </ol>
              </li>
            </ol>
          </li>

          <li>If the length of <var>list<sub>1</sub></var> is greater than the length of <var>list<sub>2</sub></var>, then <var>lit<sub>1</sub></var> is ordered higher than <var>lit<sub>2</sub></var>.</li>
          <li>If the length of <var>list<sub>2</sub></var> is greater than the length of <var>list<sub>1</sub></var>, then <var>lit<sub>2</sub></var> is ordered higher than <var>lit<sub>1</sub></var>.</li>

          <li>Let <var>str<sub>1</sub></var> be the literal that has the same lexical form as <var>lit<sub>1</sub></var> and the datatype IRI <code>xsd:string</code>.</li>
          <li>Let <var>str<sub>2</sub></var> be the literal that has the same lexical form as <var>lit<sub>2</sub></var> and the datatype IRI <code>xsd:string</code>.</li>
          <li>If <var>str<sub>1</sub></var> is ordered higher than <var>str<sub>2</sub></var>, then <var>lit<sub>1</sub></var> is ordered higher than <var>lit<sub>2</sub></var>.</li>
          <li>If <var>str<sub>2</sub></var> is ordered higher than <var>str<sub>1</sub></var>, then <var>lit<sub>2</sub></var> is ordered higher than <var>lit<sub>1</sub></var>.</li>

          <li>The relative order of <var>lit<sub>1</sub></var> and <var>lit<sub>2</sub></var> is undefined.</li>
        </ol>
      </div>

      <p>
        If at least one of the two literals, <var>lit<sub>1</sub></var> or <var>lit<sub>2</sub></var>, is <a href="#dfn-ill-formed-cdt-list-literal" id="ref-for-dfn-ill-formed-cdt-list-literal-3">ill-formed</a>, then their relative order is undefined.
      </p>

    </section>

    <section id="relative-order-of-map-literals"><div class="header-wrapper"><h3 id="x9-2-relative-order-of-cdt-map-literals"><bdi class="secno">9.2 </bdi>Relative Order of cdt:Map Literals</h3><a class="self-link" href="#relative-order-of-map-literals" aria-label="Permalink for Section 9.2"></a></div>
      

      <p>
        Given two <a href="#dfn-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-literal-36">cdt:Map literals</a> <var>lit<sub>1</sub></var> and <var>lit<sub>2</sub></var>, if they both are <a href="#dfn-well-formed-cdt-map-literal" id="ref-for-dfn-well-formed-cdt-map-literal-14">well-formed</a>, the relative order of these two literals is determined by the following algorithm.
      </p>
      <div class="algorithm">
        <ol>
          <li>Let <var>map<sub>1</sub></var> be the <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-23">term map</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a href="#dfn-cdt-map-datatype" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-datatype-12">cdt:Map datatype</a> to the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form">lexical form</a> of <var>lit<sub>1</sub></var> (i.e., <var>map<sub>1</sub></var> is the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-literal-value">value</a> of <var>lit<sub>1</sub></var>).</li>
          <li>Let <var>map<sub>2</sub></var> be the term map obtained by applying the lexical-to-value mapping of the cdt:Map datatype to the lexical form of <var>lit<sub>2</sub></var> (i.e., <var>map<sub>2</sub></var> is the value of <var>lit<sub>2</sub></var>).</li>
          <li>Let <var>entrylist<sub>1</sub></var> be a list of all <a href="#dfn-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-entry-19">map entries</a> that are <a href="#dfn-contains-map-entry" id="ref-for-dfn-contains-map-entry-11">contained</a> in <var>map<sub>1</sub></var>, ordered based on their respective <a href="#dfn-map-key" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-key-13">map keys</a> by using the same order as defined in Step&nbsp;6 of the algorithm in Section&nbsp;<a href="#func_map-less-than" class="sectionRef sec-ref"><bdi class="secno">5.4 </bdi>map-less-than</a>.</li>
          <li>Let <var>entrylist<sub>2</sub></var> be a list of all map entries that are contained in <var>map<sub>2</sub></var>, ordered in the same way as <var>entrylist<sub>1</sub></var>.</li>
          <li>For every integer <var>i</var> from 1 to <var>n</var>, where <var>n</var> is the minimum of the respective length of <var>entrylist<sub>1</sub></var> and of <var>entrylist<sub>2</sub></var>:
            <ol>
              <li>Let (<var>k<sub>1</sub></var>, <var>v<sub>1</sub></var>) be the <var>i</var>-th map entry in <var>entrylist<sub>1</sub></var>.</li>
              <li>Let (<var>k<sub>2</sub></var>, <var>v<sub>2</sub></var>) be the <var>i</var>-th map entry in <var>entrylist<sub>2</sub></var>.</li>
              <li>If evaluating the SPARQL expression <a href="https://www.w3.org/TR/sparql11-query/#func-sameTerm"><code>SAMETERM</code></a>(<var>k<sub>1</sub></var>, <var>k<sub>2</sub></var>) results in <code>false</code>, then:
                <ol>
                  <li>If <var>k<sub>1</sub></var> is ordered before <var>k<sub>2</sub></var> according to the ordering of map keys as used above for creating <var>entrylist<sub>1</sub></var> (and as defined in Step&nbsp;6 of the algorithm in Section&nbsp;<a href="#func_map-less-than" class="sectionRef sec-ref"><bdi class="secno">5.4 </bdi>map-less-than</a>), then <var>lit<sub>1</sub></var> is ordered before <var>lit<sub>2</sub></var>.</li>
                  <li><var>lit<sub>2</sub></var> is ordered before <var>lit<sub>1</sub></var>.</li>
                </ol>
              </li>
              <li>If <var>v<sub>1</sub></var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-40">null</a> and <var>v<sub>2</sub></var> is not null, then <var>lit<sub>2</sub></var> is ordered higher than <var>lit<sub>1</sub></var>.</li>
              <li>If <var>v<sub>2</sub></var> is null and <var>v<sub>1</sub></var> is not null, then <var>lit<sub>1</sub></var> is ordered higher than <var>lit<sub>2</sub></var>.</li>
              <li>If neither <var>v<sub>1</sub></var> nor <var>v<sub>2</sub></var> is null (i.e., both are RDF terms), then:
                <ol>
                  <li>If the order of <var>v<sub>1</sub></var> and <var>v<sub>2</sub></var> is defined such that <var>v<sub>1</sub></var> is ordered higher than <var>v<sub>2</sub></var>, then <var>lit<sub>1</sub></var> is ordered higher than <var>lit<sub>2</sub></var>.</li>
                  <li>If the order of <var>v<sub>1</sub></var> and <var>v<sub>2</sub></var> is defined such that <var>v<sub>2</sub></var> is ordered higher than <var>v<sub>1</sub></var>, then <var>lit<sub>2</sub></var> is ordered higher than <var>lit<sub>1</sub></var>.</li>
                  <li>If evaluating the SPARQL expression <var>v<sub>1</sub></var> = <var>v<sub>2</sub></var> results in <code>false</code> or in an error, then the relative order of <var>lit<sub>1</sub></var> and <var>lit<sub>2</sub></var> is undefined.</li>
                </ol>
              </li>
            </ol>
          </li>

          <li>If the length of <var>entrylist<sub>1</sub></var> is greater than the length of <var>entrylist<sub>2</sub></var>, then <var>lit<sub>1</sub></var> is ordered higher than <var>lit<sub>2</sub></var>.</li>
          <li>If the length of <var>entrylist<sub>2</sub></var> is greater than the length of <var>entrylist<sub>1</sub></var>, then <var>lit<sub>2</sub></var> is ordered higher than <var>lit<sub>1</sub></var>.</li>

          <li>Let <var>str<sub>1</sub></var> be the literal that has the same lexical form as <var>lit<sub>1</sub></var> and the datatype IRI <code>xsd:string</code>.</li>
          <li>Let <var>str<sub>2</sub></var> be the literal that has the same lexical form as <var>lit<sub>2</sub></var> and the datatype IRI <code>xsd:string</code>.</li>
          <li>If <var>str<sub>1</sub></var> is ordered higher than <var>str<sub>2</sub></var>, then <var>lit<sub>1</sub></var> is ordered higher than <var>lit<sub>2</sub></var>.</li>
          <li>If <var>str<sub>2</sub></var> is ordered higher than <var>str<sub>1</sub></var>, then <var>lit<sub>2</sub></var> is ordered higher than <var>lit<sub>1</sub></var>.</li>

          <li>The relative order of <var>lit<sub>1</sub></var> and <var>lit<sub>2</sub></var> is undefined.</li>
        </ol>
      </div>

      <p>
        If at least one of the two literals, <var>lit<sub>1</sub></var> or <var>lit<sub>2</sub></var>, is <a href="#dfn-ill-formed-cdt-map-literal" id="ref-for-dfn-ill-formed-cdt-map-literal-7">ill-formed</a>, then their relative order is undefined.
      </p>

    </section>

  </section>


  <section id="fold"><div class="header-wrapper"><h2 id="x10-fold"><bdi class="secno">10. </bdi>FOLD</h2><a class="self-link" href="#fold" aria-label="Permalink for Section 10."></a></div>
    

    <p>
      This section defines a new SPARQL <a href="https://www.w3.org/TR/sparql11-query/#setFunctions">Set Function</a>, <code>FOLD</code>, used to construct composite values.
      As illustrated in Section&nbsp;<a href="#description-of-fold" class="sectionRef sec-ref"><bdi class="secno">2.3 </bdi>FOLD Aggregate</a>, this function can be used to collect individual values into <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-50">cdt:List literals</a> and <a href="#dfn-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-literal-37">cdt:Map literals</a>.
    </p>

    <section id="fold-grammar"><div class="header-wrapper"><h3 id="x10-1-grammar"><bdi class="secno">10.1 </bdi>Grammar</h3><a class="self-link" href="#fold-grammar" aria-label="Permalink for Section 10.1"></a></div>
      

      <p>
        Adding the FOLD aggregate to SPARQL requires the following extension of the <a href="https://www.w3.org/TR/sparql11-query/#rAggregate"><code>Aggregate</code></a> production of the <a href="https://www.w3.org/TR/sparql11-query/#sparqlGrammar">SPARQL grammar</a>. The part in which the extended production differs from the corresponding production in the original grammar is marked in bold font. The given production rule uses several symbols for which no production rule is provided below (e.g., <a href="https://www.w3.org/TR/sparql11-query/#rExpression">Expression</a>, <a href="https://www.w3.org/TR/sparql11-query/#rOrderCondition">OrderCondition</a>); the production rules for these symbols are defined as given in the original SPARQL grammar.
      </p>

      <table class="grammar">

        <tbody><tr id="rAggregate">
          <td>[127+]</td>
          <td><code>Aggregate</code></td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <code>&nbsp;
            <span class="token">'COUNT'</span>
            <span class="token">'('</span>
            <span class="token">'DISTINCT'</span>?
            ( <span class="token">'*'</span> | <a href="https://www.w3.org/TR/sparql11-query/#rExpression">Expression</a> )
            <span class="token">')'</span>
            <br>
            <code>|</code>
            <span class="token">'SUM'</span>
            <span class="token">'('</span>
            <span class="token">'DISTINCT'</span>?
            <a href="https://www.w3.org/TR/sparql11-query/#rExpression">Expression</a>
            <span class="token">')'</span>
            <br>
            <code>|</code>
            <span class="token">'MIN'</span>
            <span class="token">'('</span>
            <span class="token">'DISTINCT'</span>?
            <a href="https://www.w3.org/TR/sparql11-query/#rExpression">Expression</a>
            <span class="token">')'</span>
            <br>
            <code>|</code>
            <span class="token">'MAX'</span>
            <span class="token">'('</span>
            <span class="token">'DISTINCT'</span>?
            <a href="https://www.w3.org/TR/sparql11-query/#rExpression">Expression</a>
            <span class="token">')'</span>
            <br>
            <code>|</code>
            <span class="token">'AVG'</span>
            <span class="token">'('</span>
            <span class="token">'DISTINCT'</span>?
            <a href="https://www.w3.org/TR/sparql11-query/#rExpression">Expression</a>
            <span class="token">')'</span>
            <br>
            <code>|</code>
            <span class="token">'SAMPLE'</span>
            <span class="token">'('</span>
            <span class="token">'DISTINCT'</span>?
            <a href="https://www.w3.org/TR/sparql11-query/#rExpression">Expression</a>
            <span class="token">')'</span>
            <br>
            <code>|</code>
            <span class="token">'GROUP_CONCAT'</span>
            <span class="token">'('</span>
            <span class="token">'DISTINCT'</span>?
            <a href="https://www.w3.org/TR/sparql11-query/#rExpression">Expression</a>
            ( <span class="token">';'</span> <span class="token">'SEPARATOR'</span> <span class="token">'='</span> <a href="https://www.w3.org/TR/sparql11-query/#rString">String</a> )?
            <span class="token">')'</span>
            <br>
            <strong>
            <code>|</code>
            <span class="token">'FOLD'</span>
            <span class="token">'('</span>
            <span class="token">'DISTINCT'</span>?
            <a href="https://www.w3.org/TR/sparql11-query/#rExpression">Expression</a>
            ( <span class="token">','</span> <a href="https://www.w3.org/TR/sparql11-query/#rExpression">Expression</a> )?
            ( <span class="token">'ORDER'</span> <span class="token">'BY'</span> <a href="https://www.w3.org/TR/sparql11-query/#rOrderCondition">OrderCondition</a>+ )?
            <span class="token">')'</span>
            </strong>
            </code>
          </td>
        </tr>

      </tbody></table>

    </section>

    <section id="fold-translation"><div class="header-wrapper"><h3 id="x10-2-translation-to-the-algebra"><bdi class="secno">10.2 </bdi>Translation to the Algebra</h3><a class="self-link" href="#fold-translation" aria-label="Permalink for Section 10.2"></a></div>
      

      <p>
        Based on the SPARQL grammar, the SPARQL specification <q>defines the process of converting graph patterns and solution modifiers in a SPARQL query string into a SPARQL algebra expression</q> (see <a href="https://www.w3.org/TR/sparql11-query/#sparqlQuery">Section&nbsp;18.2</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-query" title="SPARQL 1.1 Query Language">SPARQL11-QUERY</a></cite>]).
        This process must be adapted to consider FOLD clauses as added by the extended grammar introduced above.
        In particular, the step of translating grouping and aggregation during this process needs to be extended.
        The original algorithm that defines this translation is given in <a href="https://www.w3.org/TR/sparql11-query/#sparqlGroupAggregate">Section&nbsp;18.2.4.1</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-query" title="SPARQL 1.1 Query Language">SPARQL11-QUERY</a></cite>].
        The extended version of the algorithm is given as follows, where the parts that are modified or added to cover the FOLD operator are marked in bold font.
      </p>
      <div style="width: 100%; border: 1px solid; padding: 5px">
        <pre class="nohighlight" style="margin: 0px">Let A := the empty sequence
Let Q := the query level being evaluated
Let P := the algebra translation of the GroupGraphPattern of the query level
Let E := [], a list of pairs of the form (variable, expression)

If Q contains GROUP BY exprlist
   Let G := Group(exprlist, P)
Else If Q contains an aggregate in SELECT, HAVING, ORDER BY
   Let G := Group((1), P)
Else
   skip the rest of the aggregate step
   End

Global i := 1   # Initially 1 for each query processed

For each (X AS Var) in SELECT, each HAVING(X), and each ORDER BY X in Q
  For each unaggregated variable V in X
      Replace V with Sample(V)
      End
  For each aggregate R(args <strong>ORDER BY orderconditions</strong>; scalarvals) now in X
      <strong># note ORDER BY clause may be omitted</strong>
      # note scalarvals may be omitted, then it's equivalent to the empty set
      <strong>If aggregate contains ORDER BY orderconditions
          G := OrderGroups(G, orderconditions)
          End
      If R = Fold
          If |args| = 1
              setfunc = Fold1
          Else
              setfunc = Fold2
              End
      Else
          setfunc = R
          End</strong>
      A<sub>i</sub> := Aggregation(args, <strong>setfunc</strong>, scalarvals, G)
      Replace R(...) with agg<sub>i</sub> in Q
      i := i + 1
      End
  End

For each variable V appearing outside of an aggregate
   A<sub>i</sub> := Aggregation(V, Sample, {}, G)
   E := E append (V, agg<sub>i</sub>)
   i := i + 1
   End

A := A<sub>i</sub>, ..., A<sub>i-1</sub>
P := AggregateJoin(A)</pre>
      </div>

      <p>
        Notice that the extended algorithm uses the new algebra symbol <code>OrderGroups</code>. Hence, to use this algorithm, the list of symbols in the SPARQL algebra (as given in the second table of <a href="https://www.w3.org/TR/sparql11-query/#sparqlQuery">Section&nbsp;18.2</a> [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-query" title="SPARQL 1.1 Query Language">SPARQL11-QUERY</a></cite>]) needs to be extended by adding this symbol. The evaluation semantics of algebra expressions that contain this symbol is defined in the following.
      </p>

    </section>

    <section id="ordergroups-algebra"><div class="header-wrapper"><h3 id="x10-3-algebra"><bdi class="secno">10.3 </bdi>Algebra</h3><a class="self-link" href="#ordergroups-algebra" aria-label="Permalink for Section 10.3"></a></div>
      

      <p>
        This section defines an operator for evaluating the new algebra symbol (as <a href="https://www.w3.org/TR/sparql11-query/#sparqlAlgebra">Section&nbsp;18.5</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-query" title="SPARQL 1.1 Query Language">SPARQL11-QUERY</a></cite>] does for the standard SPARQL algebra symbols). This operator has the same name as the algebra symbol and shall be used in the following section to extend the evaluation semantics of algebra expressions that may contain the new algebra symbol.
      </p>

      <div class="defn">
        <p><b>Definition: <dfn id="defn_algOrderGroups" style="font-style:normal" tabindex="0" aria-haspopup="dialog" data-dfn-type="dfn">OrderGroups</dfn></b></p>
        <p>
          Let {&nbsp;<var>key<sub>1</sub></var>→<var>Ψ<sub>1</sub></var>, ..., <var>key<sub>m</sub></var>→<var>Ψ<sub><var>m</var></sub></var>&nbsp;} be a partial function from keys to solution sequences. OrderGroups({&nbsp;<var>key<sub>1</sub></var>→<var>Ψ<sub>1</sub></var>, ..., <var>key<sub><var>m</var></sub></var>→<var>Ψ<sub><var>m</var></sub></var>&nbsp;}, <var>condition</var>) is also a partial function from keys to solution sequences that is defined as follows:
        </p>
        <p>
          OrderGroups({&nbsp;<var>key<sub>1</sub></var>→<var>Ψ<sub>1</sub></var>, ..., <var>key<sub><var>m</var></sub></var>→<var>Ψ<sub><var>m</var></sub></var>&nbsp;}, <var>condition</var>) =
          {
          <var>key<sub>1</sub></var>→<a href="https://www.w3.org/TR/sparql11-query/#defn_algOrderBy">OrderBy</a>(<var>Ψ<sub>1</sub></var>, <var>condition</var>),
          ...,
          <var>key<sub><var>m</var></sub></var>→<a href="https://www.w3.org/TR/sparql11-query/#defn_algOrderBy">OrderBy</a>(<var>Ψ<sub><var>m</var></sub></var>, <var>condition</var>)
          }
        </p>
      </div>

      <section id="aggregateAlgebra"><div class="header-wrapper"><h4 id="x10-3-1-aggregate-algebra"><bdi class="secno">10.3.1 </bdi>Aggregate Algebra</h4><a class="self-link" href="#aggregateAlgebra" aria-label="Permalink for Section 10.3.1"></a></div>
        
        <p>Two new set functions are introduced to support the FOLD aggregate:</p>

        <section id="aggFold1"><div class="header-wrapper"><h5 id="x10-3-1-1-fold1"><bdi class="secno">10.3.1.1 </bdi>Fold1</h5><a class="self-link" href="#aggFold1" aria-label="Permalink for Section 10.3.1.1"></a></div>
          
          <p>
            Fold1 is a SPARQL set function which combines the elements in the aggregate group into a <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-51">cdt:List literal</a>.
          </p>
          <div class="defn">
            <p><b>Definition: <span id="defn_aggFold1">Fold1</span></b></p>
            <pre class="code nohighlight"><a href="#dfn-cdt-list-literal" id="ref-for-dfn-cdt-list-literal-52">cdt:List</a> Fold1(sequence <var>S</var>)</pre>
            <p><var>L</var> = Flatten(<var>S</var>)</p>
            <p><var>n</var> = |<var>L</var>|</p>
            <p>
              Fold1(<var>S</var>) is a <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-53">cdt:List literal</a> that represents a <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-26">term list</a>&nbsp;<var>tm</var> that contains <var>n</var> elements where, for every <var>i</var> in {1, ..., <var>n</var>}, the element at the <var>i</var>-th position of <var>tm</var> is determined as follows: If the element at the <var>i</var>-th position of <var>L</var> is an error, then the element at the <var>i</var>-th position of <var>tm</var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-41">null</a>. Otherwise, the element at the <var>i</var>-th position of <var>tm</var> is the element at the <var>i</var>-th position of <var>L</var>.
            </p>
          </div>
          <div class="note" role="note" id="issue-container-generatedID-21"><div role="heading" class="note-title marker" id="h-note-21" aria-level="6"><span>Note</span></div><p class="">
            If <var>S</var> is the empty sequence, then <var>n</var>=0 and, thus, the result of Fold1(<var>S</var>) is a <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-54">cdt:List literal</a> that represents the <a href="#dfn-empty-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-list-14">empty term list</a>.
          </p></div>
          <div class="note" role="note" id="issue-container-generatedID-22"><div role="heading" class="note-title marker" id="h-note-22" aria-level="6"><span>Note</span></div><p class="">
            By its definition, Fold1 behaves in the same way as the <a href="#func_list">cdt:List</a> function if that function is invoked by passing each element of <var>L</var> as a separate argument.
          </p></div>
        </section>

        <section id="aggFold2"><div class="header-wrapper"><h5 id="x10-3-1-2-fold2"><bdi class="secno">10.3.1.2 </bdi>Fold2</h5><a class="self-link" href="#aggFold2" aria-label="Permalink for Section 10.3.1.2"></a></div>
          
          <p>
            Fold2 is a SPARQL set function which combines the elements in the aggregate group into a <a href="#dfn-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-literal-38">cdt:Map literal</a>.
          </p>
          <div class="defn">
            <p><b>Definition: <span id="defn_aggFold2">Fold2</span></b></p>
            <pre class="code nohighlight"><a href="#dfn-cdt-map-literal" id="ref-for-dfn-cdt-map-literal-39">cdt:Map</a> Fold2(sequence <var>S</var>)</pre>
            <p><var>L</var> = Flatten(<var>S</var>)</p>
            <p>
              <var>n</var> = |<var>L</var>|
              <br>
              Note that <var>n</var> is an even number, which is due to
              i)&nbsp;the <a href="#fold-grammar">grammar of the FOLD aggregate</a>,
              ii)&nbsp;the corresponding <a href="#fold-translation">translation to the algebra</a>, and
              iii)&nbsp;the definition of the <a href="https://www.w3.org/TR/sparql11-query/#defn_algAggregation%20">Aggregation</a> operator.
            </p>
            <p>
              Fold2(<var>S</var>) is a <a href="#dfn-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-literal-40">cdt:Map literal</a> that represents a <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-24">term map</a>&nbsp;<var>tm</var> that is constructed by the following algorithm.
            </p>
            <div class="algorithm">
              <ol>
                <li>Initialize <var>tm</var> as the <a href="#dfn-empty-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-map-12">empty term map</a>.</li>
                <li>For every integer <var>i</var> from 1 to <var>n</var>/2:
                  <ol>
                    <li>Let <var>k</var> be the element at the (2<var>i</var>-1)-th position of <var>L</var>.</li>
                    <li>Let <var>v</var> be the element at the 2<var>i</var>-th position of <var>L</var>.</li>
                    <li>If <var>k</var> is neither an error nor a blank node, then:
                      <ol>
                        <li>If <var>tm</var> contains a <a href="#dfn-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-entry-20">map entry</a> (<var>k'</var>,<var>v'</var>) such that <var>k</var>=<var>k'</var>, then replace this map entry (<var>k'</var>,<var>v'</var>) by the map entry (<var>k</var>,<var>v</var>). Otherwise, add the map entry (<var>k</var>,<var>v</var>) to <var>tm</var>.</li>
                      </ol>
                    </li>
                  </ol>
                </li>
              </ol>
            </div>
          </div>
          <div class="note" role="note" id="issue-container-generatedID-23"><div role="heading" class="note-title marker" id="h-note-23" aria-level="6"><span>Note</span></div><p class="">
            If <var>S</var> is the empty sequence, then <var>n</var>=0 and, thus, the result of Fold2(<var>S</var>) is a <a href="#dfn-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-literal-41">cdt:Map literal</a> that represents the <a href="#dfn-empty-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-map-13">empty term map</a>.
          </p></div>
          <div class="note" role="note" id="issue-container-generatedID-24"><div role="heading" class="note-title marker" id="h-note-24" aria-level="6"><span>Note</span></div><p class="">
            By its definition, Fold2 behaves in the same way as the <a href="#func_map">cdt:Map</a> function if that function is invoked by passing each element of <var>L</var> as a separate argument.
          </p></div>
        </section>

      </section>

    </section>

    <section id="ordergroups-semantics"><div class="header-wrapper"><h3 id="x10-4-evaluation-semantics"><bdi class="secno">10.4 </bdi>Evaluation Semantics</h3><a class="self-link" href="#ordergroups-semantics" aria-label="Permalink for Section 10.4"></a></div>
      

      <p>
        The SPARQL specification defines a function <q>eval(D(G), algebra expression) as the evaluation of an algebra expression with respect to a dataset D having active graph G</q> (see <a href="https://www.w3.org/TR/sparql11-query/#sparqlAlgebraEval">Section&nbsp;18.6</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-query" title="SPARQL 1.1 Query Language">SPARQL11-QUERY</a></cite>]). The definition of this function is recursive. To cover algebra expressions that may contain the new algebra symbol (<code>OrderGroups</code>) the definition of this function needs to be extended with the following additional case.
      </p>

      <div class="defn">
        <p><b>Definition: <dfn id="defn_evalOrderGroups" style="font-style:normal" tabindex="0" aria-haspopup="dialog" class="respec-offending-element" title="Found definition for &quot;Evaluation of OrderGroups&quot;, but nothing links to it. This is usually a spec bug!" data-dfn-type="dfn">Evaluation of OrderGroups</dfn></b></p>
        <p>
          eval(D(G), <code>OrderGroups(</code><var style="font-style: normal"><code>L</code></var>, <var style="font-style: normal"><code>orderconditions</code></var><code>)</code>) = <a href="#defn_algOrderGroups" class="internalDFN" data-link-type="dfn" id="ref-for-defn_algOrderGroups-1">OrderGroups</a>(eval(D(G), <var style="font-style: normal"><code>L</code></var>), <var style="font-style: normal"><code>orderconditions</code></var>)
        </p>
      </div>

    </section>

  </section>



  <section id="unfold"><div class="header-wrapper"><h2 id="x11-unfold"><bdi class="secno">11. </bdi>UNFOLD</h2><a class="self-link" href="#unfold" aria-label="Permalink for Section 11."></a></div>
    

    <p>
      This section defines an extension of the SPARQL language that adds a new operator called UNFOLD. As illustrated in Section&nbsp;<a href="#description-of-unfold" class="sectionRef sec-ref"><bdi class="secno">2.4 </bdi>UNFOLD Operator</a>, this operator can be used to transform composite values (given in the form of <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-55">cdt:List literals</a> or <a href="#dfn-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-literal-42">cdt:Map literals</a>) into their individual components and assigns these components separately to new query variables.
    </p>

    <p>
      In particular, recall from Section&nbsp;<a href="#description-of-unfold" class="sectionRef sec-ref"><bdi class="secno">2.4 </bdi>UNFOLD Operator</a> that there are two variations of this operator: one that assigns a single new query variable (i.e., <code>UNFOLD(expr AS ?v1)</code>) and another one that assigns two new query variables (i.e., <code>UNFOLD(expr AS ?v1, ?v2)</code>).
      When applied to <a href="#dfn-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-literal-56">cdt:List literals</a>, the one-variable version binds the new variable to each of the RDF terms in the corresponding <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-27">term list</a> (or leaves it unbound for <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-42">null</a> values) and the two-variables version binds the first new variable to each RDF term in the term list (or leaves it unbound for null values) and the second variable to the corresponding position of the term/null in the list.
      When applied to <a href="#dfn-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-literal-43">cdt:Map literals</a>, the one-variable version binds the variable to each of the keys in the <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-25">term map</a> and the two-variables version binds the first variable to each key in the term map and the second variable to the corresponding value (or leaves it unbound for null values).
    </p>

    <div class="note" role="note" id="issue-container-generatedID-25"><div role="heading" class="note-title marker" id="h-note-25" aria-level="3"><span>Note</span></div><p class="">
      Note that there is an asymmetry between the two-variables version of UNFOLD for cdt:List literals and the two-variables version for cdt:Map literals. In the case of maps, the values are assigned to the second variable whereas, for lists, the values (the list elements) are assigned to the first variable.
      <br><br>
      While it would be possible to eliminate this asymmetry by changing the two-variables version of UNFOLD for cdt:List literals such that the list elements are assigned to the second variable (and the positions to the first variable), doing so would introduce another asymmetry: This asymmetry would then be between the so-changed two-variables version and the one-variable version of UNFOLD for cdt:List literals, because the latter binds the first (and, in this case, only) variable to the values. A follow-up change to eliminate this asymmetry as well may be to define the one-variable version such that it assigns the (single) variable to the positions and not to the list elements. However, this definition would have a very limited practical value and, thus, the initially mentioned asymmetry is considered as the best possible compromise.
    </p></div>

    <p>
      Adding this new UNFOLD operator to the language requires an extension to the grammar of SPARQL, an extension of the SPARQL algebra, and corresponding extensions both of the process of converting SPARQL graph patterns into SPARQL algebra expressions and of the evaluation semantics. The following sections define these extensions.
    </p>

    <section id="unfold-grammar"><div class="header-wrapper"><h3 id="x11-1-grammar"><bdi class="secno">11.1 </bdi>Grammar</h3><a class="self-link" href="#unfold-grammar" aria-label="Permalink for Section 11.1"></a></div>
      

      <p>
        Adding the UNFOLD operator to SPARQL requires the following extension of the <a href="https://www.w3.org/TR/sparql11-query/#rGraphPatternNotTriples"><code>GraphPatternNotTriples</code></a> production of the <a href="https://www.w3.org/TR/sparql11-query/#sparqlGrammar">SPARQL grammar</a>. The part in which the extended production differs from the corresponding production in the original grammar is marked in bold font. The second production defined below (i.e., <a href="#rUnfold"><code>Unfold</code></a>) needs to be added and has no counterpart in the original grammar. The given production rules use several symbols for which no production rule is provided below (e.g., <a href="https://www.w3.org/TR/sparql11-query/#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a>, <a href="https://www.w3.org/TR/sparql11-query/#rExpression">Expression</a>); the production rules for these symbols are defined as given in the original SPARQL grammar.
      </p>

      <table class="grammar">

        <tbody><tr id="rGraphPatternNotTriples">
          <td>[56+]</td>
          <td><code>GraphPatternNotTriples</code></td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <a href="https://www.w3.org/TR/sparql11-query/#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a>
            <code>|</code>
            <a href="https://www.w3.org/TR/sparql11-query/#rOptionalGraphPattern">OptionalGraphPattern</a>
            <code>|</code>
            <a href="https://www.w3.org/TR/sparql11-query/#rMinusGraphPattern">MinusGraphPattern</a>
            <code>|</code>
            <a href="https://www.w3.org/TR/sparql11-query/#rGraphGraphPattern">GraphGraphPattern</a>
            <code>|</code>
            <a href="https://www.w3.org/TR/sparql11-query/#rServiceGraphPattern">ServiceGraphPattern</a>
            <code>|</code>
            <a href="https://www.w3.org/TR/sparql11-query/#rFilter">Filter</a>
            <code>|</code>
            <a href="https://www.w3.org/TR/sparql11-query/#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a>
            <code>|</code>
            <a href="https://www.w3.org/TR/sparql11-query/#rBind">Bind</a>
            <code>|</code>
            <a href="https://www.w3.org/TR/sparql11-query/#rInlineData">InlineData</a>
            <strong>
            <code>|</code>
            <a href="#rUnfold">Unfold</a>
            </strong>
          </td>
        </tr>

        <tr id="rUnfold">
          <td>[174]</td>
          <td><code>Unfold</code></td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <code class="token">'UNFOLD'</code>
            <code class="token">'('</code>
            <a href="https://www.w3.org/TR/sparql11-query/#rExpression">Expression</a>
            <code class="token">'AS'</code>
            <a href="https://www.w3.org/TR/sparql11-query/#rVar">Var</a>
            <code>(</code>
            <code class="token">','</code>
            <a href="https://www.w3.org/TR/sparql11-query/#rVar">Var</a>
            <code>)?</code>
            <code class="token">')'</code>
          </td>
        </tr>

      </tbody></table>

      <p>
        Two additional constraints <em class="rfc2119">MUST</em> be satisfied when using the UNFOLD operator:
      </p>
      <ol>
        <li>
          For every expression of the form <code>UNFOLD(expr AS v, v')</code>, <code>v</code> and <code>v'</code> <em class="rfc2119">MUST</em> be two different variables.
        </li>
        <li>
          Second, the variable(s) assigned in an UNFOLD operator must not be already in use; more formally:
        </li>
        <ul>
          <li>For every expression of the form <code>UNFOLD(expr AS v)</code>, the variable <code>v</code> <em class="rfc2119">MUST NOT</em> be <a href="https://www.w3.org/TR/sparql11-query/#variableScope">in-scope</a> from the preceding elements in the group graph pattern in which the expression is used.</li>
          <li>For every expression of the form <code>UNFOLD(expr AS v, v')</code>, the variable <code>v</code> <em class="rfc2119">MUST NOT</em> be <a href="https://www.w3.org/TR/sparql11-query/#variableScope">in-scope</a> from the preceding elements in the group graph pattern in which the expression is used, and the same holds for the variable <code>v'</code>.</li>
        </ul>
      </ol>

      <p>
        The notion of in-scope variables as used in the second constraint is defined in <a href="https://www.w3.org/TR/sparql11-query/#variableScope">Section&nbsp;18.2.1</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-query" title="SPARQL 1.1 Query Language">SPARQL11-QUERY</a></cite>]. When using the extended syntax with the UNFOLD operator, this notion must be extended as well. To capture this extension formally, the table in <a href="https://www.w3.org/TR/sparql11-query/#variableScope">Section&nbsp;18.2.1</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-query" title="SPARQL 1.1 Query Language">SPARQL11-QUERY</a></cite>] is augmented with the following two additional rows.
      </p>
      <table class="inscope">
        <tbody><tr>
          <th>Syntax Form</th>
          <th>In-scope variables</th>
        </tr>
        <tr>
          <td><code>UNFOLD(expr AS v)</code> </td>
          <td style="padding-left: 30px;"> <code>v</code> is in-scope</td>
        </tr>
        <tr style="padding-left: 30px;">
          <td><code>UNFOLD(expr AS v, v')</code> </td>
          <td> <code>v</code> and <code>v'</code> are in-scope</td>
        </tr>
      </tbody></table>

    </section>

    <section id="unfold-translation"><div class="header-wrapper"><h3 id="x11-2-translation-to-the-algebra"><bdi class="secno">11.2 </bdi>Translation to the Algebra</h3><a class="self-link" href="#unfold-translation" aria-label="Permalink for Section 11.2"></a></div>
      

      <p>
        Based on the SPARQL grammar, the SPARQL specification <q>defines the process of converting graph patterns and solution modifiers in a SPARQL query string into a SPARQL algebra expression</q> (see <a href="https://www.w3.org/TR/sparql11-query/#sparqlQuery">Section&nbsp;18.2</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-query" title="SPARQL 1.1 Query Language">SPARQL11-QUERY</a></cite>]). This process must be adapted to consider UNFOLD clauses as added by the extended grammar introduced above. In particular, the step of translating group graph patterns (<a href="https://www.w3.org/TR/sparql11-query/#rGroupGraphPattern">GroupGraphPattern</a>) during this process needs to be extended. The original algorithm that defines this translation is given in <a href="https://www.w3.org/TR/sparql11-query/#sparqlTranslateGraphPatterns">Section&nbsp;18.2.2.6</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-query" title="SPARQL 1.1 Query Language">SPARQL11-QUERY</a></cite>]. The extended version of the algorithm is given as follows, where the parts that are added to cover the UNFOLD operator are marked in bold font.
      </p>
      <div style="width: 100%; border: 1px solid; padding: 5px">
        <pre class="nohighlight" style="margin: 0px">Let G := the empty pattern, a basic graph pattern which is the empty set.

For each element E in the GroupGraphPattern

    If E is of the form OPTIONAL{P}
        Let A := Translate(P)
        If A is of the form Filter(F, A2)
            G := LeftJoin(G, A2, F)
        Else
            G := LeftJoin(G, A, true)
            End
        End

    If E is of the form MINUS{P}
        G := Minus(G, Translate(P))
        End

    If E is of the form BIND(expr AS var)
        G := Extend(G, var, expr)
        End</pre>

        <pre class="nohighlight" style="margin: 0px;
                                        font-weight: bold;
                                        padding-left: 4ch;
                                        padding-top: 3ex;
                                        padding-bottom: 3ex;">If E is of the form UNFOLD(expr AS var)
    G := Unfold1(G, var, expr)
    End

If E is of the form UNFOLD(expr AS var1, var2)
    G := Unfold2(G, var1, var2, expr)
    End</pre>
        <pre class="nohighlight" style="margin: 0px">    If E is any other form
        Let A := Translate(E)
        G := Join(G, A)
        End

   End

The result is G.</pre>
      </div>

      <p>
        Notice that the extended algorithm uses two new algebra symbols: <code>Unfold1</code> and <code>Unfold2</code>. Hence, to use this algorithm, the list of symbols in the SPARQL algebra (as given in the second table of <a href="https://www.w3.org/TR/sparql11-query/#sparqlQuery">Section&nbsp;18.2</a> [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-query" title="SPARQL 1.1 Query Language">SPARQL11-QUERY</a></cite>]) needs to be extended by adding these two symbols. The evaluation semantics of algebra expressions that contain any of these two symbols is defined in the following.
      </p>

    </section>

    <section id="unfold-algebra"><div class="header-wrapper"><h3 id="x11-3-algebra"><bdi class="secno">11.3 </bdi>Algebra</h3><a class="self-link" href="#unfold-algebra" aria-label="Permalink for Section 11.3"></a></div>
      

      <p>
        This section defines operators for evaluating the two new algebra symbols (as <a href="https://www.w3.org/TR/sparql11-query/#sparqlAlgebra">Section&nbsp;18.5</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-query" title="SPARQL 1.1 Query Language">SPARQL11-QUERY</a></cite>] does for the standard SPARQL algebra symbols). These operators have the same name as the algebra symbols and shall be used in the following section to extend the evaluation semantics of algebra expressions that may contain the two new algebra symbols.
      </p>

      <p>
        The operator for evaluating <code>Unfold1</code> is defined as follows.
      </p>

      <div class="defn">
        <p><b>Definition: <dfn id="dfn-Unfold1" style="font-style:normal" tabindex="0" aria-haspopup="dialog" data-dfn-type="dfn">Unfold1</dfn></b></p>
        <p>
          Let <var>μ</var> be a <a href="https://www.w3.org/TR/sparql11-query/#defn_sparqlSolutionMapping">solution mapping</a>, <var>var</var> be a <a href="https://www.w3.org/TR/sparql11-query/#defn_QueryVariable">variable</a>, and <var>expr</var> be an <a href="https://www.w3.org/TR/sparql11-query/#expressions">expression</a>.
          <br>
          Then, Unfold1(<var>μ</var>, <var>var</var>, <var>expr</var>) is a multiset of solution mappings that is defined as follows:
        </p>
        <ul>
          <li>
            If <var>var</var>&nbsp;∉&nbsp;dom(<var>μ</var>) and <var>expr</var>(<var>μ</var>) is a <a href="#dfn-well-formed-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-list-literal-18">well-formed cdt:List literal</a>, then
            <ul>
              <li>
                Unfold1(<var>μ</var>, <var>var</var>, <var>expr</var>) = { <var>μ</var> | <var>L</var> contains <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-43">null</a> } ∪ <var>Ω'</var>, where
                <br>&nbsp; &nbsp; <var>L</var> is the <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-28">term list</a> represented by the cdt:List literal <var>expr</var>(<var>μ</var>) and
                <br>&nbsp; &nbsp; <var>Ω'</var> = { <var>μ</var> ∪ (<var>var</var>, <var>term</var>) | <var>term</var> is an RDF term in <var>L</var> },
              </li>
              <li>
                card[Unfold1(<var>μ</var>, <var>var</var>, <var>expr</var>)](<var>μ'</var>) = 0 for every <var>μ'</var>&nbsp;≠&nbsp;<var>μ</var> and <var>μ'</var>&nbsp;∉&nbsp;<var>Ω'</var>,
              </li>
              <li>
                card[Unfold1(<var>μ</var>, <var>var</var>, <var>expr</var>)](<var>μ'</var>) is the number of <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-44">null</a> values in <var>L</var> if <var>μ'</var>&nbsp;=&nbsp;<var>μ</var>, and
              </li>
              <li>
                card[Unfold1(<var>μ</var>, <var>var</var>, <var>expr</var>)](<var>μ'</var>) is the number of times the RDF term <var>μ'</var>(<var>var</var>) is contained in <var>L</var> if <var>μ'</var>&nbsp;∈&nbsp;<var>Ω'</var>.
              </li>
            </ul>
          </li>
          <li>
            If <var>var</var>&nbsp;∉&nbsp;dom(<var>μ</var>) and <var>expr</var>(<var>μ</var>) is a <a href="#dfn-well-formed-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-map-literal-15">well-formed cdt:Map literal</a>, then
            <ul>
              <li>
                Unfold1(<var>μ</var>, <var>var</var>, <var>expr</var>) = { <var>μ</var> ∪ (<var>var</var>, <var>key</var>) | <var>key</var> is the <a href="#dfn-key-of-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-key-of-map-entry-2">key</a> of a <a href="#dfn-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-entry-21">map entry</a> in <var>M</var> }, where
                <br>&nbsp; &nbsp; <var>M</var> is the <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-26">term map</a> represented by the cdt:Map literal <var>expr</var>(<var>μ</var>),
              </li>
              <li>
                card[Unfold1(<var>μ</var>, <var>var</var>, <var>expr</var>)](<var>μ'</var>) = 1 for every <var>μ'</var>&nbsp;∈&nbsp;Unfold1(<var>μ</var>, <var>var</var>, <var>expr</var>), and
              </li>
              <li>
                card[Unfold1(<var>μ</var>, <var>var</var>, <var>expr</var>)](<var>μ'</var>) = 0 for every <var>μ'</var>&nbsp;∉&nbsp;Unfold1(<var>μ</var>, <var>var</var>, <var>expr</var>).
              </li>
            </ul>
          </li>
          <li>
            If <var>var</var> ∉ dom(<var>μ</var>) and <var>expr</var>(<var>μ</var>) is an error or an RDF term that is neither a well-formed cdt:List literal nor a well-formed cdt:Map literal, then
            <ul>
              <li>
                Unfold1(<var>μ</var>, <var>var</var>, <var>expr</var>) = {<var>μ</var>},
              </li>
              <li>
                card[Unfold1(<var>μ</var>, <var>var</var>, <var>expr</var>)](<var>μ'</var>) = 1 if <var>μ'</var>&nbsp;=&nbsp;<var>μ</var>, and
              </li>
              <li>
                card[Unfold1(<var>μ</var>, <var>var</var>, <var>expr</var>)](<var>μ'</var>) = 0 for every <var>μ'</var>&nbsp;≠&nbsp;<var>μ</var>.
              </li>
            </ul>
          </li>
          <li>
            If <var>var</var> ∈ dom(<var>μ</var>), then Unfold1(<var>μ</var>, <var>var</var>, <var>expr</var>) is undefined.
          </li>
        </ul>

        <p>
          Let <var>Ω</var> a multiset of solution mappings. We define:
          <br>
          Unfold1(<var>Ω</var>, <var>var</var>, <var>expr</var>) = ⋃<sub><var>μ</var> ∈ <var>Ω</var></sub> Unfold1(<var>μ</var>, <var>var</var>, <var>expr</var>)
        </p>
      </div>

      <div class="note" role="note" id="issue-container-generatedID-26"><div role="heading" class="note-title marker" id="h-note-26" aria-level="4"><span>Note</span></div><p class="">
        By the given definition , for cases in which <var>var</var>&nbsp;∉&nbsp;dom(<var>μ</var>) and <var>expr</var>(<var>μ</var>) is a well-formed cdt:List literal that represents the <a href="#dfn-empty-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-list-15">empty term list</a>, <a href="#dfn-Unfold1" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-Unfold1-1">Unfold1</a>(<var>μ</var>, <var>var</var>, <var>expr</var>) is the empty multiset of solution mappings. Similarly, if <var>var</var>&nbsp;∉&nbsp;dom(<var>μ</var>) and <var>expr</var>(<var>μ</var>) is a well-formed cdt:Map literal that represents the <a href="#dfn-empty-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-map-14">empty term map</a>, then <a href="#dfn-Unfold1" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-Unfold1-2">Unfold1</a>(<var>μ</var>, <var>var</var>, <var>expr</var>) is also the empty multiset.
      </p></div>

      <p>
        The operator for evaluating <code>Unfold2</code> is defined as follows.
      </p>

      <div class="defn">
        <p><b>Definition: <dfn id="dfn-Unfold2" style="font-style:normal" tabindex="0" aria-haspopup="dialog" data-dfn-type="dfn">Unfold2</dfn></b></p>

          Let <var>μ</var> be a <a href="https://www.w3.org/TR/sparql11-query/#defn_sparqlSolutionMapping">solution mapping</a>, <var>var<sub>1</sub></var> and <var>var<sub>2</sub></var> be two different <a href="https://www.w3.org/TR/sparql11-query/#defn_QueryVariable">variables</a>, and <var>expr</var> be an <a href="https://www.w3.org/TR/sparql11-query/#expressions">expression</a>.
          <br>
          Then, Unfold2(<var>μ</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, <var>expr</var>) is a multiset of solution mappings that is defined as follows:
        <p></p>
        <ul>
          <li>
            If <var>var<sub>1</sub></var>&nbsp;∉&nbsp;dom(<var>μ</var>), <var>var<sub>2</sub></var>&nbsp;∉&nbsp;dom(<var>μ</var>), and <var>expr</var>(<var>μ</var>) is a <a href="#dfn-well-formed-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-list-literal-19">well-formed cdt:List literal</a> such that the <a href="#dfn-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-list-29">term list</a>&nbsp;<var>L</var> represented by this literals is a nonempty, then
            <ul>
              <li>
                Unfold2(<var>μ</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, <var>expr</var>) = { <var>μ</var> ∪ <var>μ<sub><var>i</var></sub></var> ∪ (<var>var<sub>2</sub></var>, <var>i</var>) | 1 ≤ <var>i</var> ≤ <var>n</var> }, where
                <br>&nbsp; &nbsp; <var>μ<sub><var>i</var></sub></var> is the empty solution mapping if the element at the <var>i</var>-th position of <var>L</var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-45">null</a>,
                <br>&nbsp; &nbsp; otherwise, <var>μ<sub><var>i</var></sub></var> = (<var>var<sub>1</sub></var>, <var>term</var>) where <var>term</var> is element at the <var>i</var>-th position of <var>L</var>, and
                <br>&nbsp; &nbsp; <var>n</var> is the number of elements in <var>L</var>,
              </li>
              <li>
                card[Unfold1(<var>μ</var>, <var>var</var>, <var>expr</var>)](<var>μ'</var>) = 1 for every <var>μ'</var>&nbsp;∈&nbsp;Unfold2(<var>μ</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, <var>expr</var>), and
              </li>
              <li>
                card[Unfold1(<var>μ</var>, <var>var</var>, <var>expr</var>)](<var>μ'</var>) = 0 for every <var>μ'</var>&nbsp;∉&nbsp;Unfold2(<var>μ</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, <var>expr</var>).
              </li>
            </ul>
          </li>
          <li>
            If <var>var<sub>1</sub></var>&nbsp;∉&nbsp;dom(<var>μ</var>), <var>var<sub>2</sub></var>&nbsp;∉&nbsp;dom(<var>μ</var>), and <var>expr</var>(<var>μ</var>) is a <a href="#dfn-well-formed-cdt-list-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-list-literal-20">well-formed cdt:List literal</a> that represents the <a href="#dfn-empty-term-list" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-list-16">empty term list</a>, then Unfold2(<var>μ</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, <var>expr</var>) is the empty multiset.
          </li>
          <li>
            If <var>var<sub>1</sub></var>&nbsp;∉&nbsp;dom(<var>μ</var>), <var>var<sub>2</sub></var>&nbsp;∉&nbsp;dom(<var>μ</var>), and <var>expr</var>(<var>μ</var>) is a <a href="#dfn-well-formed-cdt-map-literal" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-well-formed-cdt-map-literal-16">well-formed cdt:Map literal</a>, then
            <ul>
              <li>
                Unfold2(<var>μ</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, <var>expr</var>) = { <var>μ</var> ∪ (<var>var<sub>1</sub></var>, <var>k</var>) ∪ <var>μ<sub><var>v</var></sub></var> | (<var>k</var>,<var>v</var>) is a <a href="#dfn-map-entry" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-map-entry-22">map entry</a> in <var>M</var> }, where
                <br>&nbsp; &nbsp; <var>μ<sub><var>v</var></sub></var> is the empty solution mapping if <var>v</var> is <a href="#dfn-null" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-null-46">null</a>, otherwise, <var>μ<sub><var>v</var></sub></var> = (<var>var<sub>2</sub></var>, <var>v</var>), and
                <br>&nbsp; &nbsp; <var>M</var> is the <a href="#dfn-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-term-map-27">term map</a> represented by the cdt:Map literal <var>expr</var>(<var>μ</var>),
              </li>
              <li>
                card[Unfold2(<var>μ</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, <var>expr</var>)](<var>μ'</var>) = 1 for every <var>μ'</var>&nbsp;∈&nbsp;Unfold2(<var>μ</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, <var>expr</var>),
              </li>
              <li>
                card[Unfold2(<var>μ</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, <var>expr</var>)](<var>μ'</var>) = 0 for every <var>μ'</var>&nbsp;∉&nbsp;Unfold2(<var>μ</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, <var>expr</var>).
              </li>
            </ul>
          </li>
          <li>
            If <var>var<sub>1</sub></var>&nbsp;∉&nbsp;dom(<var>μ</var>), <var>var<sub>2</sub></var>&nbsp;∉&nbsp;dom(<var>μ</var>), and <var>expr</var>(<var>μ</var>) is an error or an RDF term that is neither a well-formed cdt:List literal nor a well-formed cdt:Map literal, then
            <ul>
              <li>
                Unfold2(<var>μ</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, <var>expr</var>) = {<var>μ</var>},
              </li>
              <li>
                card[Unfold2(<var>μ</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, <var>expr</var>)](<var>μ'</var>) = 1 if <var>μ'</var>&nbsp;=&nbsp;<var>μ</var>, and
              </li>
              <li>
                card[Unfold2(<var>μ</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, <var>expr</var>)](<var>μ'</var>) = 0 for every <var>μ'</var>&nbsp;≠&nbsp;<var>μ</var>.
              </li>
            </ul>
          </li>
          <li>
            If <var>var<sub>1</sub></var>&nbsp;∈&nbsp;dom(<var>μ</var>) or <var>var<sub>2</sub></var>&nbsp;∈&nbsp;dom(<var>μ</var>), then Unfold2(<var>μ</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, <var>expr</var>) is undefined.
          </li>
        </ul>

        <p>
          Let <var>Ω</var> a multiset of solution mappings. We define:
          <br>
          Unfold2(<var>Ω</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, <var>expr</var>) = ⋃<sub><var>μ</var> ∈ <var>Ω</var></sub> Unfold2(<var>μ</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, <var>expr</var>)
        </p>
      </div>

      <div class="note" role="note" id="issue-container-generatedID-27"><div role="heading" class="note-title marker" id="h-note-27" aria-level="4"><span>Note</span></div><p class="">
        While the given definition captures the case of cdt:List literals with the empty term list explicitly (see the second main bullet point in the definition), the case of cdt:Map literals with the <a href="#dfn-empty-term-map" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-empty-term-map-15">empty term map</a> are captured implicitly as part of the third main bullet point. In this case, the result of <a href="#dfn-Unfold2" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-Unfold2-1">Unfold2</a>(<var>μ</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, <var>expr</var>) is also the empty multiset of solution mappings.
      </p></div>

    </section>

    <section id="unfold-semantics"><div class="header-wrapper"><h3 id="x11-4-evaluation-semantics"><bdi class="secno">11.4 </bdi>Evaluation Semantics</h3><a class="self-link" href="#unfold-semantics" aria-label="Permalink for Section 11.4"></a></div>
      

      <p>
        The SPARQL specification defines a function <q>eval(D(G), algebra expression) as the evaluation of an algebra expression with respect to a dataset D having active graph G</q> (see <a href="https://www.w3.org/TR/sparql11-query/#sparqlAlgebraEval">Section&nbsp;18.6</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql11-query" title="SPARQL 1.1 Query Language">SPARQL11-QUERY</a></cite>]). The definition of this function is recursive. To cover algebra expressions that may contain the two new algebra symbols (<code>Unfold1</code> and <code>Unfold2</code>) the definition of this function needs to be extended with the following two additional cases.
      </p>

      <div class="defn">
        <p><b>Definition: <dfn id="dfn-evalUnfold" style="font-style:normal" tabindex="0" aria-haspopup="dialog" class="respec-offending-element" title="Found definition for &quot;Evaluation of Unfold1&quot;, but nothing links to it. This is usually a spec bug!" data-dfn-type="dfn">Evaluation of Unfold1</dfn></b></p>
        <p>
          eval(D(G), <code>Unfold1(</code><var style="font-style: normal"><code>P</code></var>, <var style="font-style: normal"><code>var</code></var>, <var style="font-style: normal"><code>expr</code></var><code>)</code>) = <a href="#dfn-Unfold1" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-Unfold1-3">Unfold1</a>(eval(D(G), <var style="font-style: normal"><code>P</code></var>), <var style="font-style: normal"><code>var</code></var>, <var style="font-style: normal"><code>expr</code></var>)
        </p>
      </div>

      <div class="defn">
        <p><b>Definition: <dfn id="dfn-evalUnfold2" style="font-style:normal" tabindex="0" aria-haspopup="dialog" class="respec-offending-element" title="Found definition for &quot;Evaluation of Unfold2&quot;, but nothing links to it. This is usually a spec bug!" data-dfn-type="dfn">Evaluation of Unfold2</dfn></b></p>
        <p>
          eval(D(G), <code>Unfold2(</code><var style="font-style: normal"><code>P</code></var>, <var style="font-style: normal"><code>var1</code></var>, <var style="font-style: normal"><code>var2</code></var>, <var style="font-style: normal"><code>expr</code></var><code>)</code>) = <a href="#dfn-Unfold2" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-Unfold2-2">Unfold2</a>(eval(D(G), <var style="font-style: normal"><code>P</code></var>), <var style="font-style: normal"><code>var1</code></var>, <var style="font-style: normal"><code>var2</code></var>, <var style="font-style: normal"><code>expr</code></var>)
        </p>
      </div>

    </section>

  </section>


  <section class="appendix informative" id="iana-considerations"><div class="header-wrapper"><h2 id="a-iana-considerations"><bdi class="secno">A. </bdi>IANA Considerations</h2><a class="self-link" href="#iana-considerations" aria-label="Permalink for Appendix A."></a></div><p><em>This section is non-normative.</em></p>
    

    <p>TODO</p>

  </section>


  <section class="appendix" id="complete-ebnf-grammars"><div class="header-wrapper"><h2 id="b-complete-ebnf-grammars"><bdi class="secno">B. </bdi>Complete <abbr title="Extended Backus-Naur Form">EBNF</abbr> Grammars</h2><a class="self-link" href="#complete-ebnf-grammars" aria-label="Permalink for Appendix B."></a></div>
    

    <section class="appendix informative" id="cdt-ebnf"><div class="header-wrapper"><h3 id="b-1-composite-datatypes-ebnf-grammar"><bdi class="secno">B.1 </bdi>Composite Datatypes <abbr title="Extended Backus-Naur Form">EBNF</abbr> Grammar</h3><a class="self-link" href="#cdt-ebnf" aria-label="Permalink for Appendix B.1"></a></div><p><em>This section is non-normative.</em></p>
      
      <p>
        The following is a complete grammar for composite datatype literals (i.e., literals that conform either to the <a href="#dfn-cdt-list-datatype" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-list-datatype-12">cdt:List datatype</a> or to the <a href="#dfn-cdt-map-datatype" class="internalDFN" data-link-type="dfn" id="ref-for-dfn-cdt-map-datatype-13">cdt:Map datatype</a>). The <abbr title="Extended Backus-Naur Form">EBNF</abbr> used here is defined in XML 1.0 [<cite><a class="bibref" data-link-type="biblio" href="#bib-ebnf-notation" title="EBNF NOTATION">EBNF-NOTATION</a></cite>].
      </p>
      <div data-include="../ebnf/cdt-literals.html" data-include-id="include-9281008828065852" class="respec-offending-element" title="`data-include` failed: `../ebnf/cdt-literals.html` (NetworkError when attempting to fetch resource.)." id="respec-offender-data-include-failed-ebnf-cdt-literals-html-networkerror-when-attempting-to-fetch-resource"></div>
    </section>

    <section class="appendix informative" id="sparql-cdt-ebnf"><div class="header-wrapper"><h3 id="b-2-sparql-cdt-ebnf-grammar"><bdi class="secno">B.2 </bdi>SPARQL-CDT <abbr title="Extended Backus-Naur Form">EBNF</abbr> Grammar</h3><a class="self-link" href="#sparql-cdt-ebnf" aria-label="Permalink for Appendix B.2"></a></div><p><em>This section is non-normative.</em></p>
      
      <p>
        The following is a complete grammar for the SPARQL language with the extensions for composite datatype literals as defined in this document. The <abbr title="Extended Backus-Naur Form">EBNF</abbr> used here is defined in XML 1.0 [<cite><a class="bibref" data-link-type="biblio" href="#bib-ebnf-notation" title="EBNF NOTATION">EBNF-NOTATION</a></cite>].
      </p>
      <div data-include="../ebnf/sparql-cdt.html" data-include-id="include-8594651025073811" class="respec-offending-element" title="`data-include` failed: `../ebnf/sparql-cdt.html` (NetworkError when attempting to fetch resource.)." id="respec-offender-data-include-failed-ebnf-sparql-cdt-html-networkerror-when-attempting-to-fetch-resource"></div>
    </section>

  </section>


    




<section id="references" class="appendix"><div class="header-wrapper"><h2 id="c-references"><bdi class="secno">C. </bdi>References</h2><a class="self-link" href="#references" aria-label="Permalink for Appendix C."></a></div><section id="normative-references"><div class="header-wrapper"><h3 id="c-1-normative-references"><bdi class="secno">C.1 </bdi>Normative references</h3><a class="self-link" href="#normative-references" aria-label="Permalink for Appendix C.1"></a></div>
    
    <dl class="bibliography"><dt id="bib-ebnf-notation">[EBNF-NOTATION]</dt><dd>
      <a href="http://www.w3.org/TR/REC-xml/#sec-notation"><cite>EBNF NOTATION</cite></a>. Tim Bray; Jean Paoli; C. M. Sperberg-McQueen; Eve Maler; François Yergeau.  W3C. 26 November 2008. W3C Recommendation. URL: <a href="http://www.w3.org/TR/REC-xml/#sec-notation">http://www.w3.org/TR/REC-xml/#sec-notation</a>
    </dd><dt id="bib-rdf11-concepts">[RDF11-CONCEPTS]</dt><dd>
      <a href="https://www.w3.org/TR/rdf11-concepts/"><cite>RDF 1.1 Concepts and Abstract Syntax</cite></a>. Richard Cyganiak; David Wood; Markus Lanthaler.  W3C. 25 February 2014. W3C Recommendation. URL: <a href="https://www.w3.org/TR/rdf11-concepts/">https://www.w3.org/TR/rdf11-concepts/</a>
    </dd><dt id="bib-rfc2119">[RFC2119]</dt><dd>
      <a href="https://www.rfc-editor.org/rfc/rfc2119"><cite>Key words for use in RFCs to Indicate Requirement Levels</cite></a>. S. Bradner.  IETF. March 1997. Best Current Practice. URL: <a href="https://www.rfc-editor.org/rfc/rfc2119">https://www.rfc-editor.org/rfc/rfc2119</a>
    </dd><dt id="bib-rfc3987">[RFC3987]</dt><dd>
      <a href="https://www.rfc-editor.org/rfc/rfc3987"><cite>Internationalized Resource Identifiers (IRIs)</cite></a>. M. Duerst; M. Suignard.  IETF. January 2005. Proposed Standard. URL: <a href="https://www.rfc-editor.org/rfc/rfc3987">https://www.rfc-editor.org/rfc/rfc3987</a>
    </dd><dt id="bib-rfc8174">[RFC8174]</dt><dd>
      <a href="https://www.rfc-editor.org/rfc/rfc8174"><cite>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</cite></a>. B. Leiba.  IETF. May 2017. Best Current Practice. URL: <a href="https://www.rfc-editor.org/rfc/rfc8174">https://www.rfc-editor.org/rfc/rfc8174</a>
    </dd><dt id="bib-sparql11-query">[SPARQL11-QUERY]</dt><dd>
      <a href="https://www.w3.org/TR/sparql11-query/"><cite>SPARQL 1.1 Query Language</cite></a>. Steven Harris; Andy Seaborne.  W3C. 21 March 2013. W3C Recommendation. URL: <a href="https://www.w3.org/TR/sparql11-query/">https://www.w3.org/TR/sparql11-query/</a>
    </dd><dt id="bib-turtle">[TURTLE]</dt><dd>
      <a href="https://www.w3.org/TR/turtle/"><cite>RDF 1.1 Turtle</cite></a>. Eric Prud'hommeaux; Gavin Carothers.  W3C. 25 February 2014. W3C Recommendation. URL: <a href="https://www.w3.org/TR/turtle/">https://www.w3.org/TR/turtle/</a>
    </dd><dt id="bib-xml">[XML]</dt><dd>
      <a href="https://www.w3.org/TR/xml/"><cite>Extensible Markup Language (XML) 1.0 (Fifth Edition)</cite></a>. Tim Bray; Jean Paoli; Michael Sperberg-McQueen; Eve Maler; François Yergeau et al.  W3C. 26 November 2008. W3C Recommendation. URL: <a href="https://www.w3.org/TR/xml/">https://www.w3.org/TR/xml/</a>
    </dd></dl>
  </section><section id="informative-references"><div class="header-wrapper"><h3 id="c-2-informative-references"><bdi class="secno">C.2 </bdi>Informative references</h3><a class="self-link" href="#informative-references" aria-label="Permalink for Appendix C.2"></a></div>
    
    <dl class="bibliography"><dt id="bib-rdf11-primer">[RDF11-PRIMER]</dt><dd>
      <a href="https://www.w3.org/TR/rdf11-primer/"><cite>RDF 1.1 Primer</cite></a>. Guus Schreiber; Yves Raimond.  W3C. 24 June 2014. W3C Working Group Note. URL: <a href="https://www.w3.org/TR/rdf11-primer/">https://www.w3.org/TR/rdf11-primer/</a>
    </dd><dt id="bib-rdf11-schema">[RDF11-SCHEMA]</dt><dd>
      <a href="https://www.w3.org/TR/rdf-schema/"><cite>RDF Schema 1.1</cite></a>. Dan Brickley; Ramanathan Guha.  W3C. 25 February 2014. W3C Recommendation. URL: <a href="https://www.w3.org/TR/rdf-schema/">https://www.w3.org/TR/rdf-schema/</a>
    </dd><dt id="bib-rfc8259">[RFC8259]</dt><dd>
      <a href="https://www.rfc-editor.org/rfc/rfc8259"><cite>The JavaScript Object Notation (JSON) Data Interchange Format</cite></a>. T. Bray, Ed..  IETF. December 2017. Internet Standard. URL: <a href="https://www.rfc-editor.org/rfc/rfc8259">https://www.rfc-editor.org/rfc/rfc8259</a>
    </dd><dt id="bib-sparql11-overview">[SPARQL11-OVERVIEW]</dt><dd>
      <a href="https://www.w3.org/TR/sparql11-overview/"><cite>SPARQL 1.1 Overview</cite></a>. The W3C SPARQL Working Group.  W3C. 21 March 2013. W3C Recommendation. URL: <a href="https://www.w3.org/TR/sparql11-overview/">https://www.w3.org/TR/sparql11-overview/</a>
    </dd><dt id="bib-xpath-functions">[XPATH-FUNCTIONS]</dt><dd>
      <a href="https://www.w3.org/TR/xpath-functions/"><cite>XQuery 1.0 and XPath 2.0 Functions and Operators (Second Edition)</cite></a>. Ashok Malhotra; Jim Melton; Norman Walsh; Michael Kay.  W3C. 14 December 2010. W3C Recommendation. URL: <a href="https://www.w3.org/TR/xpath-functions/">https://www.w3.org/TR/xpath-functions/</a>
    </dd></dl>
  </section></section><p role="navigation" id="back-to-top">
    <a href="#title"><abbr title="Back to Top">↑</abbr></a>
  </p><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-dfn-cdt-list-datatype" aria-label="Links in this document to definition: cdt:List datatype">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#dfn-cdt-list-datatype" aria-label="Permalink for definition: cdt:List datatype. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
      <a href="#ref-for-dfn-cdt-list-datatype-1" title="§ 3. The cdt:List Datatype">§ 3. The cdt:List Datatype</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-datatype-2" title="§ 3.1 Value Space">§ 3.1 Value Space</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-datatype-3" title="§ 3.2 Lexical Space">§ 3.2 Lexical Space</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-datatype-4" title="§ 3.3 Lexical-To-Value Mapping">§ 3.3 Lexical-To-Value Mapping</a> <a href="#ref-for-dfn-cdt-list-datatype-5" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-datatype-6" title="§ 5.1 list-equal">§ 5.1 list-equal</a> <a href="#ref-for-dfn-cdt-list-datatype-7" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-datatype-8" title="§ 5.3 list-less-than">§ 5.3 list-less-than</a> <a href="#ref-for-dfn-cdt-list-datatype-9" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-datatype-10" title="§ 9.1 Relative Order of cdt:List Literals">§ 9.1 Relative Order of cdt:List Literals</a> <a href="#ref-for-dfn-cdt-list-datatype-11" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-datatype-12" title="§ B.1 Composite Datatypes EBNF Grammar">§ B.1 Composite Datatypes EBNF Grammar</a> 
    </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-dfn-cdt-list-literal" aria-label="Links in this document to definition: cdt:List literal">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#dfn-cdt-list-literal" aria-label="Permalink for definition: cdt:List literal. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
      <a href="#ref-for-dfn-cdt-list-literal-1" title="§ 3. The cdt:List Datatype">§ 3. The cdt:List Datatype</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-literal-2" title="§ 3.2 Lexical Space">§ 3.2 Lexical Space</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-literal-3" title="§ 3.3 Lexical-To-Value Mapping">§ 3.3 Lexical-To-Value Mapping</a> <a href="#ref-for-dfn-cdt-list-literal-4" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-literal-5" title="§ 3.4 Relationship to RDF Collections">§ 3.4 Relationship to RDF Collections</a> <a href="#ref-for-dfn-cdt-list-literal-6" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-literal-7" title="§ 4.4 Relationship to JSON">§ 4.4 Relationship to JSON</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-literal-8" title="§ 5. Extensions of Existing SPARQL Operators">§ 5. Extensions of Existing SPARQL Operators</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-literal-9" title="§ 5.1 list-equal">§ 5.1 list-equal</a> <a href="#ref-for-dfn-cdt-list-literal-10" title="Reference 2">(2)</a> <a href="#ref-for-dfn-cdt-list-literal-11" title="Reference 3">(3)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-literal-12" title="§ 5.3 list-less-than">§ 5.3 list-less-than</a> <a href="#ref-for-dfn-cdt-list-literal-13" title="Reference 2">(2)</a> <a href="#ref-for-dfn-cdt-list-literal-14" title="Reference 3">(3)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-literal-15" title="§ 6. Functions on Lists and Maps">§ 6. Functions on Lists and Maps</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-literal-16" title="§ 6.1 cdt:get">§ 6.1 cdt:get</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-literal-17" title="§ 6.2 cdt:size">§ 6.2 cdt:size</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-literal-18" title="§ 7. Functions on Lists">§ 7. Functions on Lists</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-literal-19" title="§ 7.1 cdt:List">§ 7.1 cdt:List</a> <a href="#ref-for-dfn-cdt-list-literal-20" title="Reference 2">(2)</a> <a href="#ref-for-dfn-cdt-list-literal-21" title="Reference 3">(3)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-literal-22" title="§ 7.2 cdt:concat">§ 7.2 cdt:concat</a> <a href="#ref-for-dfn-cdt-list-literal-23" title="Reference 2">(2)</a> <a href="#ref-for-dfn-cdt-list-literal-24" title="Reference 3">(3)</a> <a href="#ref-for-dfn-cdt-list-literal-25" title="Reference 4">(4)</a> <a href="#ref-for-dfn-cdt-list-literal-26" title="Reference 5">(5)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-literal-27" title="§ 7.3 cdt:contains">§ 7.3 cdt:contains</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-literal-28" title="§ 7.4 cdt:head">§ 7.4 cdt:head</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-literal-29" title="§ 7.5 cdt:reverse">§ 7.5 cdt:reverse</a> <a href="#ref-for-dfn-cdt-list-literal-30" title="Reference 2">(2)</a> <a href="#ref-for-dfn-cdt-list-literal-31" title="Reference 3">(3)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-literal-32" title="§ 7.6 cdt:subseq">§ 7.6 cdt:subseq</a> <a href="#ref-for-dfn-cdt-list-literal-33" title="Reference 2">(2)</a> <a href="#ref-for-dfn-cdt-list-literal-34" title="Reference 3">(3)</a> <a href="#ref-for-dfn-cdt-list-literal-35" title="Reference 4">(4)</a> <a href="#ref-for-dfn-cdt-list-literal-36" title="Reference 5">(5)</a> <a href="#ref-for-dfn-cdt-list-literal-37" title="Reference 6">(6)</a> <a href="#ref-for-dfn-cdt-list-literal-38" title="Reference 7">(7)</a> <a href="#ref-for-dfn-cdt-list-literal-39" title="Reference 8">(8)</a> <a href="#ref-for-dfn-cdt-list-literal-40" title="Reference 9">(9)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-literal-41" title="§ 7.7 cdt:tail">§ 7.7 cdt:tail</a> <a href="#ref-for-dfn-cdt-list-literal-42" title="Reference 2">(2)</a> <a href="#ref-for-dfn-cdt-list-literal-43" title="Reference 3">(3)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-literal-44" title="§ 8.3 cdt:keys">§ 8.3 cdt:keys</a> <a href="#ref-for-dfn-cdt-list-literal-45" title="Reference 2">(2)</a> <a href="#ref-for-dfn-cdt-list-literal-46" title="Reference 3">(3)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-literal-47" title="§ 9. Extension of ORDER BY">§ 9. Extension of ORDER BY</a> <a href="#ref-for-dfn-cdt-list-literal-48" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-literal-49" title="§ 9.1 Relative Order of cdt:List Literals">§ 9.1 Relative Order of cdt:List Literals</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-literal-50" title="§ 10. FOLD">§ 10. FOLD</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-literal-51" title="§ 10.3.1.1 Fold1">§ 10.3.1.1 Fold1</a> <a href="#ref-for-dfn-cdt-list-literal-52" title="Reference 2">(2)</a> <a href="#ref-for-dfn-cdt-list-literal-53" title="Reference 3">(3)</a> <a href="#ref-for-dfn-cdt-list-literal-54" title="Reference 4">(4)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-list-literal-55" title="§ 11. UNFOLD">§ 11. UNFOLD</a> <a href="#ref-for-dfn-cdt-list-literal-56" title="Reference 2">(2)</a> 
    </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-dfn-well-formed-cdt-list-literal" aria-label="Links in this document to definition: well-formed cdt:List literal">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#dfn-well-formed-cdt-list-literal" aria-label="Permalink for definition: well-formed cdt:List literal. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
      <a href="#ref-for-dfn-well-formed-cdt-list-literal-1" title="§ 3.3 Lexical-To-Value Mapping">§ 3.3 Lexical-To-Value Mapping</a> 
    </li><li>
      <a href="#ref-for-dfn-well-formed-cdt-list-literal-2" title="§ 5.1 list-equal">§ 5.1 list-equal</a> 
    </li><li>
      <a href="#ref-for-dfn-well-formed-cdt-list-literal-3" title="§ 5.3 list-less-than">§ 5.3 list-less-than</a> 
    </li><li>
      <a href="#ref-for-dfn-well-formed-cdt-list-literal-4" title="§ 6.1 cdt:get">§ 6.1 cdt:get</a> 
    </li><li>
      <a href="#ref-for-dfn-well-formed-cdt-list-literal-5" title="§ 6.2 cdt:size">§ 6.2 cdt:size</a> <a href="#ref-for-dfn-well-formed-cdt-list-literal-6" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-well-formed-cdt-list-literal-7" title="§ 7.2 cdt:concat">§ 7.2 cdt:concat</a> <a href="#ref-for-dfn-well-formed-cdt-list-literal-8" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-well-formed-cdt-list-literal-9" title="§ 7.3 cdt:contains">§ 7.3 cdt:contains</a> <a href="#ref-for-dfn-well-formed-cdt-list-literal-10" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-well-formed-cdt-list-literal-11" title="§ 7.4 cdt:head">§ 7.4 cdt:head</a> 
    </li><li>
      <a href="#ref-for-dfn-well-formed-cdt-list-literal-12" title="§ 7.5 cdt:reverse">§ 7.5 cdt:reverse</a> <a href="#ref-for-dfn-well-formed-cdt-list-literal-13" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-well-formed-cdt-list-literal-14" title="§ 7.6 cdt:subseq">§ 7.6 cdt:subseq</a> <a href="#ref-for-dfn-well-formed-cdt-list-literal-15" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-well-formed-cdt-list-literal-16" title="§ 7.7 cdt:tail">§ 7.7 cdt:tail</a> 
    </li><li>
      <a href="#ref-for-dfn-well-formed-cdt-list-literal-17" title="§ 9.1 Relative Order of cdt:List Literals">§ 9.1 Relative Order of cdt:List Literals</a> 
    </li><li>
      <a href="#ref-for-dfn-well-formed-cdt-list-literal-18" title="§ 11.3 Algebra">§ 11.3 Algebra</a> <a href="#ref-for-dfn-well-formed-cdt-list-literal-19" title="Reference 2">(2)</a> <a href="#ref-for-dfn-well-formed-cdt-list-literal-20" title="Reference 3">(3)</a> 
    </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-dfn-ill-formed-cdt-list-literal" aria-label="Links in this document to definition: ill-formed cdt:List literal">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#dfn-ill-formed-cdt-list-literal" aria-label="Permalink for definition: ill-formed cdt:List literal. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
      <a href="#ref-for-dfn-ill-formed-cdt-list-literal-1" title="§ 5.1 list-equal">§ 5.1 list-equal</a> 
    </li><li>
      <a href="#ref-for-dfn-ill-formed-cdt-list-literal-2" title="§ 5.3 list-less-than">§ 5.3 list-less-than</a> 
    </li><li>
      <a href="#ref-for-dfn-ill-formed-cdt-list-literal-3" title="§ 9.1 Relative Order of cdt:List Literals">§ 9.1 Relative Order of cdt:List Literals</a> 
    </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-dfn-list-element" aria-label="Links in this document to definition: list element">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#dfn-list-element" aria-label="Permalink for definition: list element. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
      <a href="#ref-for-dfn-list-element-1" title="§ 3.1 Value Space">§ 3.1 Value Space</a> <a href="#ref-for-dfn-list-element-2" title="Reference 2">(2)</a> <a href="#ref-for-dfn-list-element-3" title="Reference 3">(3)</a> 
    </li><li>
      <a href="#ref-for-dfn-list-element-4" title="§ 3.3 Lexical-To-Value Mapping">§ 3.3 Lexical-To-Value Mapping</a> <a href="#ref-for-dfn-list-element-5" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-list-element-6" title="§ 3.4 Relationship to RDF Collections">§ 3.4 Relationship to RDF Collections</a> <a href="#ref-for-dfn-list-element-7" title="Reference 2">(2)</a> 
    </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-dfn-term-list" aria-label="Links in this document to definition: term list">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#dfn-term-list" aria-label="Permalink for definition: term list. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
      <a href="#ref-for-dfn-term-list-1" title="§ 3.1 Value Space">§ 3.1 Value Space</a> 
    </li><li>
      <a href="#ref-for-dfn-term-list-2" title="§ 3.3 Lexical-To-Value Mapping">§ 3.3 Lexical-To-Value Mapping</a> <a href="#ref-for-dfn-term-list-3" title="Reference 2">(2)</a> <a href="#ref-for-dfn-term-list-4" title="Reference 3">(3)</a> <a href="#ref-for-dfn-term-list-5" title="Reference 4">(4)</a> 
    </li><li>
      <a href="#ref-for-dfn-term-list-6" title="§ 3.4 Relationship to RDF Collections">§ 3.4 Relationship to RDF Collections</a> <a href="#ref-for-dfn-term-list-7" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-term-list-8" title="§ 5.1 list-equal">§ 5.1 list-equal</a> <a href="#ref-for-dfn-term-list-9" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-term-list-10" title="§ 5.3 list-less-than">§ 5.3 list-less-than</a> <a href="#ref-for-dfn-term-list-11" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-term-list-12" title="§ 6.1 cdt:get">§ 6.1 cdt:get</a> 
    </li><li>
      <a href="#ref-for-dfn-term-list-13" title="§ 6.2 cdt:size">§ 6.2 cdt:size</a> 
    </li><li>
      <a href="#ref-for-dfn-term-list-14" title="§ 7.1 cdt:List">§ 7.1 cdt:List</a> 
    </li><li>
      <a href="#ref-for-dfn-term-list-15" title="§ 7.2 cdt:concat">§ 7.2 cdt:concat</a> 
    </li><li>
      <a href="#ref-for-dfn-term-list-16" title="§ 7.3 cdt:contains">§ 7.3 cdt:contains</a> 
    </li><li>
      <a href="#ref-for-dfn-term-list-17" title="§ 7.4 cdt:head">§ 7.4 cdt:head</a> 
    </li><li>
      <a href="#ref-for-dfn-term-list-18" title="§ 7.5 cdt:reverse">§ 7.5 cdt:reverse</a> 
    </li><li>
      <a href="#ref-for-dfn-term-list-19" title="§ 7.6 cdt:subseq">§ 7.6 cdt:subseq</a> 
    </li><li>
      <a href="#ref-for-dfn-term-list-20" title="§ 7.7 cdt:tail">§ 7.7 cdt:tail</a> <a href="#ref-for-dfn-term-list-21" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-term-list-22" title="§ 8.3 cdt:keys">§ 8.3 cdt:keys</a> 
    </li><li>
      <a href="#ref-for-dfn-term-list-23" title="§ 9.1 Relative Order of cdt:List Literals">§ 9.1 Relative Order of cdt:List Literals</a> <a href="#ref-for-dfn-term-list-24" title="Reference 2">(2)</a> <a href="#ref-for-dfn-term-list-25" title="Reference 3">(3)</a> 
    </li><li>
      <a href="#ref-for-dfn-term-list-26" title="§ 10.3.1.1 Fold1">§ 10.3.1.1 Fold1</a> 
    </li><li>
      <a href="#ref-for-dfn-term-list-27" title="§ 11. UNFOLD">§ 11. UNFOLD</a> 
    </li><li>
      <a href="#ref-for-dfn-term-list-28" title="§ 11.3 Algebra">§ 11.3 Algebra</a> <a href="#ref-for-dfn-term-list-29" title="Reference 2">(2)</a> 
    </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-dfn-empty-term-list" aria-label="Links in this document to definition: empty term list">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#dfn-empty-term-list" aria-label="Permalink for definition: empty term list. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
      <a href="#ref-for-dfn-empty-term-list-1" title="§ 3.3 Lexical-To-Value Mapping">§ 3.3 Lexical-To-Value Mapping</a> 
    </li><li>
      <a href="#ref-for-dfn-empty-term-list-2" title="§ 5.1 list-equal">§ 5.1 list-equal</a> 
    </li><li>
      <a href="#ref-for-dfn-empty-term-list-3" title="§ 5.3 list-less-than">§ 5.3 list-less-than</a> 
    </li><li>
      <a href="#ref-for-dfn-empty-term-list-4" title="§ 6.1 cdt:get">§ 6.1 cdt:get</a> 
    </li><li>
      <a href="#ref-for-dfn-empty-term-list-5" title="§ 7.1 cdt:List">§ 7.1 cdt:List</a> 
    </li><li>
      <a href="#ref-for-dfn-empty-term-list-6" title="§ 7.2 cdt:concat">§ 7.2 cdt:concat</a> 
    </li><li>
      <a href="#ref-for-dfn-empty-term-list-7" title="§ 7.4 cdt:head">§ 7.4 cdt:head</a> 
    </li><li>
      <a href="#ref-for-dfn-empty-term-list-8" title="§ 7.5 cdt:reverse">§ 7.5 cdt:reverse</a> 
    </li><li>
      <a href="#ref-for-dfn-empty-term-list-9" title="§ 7.6 cdt:subseq">§ 7.6 cdt:subseq</a> <a href="#ref-for-dfn-empty-term-list-10" title="Reference 2">(2)</a> <a href="#ref-for-dfn-empty-term-list-11" title="Reference 3">(3)</a> 
    </li><li>
      <a href="#ref-for-dfn-empty-term-list-12" title="§ 7.7 cdt:tail">§ 7.7 cdt:tail</a> 
    </li><li>
      <a href="#ref-for-dfn-empty-term-list-13" title="§ 8.3 cdt:keys">§ 8.3 cdt:keys</a> 
    </li><li>
      <a href="#ref-for-dfn-empty-term-list-14" title="§ 10.3.1.1 Fold1">§ 10.3.1.1 Fold1</a> 
    </li><li>
      <a href="#ref-for-dfn-empty-term-list-15" title="§ 11.3 Algebra">§ 11.3 Algebra</a> <a href="#ref-for-dfn-empty-term-list-16" title="Reference 2">(2)</a> 
    </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-dfn-null" aria-label="Links in this document to definition: null">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#dfn-null" aria-label="Permalink for definition: null. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
      <a href="#ref-for-dfn-null-1" title="§ 3.1 Value Space">§ 3.1 Value Space</a> <a href="#ref-for-dfn-null-2" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-null-3" title="§ 3.3 Lexical-To-Value Mapping">§ 3.3 Lexical-To-Value Mapping</a> 
    </li><li>
      <a href="#ref-for-dfn-null-4" title="§ 3.4 Relationship to RDF Collections">§ 3.4 Relationship to RDF Collections</a> 
    </li><li>
      <a href="#ref-for-dfn-null-5" title="§ 4.1 Value Space">§ 4.1 Value Space</a> 
    </li><li>
      <a href="#ref-for-dfn-null-6" title="§ 4.3 Lexical-To-Value Mapping">§ 4.3 Lexical-To-Value Mapping</a> 
    </li><li>
      <a href="#ref-for-dfn-null-7" title="§ 4.4 Relationship to JSON">§ 4.4 Relationship to JSON</a> 
    </li><li>
      <a href="#ref-for-dfn-null-8" title="§ 5.1 list-equal">§ 5.1 list-equal</a> <a href="#ref-for-dfn-null-9" title="Reference 2">(2)</a> <a href="#ref-for-dfn-null-10" title="Reference 3">(3)</a> <a href="#ref-for-dfn-null-11" title="Reference 4">(4)</a> <a href="#ref-for-dfn-null-12" title="Reference 5">(5)</a> <a href="#ref-for-dfn-null-13" title="Reference 6">(6)</a> 
    </li><li>
      <a href="#ref-for-dfn-null-14" title="§ 5.2 map-equal">§ 5.2 map-equal</a> <a href="#ref-for-dfn-null-15" title="Reference 2">(2)</a> <a href="#ref-for-dfn-null-16" title="Reference 3">(3)</a> <a href="#ref-for-dfn-null-17" title="Reference 4">(4)</a> <a href="#ref-for-dfn-null-18" title="Reference 5">(5)</a> 
    </li><li>
      <a href="#ref-for-dfn-null-19" title="§ 5.3 list-less-than">§ 5.3 list-less-than</a> <a href="#ref-for-dfn-null-20" title="Reference 2">(2)</a> <a href="#ref-for-dfn-null-21" title="Reference 3">(3)</a> <a href="#ref-for-dfn-null-22" title="Reference 4">(4)</a> 
    </li><li>
      <a href="#ref-for-dfn-null-23" title="§ 5.4 map-less-than">§ 5.4 map-less-than</a> <a href="#ref-for-dfn-null-24" title="Reference 2">(2)</a> <a href="#ref-for-dfn-null-25" title="Reference 3">(3)</a> <a href="#ref-for-dfn-null-26" title="Reference 4">(4)</a> 
    </li><li>
      <a href="#ref-for-dfn-null-27" title="§ 6.1 cdt:get">§ 6.1 cdt:get</a> <a href="#ref-for-dfn-null-28" title="Reference 2">(2)</a> <a href="#ref-for-dfn-null-29" title="Reference 3">(3)</a> <a href="#ref-for-dfn-null-30" title="Reference 4">(4)</a> 
    </li><li>
      <a href="#ref-for-dfn-null-31" title="§ 7.1 cdt:List">§ 7.1 cdt:List</a> 
    </li><li>
      <a href="#ref-for-dfn-null-32" title="§ 7.4 cdt:head">§ 7.4 cdt:head</a> <a href="#ref-for-dfn-null-33" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-null-34" title="§ 8.1 cdt:Map">§ 8.1 cdt:Map</a> 
    </li><li>
      <a href="#ref-for-dfn-null-35" title="§ 8.5 cdt:put">§ 8.5 cdt:put</a> <a href="#ref-for-dfn-null-36" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-null-37" title="§ 9.1 Relative Order of cdt:List Literals">§ 9.1 Relative Order of cdt:List Literals</a> <a href="#ref-for-dfn-null-38" title="Reference 2">(2)</a> <a href="#ref-for-dfn-null-39" title="Reference 3">(3)</a> 
    </li><li>
      <a href="#ref-for-dfn-null-40" title="§ 9.2 Relative Order of cdt:Map Literals">§ 9.2 Relative Order of cdt:Map Literals</a> 
    </li><li>
      <a href="#ref-for-dfn-null-41" title="§ 10.3.1.1 Fold1">§ 10.3.1.1 Fold1</a> 
    </li><li>
      <a href="#ref-for-dfn-null-42" title="§ 11. UNFOLD">§ 11. UNFOLD</a> 
    </li><li>
      <a href="#ref-for-dfn-null-43" title="§ 11.3 Algebra">§ 11.3 Algebra</a> <a href="#ref-for-dfn-null-44" title="Reference 2">(2)</a> <a href="#ref-for-dfn-null-45" title="Reference 3">(3)</a> <a href="#ref-for-dfn-null-46" title="Reference 4">(4)</a> 
    </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-dfn-cdt-map-datatype" aria-label="Links in this document to definition: cdt:Map datatype">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#dfn-cdt-map-datatype" aria-label="Permalink for definition: cdt:Map datatype. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
      <a href="#ref-for-dfn-cdt-map-datatype-1" title="§ 4. The cdt:Map Datatype">§ 4. The cdt:Map Datatype</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-datatype-2" title="§ 4.1 Value Space">§ 4.1 Value Space</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-datatype-3" title="§ 4.2 Lexical Space">§ 4.2 Lexical Space</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-datatype-4" title="§ 4.3 Lexical-To-Value Mapping">§ 4.3 Lexical-To-Value Mapping</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-datatype-5" title="§ 4.4 Relationship to JSON">§ 4.4 Relationship to JSON</a> <a href="#ref-for-dfn-cdt-map-datatype-6" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-datatype-7" title="§ 5.2 map-equal">§ 5.2 map-equal</a> <a href="#ref-for-dfn-cdt-map-datatype-8" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-datatype-9" title="§ 5.4 map-less-than">§ 5.4 map-less-than</a> <a href="#ref-for-dfn-cdt-map-datatype-10" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-datatype-11" title="§ 8.5 cdt:put">§ 8.5 cdt:put</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-datatype-12" title="§ 9.2 Relative Order of cdt:Map Literals">§ 9.2 Relative Order of cdt:Map Literals</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-datatype-13" title="§ B.1 Composite Datatypes EBNF Grammar">§ B.1 Composite Datatypes EBNF Grammar</a> 
    </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-dfn-cdt-map-literal" aria-label="Links in this document to definition: cdt:Map literal">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#dfn-cdt-map-literal" aria-label="Permalink for definition: cdt:Map literal. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
      <a href="#ref-for-dfn-cdt-map-literal-1" title="§ 3.2 Lexical Space">§ 3.2 Lexical Space</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-literal-2" title="§ 3.4 Relationship to RDF Collections">§ 3.4 Relationship to RDF Collections</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-literal-3" title="§ 4. The cdt:Map Datatype">§ 4. The cdt:Map Datatype</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-literal-4" title="§ 4.4 Relationship to JSON">§ 4.4 Relationship to JSON</a> <a href="#ref-for-dfn-cdt-map-literal-5" title="Reference 2">(2)</a> <a href="#ref-for-dfn-cdt-map-literal-6" title="Reference 3">(3)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-literal-7" title="§ 5. Extensions of Existing SPARQL Operators">§ 5. Extensions of Existing SPARQL Operators</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-literal-8" title="§ 5.2 map-equal">§ 5.2 map-equal</a> <a href="#ref-for-dfn-cdt-map-literal-9" title="Reference 2">(2)</a> <a href="#ref-for-dfn-cdt-map-literal-10" title="Reference 3">(3)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-literal-11" title="§ 5.4 map-less-than">§ 5.4 map-less-than</a> <a href="#ref-for-dfn-cdt-map-literal-12" title="Reference 2">(2)</a> <a href="#ref-for-dfn-cdt-map-literal-13" title="Reference 3">(3)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-literal-14" title="§ 6. Functions on Lists and Maps">§ 6. Functions on Lists and Maps</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-literal-15" title="§ 6.1 cdt:get">§ 6.1 cdt:get</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-literal-16" title="§ 6.2 cdt:size">§ 6.2 cdt:size</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-literal-17" title="§ 8. Functions on Maps">§ 8. Functions on Maps</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-literal-18" title="§ 8.1 cdt:Map">§ 8.1 cdt:Map</a> <a href="#ref-for-dfn-cdt-map-literal-19" title="Reference 2">(2)</a> <a href="#ref-for-dfn-cdt-map-literal-20" title="Reference 3">(3)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-literal-21" title="§ 8.2 cdt:containsKey">§ 8.2 cdt:containsKey</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-literal-22" title="§ 8.3 cdt:keys">§ 8.3 cdt:keys</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-literal-23" title="§ 8.4 cdt:merge">§ 8.4 cdt:merge</a> <a href="#ref-for-dfn-cdt-map-literal-24" title="Reference 2">(2)</a> <a href="#ref-for-dfn-cdt-map-literal-25" title="Reference 3">(3)</a> <a href="#ref-for-dfn-cdt-map-literal-26" title="Reference 4">(4)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-literal-27" title="§ 8.5 cdt:put">§ 8.5 cdt:put</a> <a href="#ref-for-dfn-cdt-map-literal-28" title="Reference 2">(2)</a> <a href="#ref-for-dfn-cdt-map-literal-29" title="Reference 3">(3)</a> <a href="#ref-for-dfn-cdt-map-literal-30" title="Reference 4">(4)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-literal-31" title="§ 8.6 cdt:remove">§ 8.6 cdt:remove</a> <a href="#ref-for-dfn-cdt-map-literal-32" title="Reference 2">(2)</a> <a href="#ref-for-dfn-cdt-map-literal-33" title="Reference 3">(3)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-literal-34" title="§ 9. Extension of ORDER BY">§ 9. Extension of ORDER BY</a> <a href="#ref-for-dfn-cdt-map-literal-35" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-literal-36" title="§ 9.2 Relative Order of cdt:Map Literals">§ 9.2 Relative Order of cdt:Map Literals</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-literal-37" title="§ 10. FOLD">§ 10. FOLD</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-literal-38" title="§ 10.3.1.2 Fold2">§ 10.3.1.2 Fold2</a> <a href="#ref-for-dfn-cdt-map-literal-39" title="Reference 2">(2)</a> <a href="#ref-for-dfn-cdt-map-literal-40" title="Reference 3">(3)</a> <a href="#ref-for-dfn-cdt-map-literal-41" title="Reference 4">(4)</a> 
    </li><li>
      <a href="#ref-for-dfn-cdt-map-literal-42" title="§ 11. UNFOLD">§ 11. UNFOLD</a> <a href="#ref-for-dfn-cdt-map-literal-43" title="Reference 2">(2)</a> 
    </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-dfn-well-formed-cdt-map-literal" aria-label="Links in this document to definition: well-formed cdt:Map literal">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#dfn-well-formed-cdt-map-literal" aria-label="Permalink for definition: well-formed cdt:Map literal. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
      <a href="#ref-for-dfn-well-formed-cdt-map-literal-1" title="§ 5.2 map-equal">§ 5.2 map-equal</a> 
    </li><li>
      <a href="#ref-for-dfn-well-formed-cdt-map-literal-2" title="§ 5.4 map-less-than">§ 5.4 map-less-than</a> 
    </li><li>
      <a href="#ref-for-dfn-well-formed-cdt-map-literal-3" title="§ 6.1 cdt:get">§ 6.1 cdt:get</a> 
    </li><li>
      <a href="#ref-for-dfn-well-formed-cdt-map-literal-4" title="§ 6.2 cdt:size">§ 6.2 cdt:size</a> <a href="#ref-for-dfn-well-formed-cdt-map-literal-5" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-well-formed-cdt-map-literal-6" title="§ 8.2 cdt:containsKey">§ 8.2 cdt:containsKey</a> <a href="#ref-for-dfn-well-formed-cdt-map-literal-7" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-well-formed-cdt-map-literal-8" title="§ 8.3 cdt:keys">§ 8.3 cdt:keys</a> 
    </li><li>
      <a href="#ref-for-dfn-well-formed-cdt-map-literal-9" title="§ 8.4 cdt:merge">§ 8.4 cdt:merge</a> <a href="#ref-for-dfn-well-formed-cdt-map-literal-10" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-well-formed-cdt-map-literal-11" title="§ 8.5 cdt:put">§ 8.5 cdt:put</a> 
    </li><li>
      <a href="#ref-for-dfn-well-formed-cdt-map-literal-12" title="§ 8.6 cdt:remove">§ 8.6 cdt:remove</a> <a href="#ref-for-dfn-well-formed-cdt-map-literal-13" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-well-formed-cdt-map-literal-14" title="§ 9.2 Relative Order of cdt:Map Literals">§ 9.2 Relative Order of cdt:Map Literals</a> 
    </li><li>
      <a href="#ref-for-dfn-well-formed-cdt-map-literal-15" title="§ 11.3 Algebra">§ 11.3 Algebra</a> <a href="#ref-for-dfn-well-formed-cdt-map-literal-16" title="Reference 2">(2)</a> 
    </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-dfn-ill-formed-cdt-map-literal" aria-label="Links in this document to definition: ill-formed cdt:Map literal">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#dfn-ill-formed-cdt-map-literal" aria-label="Permalink for definition: ill-formed cdt:Map literal. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
      <a href="#ref-for-dfn-ill-formed-cdt-map-literal-1" title="§ 5.2 map-equal">§ 5.2 map-equal</a> 
    </li><li>
      <a href="#ref-for-dfn-ill-formed-cdt-map-literal-2" title="§ 5.4 map-less-than">§ 5.4 map-less-than</a> 
    </li><li>
      <a href="#ref-for-dfn-ill-formed-cdt-map-literal-3" title="§ 8.3 cdt:keys">§ 8.3 cdt:keys</a> 
    </li><li>
      <a href="#ref-for-dfn-ill-formed-cdt-map-literal-4" title="§ 8.4 cdt:merge">§ 8.4 cdt:merge</a> <a href="#ref-for-dfn-ill-formed-cdt-map-literal-5" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-ill-formed-cdt-map-literal-6" title="§ 8.6 cdt:remove">§ 8.6 cdt:remove</a> 
    </li><li>
      <a href="#ref-for-dfn-ill-formed-cdt-map-literal-7" title="§ 9.2 Relative Order of cdt:Map Literals">§ 9.2 Relative Order of cdt:Map Literals</a> 
    </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-dfn-map-key" aria-label="Links in this document to definition: map key">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#dfn-map-key" aria-label="Permalink for definition: map key. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
      <a href="#ref-for-dfn-map-key-1" title="§ 4.1 Value Space">§ 4.1 Value Space</a> <a href="#ref-for-dfn-map-key-2" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-map-key-3" title="§ 4.4 Relationship to JSON">§ 4.4 Relationship to JSON</a> 
    </li><li>
      <a href="#ref-for-dfn-map-key-4" title="§ 5.4 map-less-than">§ 5.4 map-less-than</a> 
    </li><li>
      <a href="#ref-for-dfn-map-key-5" title="§ 8.1 cdt:Map">§ 8.1 cdt:Map</a> <a href="#ref-for-dfn-map-key-6" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-map-key-7" title="§ 8.3 cdt:keys">§ 8.3 cdt:keys</a> 
    </li><li>
      <a href="#ref-for-dfn-map-key-8" title="§ 8.4 cdt:merge">§ 8.4 cdt:merge</a> 
    </li><li>
      <a href="#ref-for-dfn-map-key-9" title="§ 8.5 cdt:put">§ 8.5 cdt:put</a> 
    </li><li>
      <a href="#ref-for-dfn-map-key-10" title="§ 8.6 cdt:remove">§ 8.6 cdt:remove</a> <a href="#ref-for-dfn-map-key-11" title="Reference 2">(2)</a> <a href="#ref-for-dfn-map-key-12" title="Reference 3">(3)</a> 
    </li><li>
      <a href="#ref-for-dfn-map-key-13" title="§ 9.2 Relative Order of cdt:Map Literals">§ 9.2 Relative Order of cdt:Map Literals</a> 
    </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-dfn-map-value" aria-label="Links in this document to definition: map value">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#dfn-map-value" aria-label="Permalink for definition: map value. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
      <a href="#ref-for-dfn-map-value-1" title="§ 3.1 Value Space">§ 3.1 Value Space</a> 
    </li><li>
      <a href="#ref-for-dfn-map-value-2" title="§ 4.1 Value Space">§ 4.1 Value Space</a> <a href="#ref-for-dfn-map-value-3" title="Reference 2">(2)</a> <a href="#ref-for-dfn-map-value-4" title="Reference 3">(3)</a> <a href="#ref-for-dfn-map-value-5" title="Reference 4">(4)</a> 
    </li><li>
      <a href="#ref-for-dfn-map-value-6" title="§ 4.4 Relationship to JSON">§ 4.4 Relationship to JSON</a> 
    </li><li>
      <a href="#ref-for-dfn-map-value-7" title="§ 8.1 cdt:Map">§ 8.1 cdt:Map</a> 
    </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-dfn-term-map" aria-label="Links in this document to definition: term map">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#dfn-term-map" aria-label="Permalink for definition: term map. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
      <a href="#ref-for-dfn-term-map-1" title="§ 4.1 Value Space">§ 4.1 Value Space</a> <a href="#ref-for-dfn-term-map-2" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-term-map-3" title="§ 4.2 Lexical Space">§ 4.2 Lexical Space</a> 
    </li><li>
      <a href="#ref-for-dfn-term-map-4" title="§ 4.3 Lexical-To-Value Mapping">§ 4.3 Lexical-To-Value Mapping</a> <a href="#ref-for-dfn-term-map-5" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-term-map-6" title="§ 4.4 Relationship to JSON">§ 4.4 Relationship to JSON</a> 
    </li><li>
      <a href="#ref-for-dfn-term-map-7" title="§ 5.2 map-equal">§ 5.2 map-equal</a> <a href="#ref-for-dfn-term-map-8" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-term-map-9" title="§ 5.4 map-less-than">§ 5.4 map-less-than</a> <a href="#ref-for-dfn-term-map-10" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-term-map-11" title="§ 6.1 cdt:get">§ 6.1 cdt:get</a> 
    </li><li>
      <a href="#ref-for-dfn-term-map-12" title="§ 6.2 cdt:size">§ 6.2 cdt:size</a> 
    </li><li>
      <a href="#ref-for-dfn-term-map-13" title="§ 8.1 cdt:Map">§ 8.1 cdt:Map</a> <a href="#ref-for-dfn-term-map-14" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-term-map-15" title="§ 8.2 cdt:containsKey">§ 8.2 cdt:containsKey</a> 
    </li><li>
      <a href="#ref-for-dfn-term-map-16" title="§ 8.3 cdt:keys">§ 8.3 cdt:keys</a> <a href="#ref-for-dfn-term-map-17" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-term-map-18" title="§ 8.4 cdt:merge">§ 8.4 cdt:merge</a> 
    </li><li>
      <a href="#ref-for-dfn-term-map-19" title="§ 8.5 cdt:put">§ 8.5 cdt:put</a> <a href="#ref-for-dfn-term-map-20" title="Reference 2">(2)</a> <a href="#ref-for-dfn-term-map-21" title="Reference 3">(3)</a> 
    </li><li>
      <a href="#ref-for-dfn-term-map-22" title="§ 8.6 cdt:remove">§ 8.6 cdt:remove</a> 
    </li><li>
      <a href="#ref-for-dfn-term-map-23" title="§ 9.2 Relative Order of cdt:Map Literals">§ 9.2 Relative Order of cdt:Map Literals</a> 
    </li><li>
      <a href="#ref-for-dfn-term-map-24" title="§ 10.3.1.2 Fold2">§ 10.3.1.2 Fold2</a> 
    </li><li>
      <a href="#ref-for-dfn-term-map-25" title="§ 11. UNFOLD">§ 11. UNFOLD</a> 
    </li><li>
      <a href="#ref-for-dfn-term-map-26" title="§ 11.3 Algebra">§ 11.3 Algebra</a> <a href="#ref-for-dfn-term-map-27" title="Reference 2">(2)</a> 
    </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-dfn-empty-term-map" aria-label="Links in this document to definition: empty term map">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#dfn-empty-term-map" aria-label="Permalink for definition: empty term map. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
      <a href="#ref-for-dfn-empty-term-map-1" title="§ 4.1 Value Space">§ 4.1 Value Space</a> 
    </li><li>
      <a href="#ref-for-dfn-empty-term-map-2" title="§ 4.3 Lexical-To-Value Mapping">§ 4.3 Lexical-To-Value Mapping</a> 
    </li><li>
      <a href="#ref-for-dfn-empty-term-map-3" title="§ 5.2 map-equal">§ 5.2 map-equal</a> 
    </li><li>
      <a href="#ref-for-dfn-empty-term-map-4" title="§ 5.4 map-less-than">§ 5.4 map-less-than</a> 
    </li><li>
      <a href="#ref-for-dfn-empty-term-map-5" title="§ 6.1 cdt:get">§ 6.1 cdt:get</a> 
    </li><li>
      <a href="#ref-for-dfn-empty-term-map-6" title="§ 8.1 cdt:Map">§ 8.1 cdt:Map</a> <a href="#ref-for-dfn-empty-term-map-7" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-empty-term-map-8" title="§ 8.3 cdt:keys">§ 8.3 cdt:keys</a> 
    </li><li>
      <a href="#ref-for-dfn-empty-term-map-9" title="§ 8.4 cdt:merge">§ 8.4 cdt:merge</a> 
    </li><li>
      <a href="#ref-for-dfn-empty-term-map-10" title="§ 8.5 cdt:put">§ 8.5 cdt:put</a> 
    </li><li>
      <a href="#ref-for-dfn-empty-term-map-11" title="§ 8.6 cdt:remove">§ 8.6 cdt:remove</a> 
    </li><li>
      <a href="#ref-for-dfn-empty-term-map-12" title="§ 10.3.1.2 Fold2">§ 10.3.1.2 Fold2</a> <a href="#ref-for-dfn-empty-term-map-13" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-empty-term-map-14" title="§ 11.3 Algebra">§ 11.3 Algebra</a> <a href="#ref-for-dfn-empty-term-map-15" title="Reference 2">(2)</a> 
    </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-dfn-map-entry" aria-label="Links in this document to definition: map entry">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#dfn-map-entry" aria-label="Permalink for definition: map entry. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
      <a href="#ref-for-dfn-map-entry-1" title="§ 4.1 Value Space">§ 4.1 Value Space</a> 
    </li><li>
      <a href="#ref-for-dfn-map-entry-2" title="§ 4.3 Lexical-To-Value Mapping">§ 4.3 Lexical-To-Value Mapping</a> 
    </li><li>
      <a href="#ref-for-dfn-map-entry-3" title="§ 4.4 Relationship to JSON">§ 4.4 Relationship to JSON</a> 
    </li><li>
      <a href="#ref-for-dfn-map-entry-4" title="§ 5.2 map-equal">§ 5.2 map-equal</a> <a href="#ref-for-dfn-map-entry-5" title="Reference 2">(2)</a> <a href="#ref-for-dfn-map-entry-6" title="Reference 3">(3)</a> 
    </li><li>
      <a href="#ref-for-dfn-map-entry-7" title="§ 5.4 map-less-than">§ 5.4 map-less-than</a> <a href="#ref-for-dfn-map-entry-8" title="Reference 2">(2)</a> <a href="#ref-for-dfn-map-entry-9" title="Reference 3">(3)</a> <a href="#ref-for-dfn-map-entry-10" title="Reference 4">(4)</a> 
    </li><li>
      <a href="#ref-for-dfn-map-entry-11" title="§ 6.1 cdt:get">§ 6.1 cdt:get</a> 
    </li><li>
      <a href="#ref-for-dfn-map-entry-12" title="§ 8.1 cdt:Map">§ 8.1 cdt:Map</a> <a href="#ref-for-dfn-map-entry-13" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-map-entry-14" title="§ 8.2 cdt:containsKey">§ 8.2 cdt:containsKey</a> 
    </li><li>
      <a href="#ref-for-dfn-map-entry-15" title="§ 8.3 cdt:keys">§ 8.3 cdt:keys</a> 
    </li><li>
      <a href="#ref-for-dfn-map-entry-16" title="§ 8.4 cdt:merge">§ 8.4 cdt:merge</a> 
    </li><li>
      <a href="#ref-for-dfn-map-entry-17" title="§ 8.5 cdt:put">§ 8.5 cdt:put</a> 
    </li><li>
      <a href="#ref-for-dfn-map-entry-18" title="§ 8.6 cdt:remove">§ 8.6 cdt:remove</a> 
    </li><li>
      <a href="#ref-for-dfn-map-entry-19" title="§ 9.2 Relative Order of cdt:Map Literals">§ 9.2 Relative Order of cdt:Map Literals</a> 
    </li><li>
      <a href="#ref-for-dfn-map-entry-20" title="§ 10.3.1.2 Fold2">§ 10.3.1.2 Fold2</a> 
    </li><li>
      <a href="#ref-for-dfn-map-entry-21" title="§ 11.3 Algebra">§ 11.3 Algebra</a> <a href="#ref-for-dfn-map-entry-22" title="Reference 2">(2)</a> 
    </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-dfn-key-of-map-entry" aria-label="Links in this document to definition: key">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#dfn-key-of-map-entry" aria-label="Permalink for definition: key. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
      <a href="#ref-for-dfn-key-of-map-entry-1" title="§ 4.1 Value Space">§ 4.1 Value Space</a> 
    </li><li>
      <a href="#ref-for-dfn-key-of-map-entry-2" title="§ 11.3 Algebra">§ 11.3 Algebra</a> 
    </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-dfn-value-of-map-entry" aria-label="Links in this document to definition: value">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#dfn-value-of-map-entry" aria-label="Permalink for definition: value. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
      <a href="#ref-for-dfn-value-of-map-entry-1" title="§ 4.1 Value Space">§ 4.1 Value Space</a> 
    </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-dfn-contains-map-entry" aria-label="Links in this document to definition: contains">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#dfn-contains-map-entry" aria-label="Permalink for definition: contains. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
      <a href="#ref-for-dfn-contains-map-entry-1" title="§ 4.1 Value Space">§ 4.1 Value Space</a> <a href="#ref-for-dfn-contains-map-entry-2" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-contains-map-entry-3" title="§ 4.3 Lexical-To-Value Mapping">§ 4.3 Lexical-To-Value Mapping</a> 
    </li><li>
      <a href="#ref-for-dfn-contains-map-entry-4" title="§ 4.4 Relationship to JSON">§ 4.4 Relationship to JSON</a> 
    </li><li>
      <a href="#ref-for-dfn-contains-map-entry-5" title="§ 5.2 map-equal">§ 5.2 map-equal</a> <a href="#ref-for-dfn-contains-map-entry-6" title="Reference 2">(2)</a> <a href="#ref-for-dfn-contains-map-entry-7" title="Reference 3">(3)</a> 
    </li><li>
      <a href="#ref-for-dfn-contains-map-entry-8" title="§ 5.4 map-less-than">§ 5.4 map-less-than</a> <a href="#ref-for-dfn-contains-map-entry-9" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-contains-map-entry-10" title="§ 8.5 cdt:put">§ 8.5 cdt:put</a> 
    </li><li>
      <a href="#ref-for-dfn-contains-map-entry-11" title="§ 9.2 Relative Order of cdt:Map Literals">§ 9.2 Relative Order of cdt:Map Literals</a> 
    </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-defn_algOrderGroups" aria-label="Links in this document to definition: OrderGroups">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#defn_algOrderGroups" aria-label="Permalink for definition: OrderGroups. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
      <a href="#ref-for-defn_algOrderGroups-1" title="§ 10.4 Evaluation Semantics">§ 10.4 Evaluation Semantics</a> 
    </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-defn_evalOrderGroups" aria-label="Links in this document to definition: Evaluation of OrderGroups">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#defn_evalOrderGroups" aria-label="Permalink for definition: Evaluation of OrderGroups. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
      <li>Not referenced in this document.</li>
    </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-dfn-Unfold1" aria-label="Links in this document to definition: Unfold1">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#dfn-Unfold1" aria-label="Permalink for definition: Unfold1. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
      <a href="#ref-for-dfn-Unfold1-1" title="§ 11.3 Algebra">§ 11.3 Algebra</a> <a href="#ref-for-dfn-Unfold1-2" title="Reference 2">(2)</a> 
    </li><li>
      <a href="#ref-for-dfn-Unfold1-3" title="§ 11.4 Evaluation Semantics">§ 11.4 Evaluation Semantics</a> 
    </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-dfn-Unfold2" aria-label="Links in this document to definition: Unfold2">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#dfn-Unfold2" aria-label="Permalink for definition: Unfold2. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
      <a href="#ref-for-dfn-Unfold2-1" title="§ 11.3 Algebra">§ 11.3 Algebra</a> 
    </li><li>
      <a href="#ref-for-dfn-Unfold2-2" title="§ 11.4 Evaluation Semantics">§ 11.4 Evaluation Semantics</a> 
    </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-dfn-evalUnfold" aria-label="Links in this document to definition: Evaluation of Unfold1">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#dfn-evalUnfold" aria-label="Permalink for definition: Evaluation of Unfold1. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
      <li>Not referenced in this document.</li>
    </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-dfn-evalUnfold2" aria-label="Links in this document to definition: Evaluation of Unfold2">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="#dfn-evalUnfold2" aria-label="Permalink for definition: Evaluation of Unfold2. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
      <li>Not referenced in this document.</li>
    </ul>
    </div><script id="respec-dfn-panel">(() => {
// @ts-check
if (document.respec) {
  document.respec.ready.then(setupPanel);
} else {
  setupPanel();
}

function setupPanel() {
  const listener = panelListener();
  document.body.addEventListener("keydown", listener);
  document.body.addEventListener("click", listener);
}

function panelListener() {
  /** @type {HTMLElement} */
  let panel = null;
  return event => {
    const { target, type } = event;

    if (!(target instanceof HTMLElement)) return;

    // For keys, we only care about Enter key to activate the panel
    // otherwise it's activated via a click.
    if (type === "keydown" && event.key !== "Enter") return;

    const action = deriveAction(event);

    switch (action) {
      case "show": {
        hidePanel(panel);
        /** @type {HTMLElement} */
        const dfn = target.closest("dfn, .index-term");
        panel = document.getElementById(`dfn-panel-for-${dfn.id}`);
        const coords = deriveCoordinates(event);
        displayPanel(dfn, panel, coords);
        break;
      }
      case "dock": {
        panel.style.left = null;
        panel.style.top = null;
        panel.classList.add("docked");
        break;
      }
      case "hide": {
        hidePanel(panel);
        panel = null;
        break;
      }
    }
  };
}

/**
 * @param {MouseEvent|KeyboardEvent} event
 */
function deriveCoordinates(event) {
  const target = /** @type HTMLElement */ (event.target);

  // We prevent synthetic AT clicks from putting
  // the dialog in a weird place. The AT events sometimes
  // lack coordinates, so they have clientX/Y = 0
  const rect = target.getBoundingClientRect();
  if (
    event instanceof MouseEvent &&
    event.clientX >= rect.left &&
    event.clientY >= rect.top
  ) {
    // The event probably happened inside the bounding rect...
    return { x: event.clientX, y: event.clientY };
  }

  // Offset to the middle of the element
  const x = rect.x + rect.width / 2;
  // Placed at the bottom of the element
  const y = rect.y + rect.height;
  return { x, y };
}

/**
 * @param {Event} event
 */
function deriveAction(event) {
  const target = /** @type {HTMLElement} */ (event.target);
  const hitALink = !!target.closest("a");
  if (target.closest("dfn:not([data-cite]), .index-term")) {
    return hitALink ? "none" : "show";
  }
  if (target.closest(".dfn-panel")) {
    if (hitALink) {
      return target.classList.contains("self-link") ? "hide" : "dock";
    }
    const panel = target.closest(".dfn-panel");
    return panel.classList.contains("docked") ? "hide" : "none";
  }
  if (document.querySelector(".dfn-panel:not([hidden])")) {
    return "hide";
  }
  return "none";
}

/**
 * @param {HTMLElement} dfn
 * @param {HTMLElement} panel
 * @param {{ x: number, y: number }} clickPosition
 */
function displayPanel(dfn, panel, { x, y }) {
  panel.hidden = false;
  // distance (px) between edge of panel and the pointing triangle (caret)
  const MARGIN = 20;

  const dfnRects = dfn.getClientRects();
  // Find the `top` offset when the `dfn` can be spread across multiple lines
  let closestTop = 0;
  let minDiff = Infinity;
  for (const rect of dfnRects) {
    const { top, bottom } = rect;
    const diffFromClickY = Math.abs((top + bottom) / 2 - y);
    if (diffFromClickY < minDiff) {
      minDiff = diffFromClickY;
      closestTop = top;
    }
  }

  const top = window.scrollY + closestTop + dfnRects[0].height;
  const left = x - MARGIN;
  panel.style.left = `${left}px`;
  panel.style.top = `${top}px`;

  // Find if the panel is flowing out of the window
  const panelRect = panel.getBoundingClientRect();
  const SCREEN_WIDTH = Math.min(window.innerWidth, window.screen.width);
  if (panelRect.right > SCREEN_WIDTH) {
    const newLeft = Math.max(MARGIN, x + MARGIN - panelRect.width);
    const newCaretOffset = left - newLeft;
    panel.style.left = `${newLeft}px`;
    /** @type {HTMLElement} */
    const caret = panel.querySelector(".caret");
    caret.style.left = `${newCaretOffset}px`;
  }

  // As it's a dialog, we trap focus.
  // TODO: when <dialog> becomes a implemented, we should really
  // use that.
  trapFocus(panel, dfn);
}

/**
 * @param {HTMLElement} panel
 * @param {HTMLElement} dfn
 * @returns
 */
function trapFocus(panel, dfn) {
  /** @type NodeListOf<HTMLAnchorElement> elements */
  const anchors = panel.querySelectorAll("a[href]");
  // No need to trap focus
  if (!anchors.length) return;

  // Move focus to first anchor element
  const first = anchors.item(0);
  first.focus();

  const trapListener = createTrapListener(anchors, panel, dfn);
  panel.addEventListener("keydown", trapListener);

  // Hiding the panel releases the trap
  const mo = new MutationObserver(records => {
    const [record] = records;
    const target = /** @type HTMLElement */ (record.target);
    if (target.hidden) {
      panel.removeEventListener("keydown", trapListener);
      mo.disconnect();
    }
  });
  mo.observe(panel, { attributes: true, attributeFilter: ["hidden"] });
}

/**
 *
 * @param {NodeListOf<HTMLAnchorElement>} anchors
 * @param {HTMLElement} panel
 * @param {HTMLElement} dfn
 * @returns
 */
function createTrapListener(anchors, panel, dfn) {
  const lastIndex = anchors.length - 1;
  let currentIndex = 0;
  return event => {
    switch (event.key) {
      // Hitting "Tab" traps us in a nice loop around elements.
      case "Tab": {
        event.preventDefault();
        currentIndex += event.shiftKey ? -1 : +1;
        if (currentIndex < 0) {
          currentIndex = lastIndex;
        } else if (currentIndex > lastIndex) {
          currentIndex = 0;
        }
        anchors.item(currentIndex).focus();
        break;
      }

      // Hitting "Enter" on an anchor releases the trap.
      case "Enter":
        hidePanel(panel);
        break;

      // Hitting "Escape" returns focus to dfn.
      case "Escape":
        hidePanel(panel);
        dfn.focus();
        return;
    }
  };
}

/** @param {HTMLElement} panel */
function hidePanel(panel) {
  if (!panel) return;
  panel.hidden = true;
  panel.classList.remove("docked");
}
})()</script><script src="https://www.w3.org/scripts/TR/2021/fixup.js"></script></body></html>
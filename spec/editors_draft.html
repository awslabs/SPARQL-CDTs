<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Composite Datatype Literals in RDF and SPARQL</title>
  <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>
  <script class="remove">
   // All config options at https://respec.org/docs/
   var respecConfig = {
      specStatus: "unofficial",
// TODO:
      edDraftURI: "https://w3c.github.io/rdf-star/cg-spec/editors_draft.html",
      editors: [
        {
          "name": "Olaf Hartig",
          "url": "http://olafhartig.de/",
          "company": "Amazon",
          "companyURL": "https://amazon.com/",
          "orcid": "0000-0002-1741-2090",
          "w3cid": 112469,
        },
        {
          "name": "Gregory Todd Williams",
          "url": "https://kasei.us/",
          "company": "Amazon",
          "companyURL": "https://amazon.com/",
          "w3cid": 112469,
        },
// TODO: Greg's w3cid ?
      ],
      github: {
        repoURL: "hartig/SPARQL-CDTs",
        branch: "main",
      },
      localBiblio: {
        "EBNF-NOTATION": {
          title: "EBNF NOTATION",
          href: "http://www.w3.org/TR/REC-xml/#sec-notation",
          publisher: "W3C",
          date: "26 November 2008",
          status: "W3C Recommendation",
          authors: [
            "Tim Bray",
            "Jean Paoli",
            "C. M. Sperberg-McQueen",
            "Eve Maler",
            "François Yergeau"
          ]
        }
      },
//       wgPublicList: "public-rdf-star",
//       shortName: "rdf-star",
//       group: "rdf-dev",

//       testSuiteURI: "https://w3c.github.io/rdf-star/tests/",
//       implementationReportURI:"https://w3c.github.io/rdf-star/reports/",
      xref: ["RDF11-CONCEPTS", "SPARQL11-QUERY", "RDF11-MT"],
      maxTocLevel: 3,
//       latestVersion: "https://w3c.github.io/rdf-star/cg-spec",
    };
    // set publishDate and previousDate in order to make a published draft
    var publishDate = null;
    var previousDate = null;
    if (publishDate !== null && previousDate !== null) {
      var thisVersion = "https://w3c.github.io/rdf-star/cg-spec/" + publishDate + ".html";
      var previousVersion = "https://w3c.github.io/rdf-star/cg-spec/" + previousDate + ".html";
      respecConfig.otherLinks.push({
        key: "This version:",
          data: [
            {
              value: thisVersion,
              href: thisVersion,
            }
          ]
      });
      respecConfig.otherLinks.push({
        key: "Previous version:",
          data: [
            {
              value: previousVersion,
              href: previousVersion,
            }
          ]
      });
      respecConfig.publishDate = publishDate;
      respecConfig.doJsonLd = true;
      respecConfig.canonicalURI = thisVersion;
      window.addEventListener('load', () => {
        document.body.classList.add('no-watermark');
      })
    }
  </script>
  <style>
    /* copied from TR/turtle, and adapted for SPARQL rules */
    .grammar td { font-family: monospace; vertical-align: top; }
    .grammar-literal, .token { color: gray;}
    .grammar_comment { color: #A52A2A; font-style: italic; }

    /* better looking quoted examples */
    .example .example {
      border-left-width: .15em;
    }

    /* better numbering of algorithm steps */
    .algorithm ol {
      counter-reset: numsection;
      list-style-type: none;
    }
    .algorithm ol>li {
      margin: 0.5em 0;
    }
    .algorithm ol>li:before {
      font-weight: bold;
      counter-increment: numsection;
      content: counters(numsection, ".") ") ";
    }

    /* SPARQL modification section */

    .defn	{ 
/*         margin-left:5% ; margin-right: 7%;  */
        margin-top: 0.1ex ; margin-bottom: 0.1ex ;
        border: thin solid #888888;
        padding: 1ex 2ex 0.5ex 2ex ;
        page-break-inside: avoid ;
        background-color: #F0F8F8 ;
    }
    
    div.defn p	{ margin-top: 1ex ; margin-bottom: 1.5ex ;}
    div.defn ul	{ margin-top: 1ex ; margin-bottom: 1.5ex ; }

    .operator {
        border: solid;
        border-width: 1px;
        border-color: #888;
        width: 100%;
        margin: 0px;
    }

    .operator tr {
        border: solid;
        border-color: #888;
        border-width: 1px;
    }
    
    .operator th {
        border: solid;
        border-color: #888;
        border-width: 1px;
        font-weight: bold;
    }

    .operator td {
        border: solid;
        border-color: #888;
        border-width: 1px;
    }

    .inscope {
        border-collapse: collapse;
    }

    .inscope th {
        border: solid;
        border-width: 1px;
        font-weight: bold;
        padding-left:  10px;
        padding-right: 10px;
    }

    .inscope td {
        border: solid;
        border-width: 1px;
        padding-left:  10px;
        padding-right: 10px;
    }
    
    .heavy { color:black; font-weight:bold }
    .small { font-size: smaller; }

    #structure-map table {
      background-image: url("visual-map-bg.svg");
      background-size: 100% 100%;
      background-repeat: no-repeat;
    }

    #structure-map table td {
      width: 33.34%;
    }

    #structure-map .box {
      display: block;
      border: thin solid gray;
      border-radius: 0.5em;
      background-color: white;
      margin: 0.7em 1em;
      padding: 0.35em 0.5em;
      box-shadow: 0.25em 0.25em 0.5em darkgray;
      text-align: center;
    }

    /* remove "unofficial draft" watermark */
    body.no-watermark {
      background: url('https://www.w3.org/StyleSheets/TR/2016/logos/back-cg-draft') no-repeat !important
    }
  </style>
  <script>
    /* copied from JSON-LD specs */
    function updateExample(doc, content) {
      // perform transformations to make it render and prettier
      return _esc(reindent(unComment(doc, content)));
    }

    function _esc(s) {
      return s.replace(/&/g,'&amp;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/</g,'&lt;');
    }

    function reindent(text) {
      // TODO: use trimEnd when Edge supports it
      const lines = text.trimRight().split("\n");
      while (lines.length && !lines[0].trim()) {
        lines.shift();
      }
      const indents = lines.filter(s => s.trim()).map(s => s.search(/[^\s]/));
      const leastIndent = Math.min(...indents);
      return lines.map(s => s.slice(leastIndent)).join("\n");
    }

    function unComment(doc, content) {
      // perform transformations to make it render and prettier
      return content
        .replace(/<!--/, '')
        .replace(/-->/, '')
        .replace(/< !\s*-\s*-/g, '<!--')
        .replace(/-\s*- >/g, '-->')
        .replace(/-\s*-\s*&gt;/g, '--&gt;');
    }
  </script>
</head>
<body>
  <section id="abstract">
    <p>The Resource Description Framework (RDF) is a general-purpose framework for representing information on the Web, and the SPARQL language is a declarative language for querying and updating RDF data. This specification defines an approach to represent composite values (lists and maps) as literals in RDF, and corresponding extensions of the SPARQL language. These extensions include an aggregation function to produce such composite values, functions to operate on such composite values in expressions, and a new operator to transform such composite values into their individual components.</p>
  </section>
  <section id="sotd">
  </section>

  <section id="introduction">
    <h1>Introduction</h1>

    <section class="informative">
      <h2>Background and Motivation</h2>

      <p>The RDF data model lets you state facts in three-part subject-predicate-object statements known as triples. For example, with a single RDF triple, you can say that employee38 has a familyName of "Smith". A triple's predicate is a property specified with an IRI (an Internationalized version of a URI), identifying that property in a globally unambiguous way. A triple's subject and object can each be an IRI referencing any entity, and the object can also be a literal value such as "Smith" or data of other types such as dates, numbers, or Boolean values.</p>

      <p>TODO</p>
<!-- <p class="issue" data-number="43">Although the examples in this document, and the tests in <a href="https://w3c.github.io/rdf-star/tests/">the test suite</a>, adopt the optimistic approach, it should be noted that no clear consensus emerged from the group on which approach is the best.</p> -->

    </section>

    <section class="informative">
      <h2>Overview</h2>

      <p>
        The basis of the approach is to capture composite values (lists and maps) as RDF literals. The components of such a composite value may be RDF terms, including literals representing other composite values. The <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> (i.e., the string representation) of such a literal that represents a composite value contains the components of the composite value serialized in a format that is based on the <a href="https://www.w3.org/TR/turtle/">RDF Turtle format</a> [[TURTLE]]. For instance, the literals in the object positions of the following two RDF triples represent lists. Notice that, in the lexical form of these literals, the elements of the lists are separated by commas and enclosed in square brackets.
      </p>
      <pre id="first-list-example"
           data-transform="updateExample"
           data-content-type="text/turtle"
           class="nohighlight example">
        <!--
        ex:s ex:p1 "[ '1999-08-16'^^<http://www.w3.org/2001/XMLSchema#date>, 42 ]"^^cdt:List .
        ex:s ex:p2 "[ <http://example.org/>, [1,2,3], 2.5 ]"^^cdt:List .
        -->
      </pre>
      <p>
        In addition to lists, the approach considers maps, as demonstrated by the literal in the object position of the following triple.
      </p>
      <pre id="first-map-example"
           data-transform="updateExample"
           data-content-type="text/turtle"
           class="nohighlight example">
        <!--
        ex:s ex:p1 "{ 'name' : 'Tuva', 1: <http://example.org/> }"^^cdt:Map .
        -->
      </pre>
      <p>
        For a more detailed description of this form of literals for composite values, refer to the more extensive <a href="#description-of-literals">informal description of the approach</a>. For the definition of the datatypes used for these literals, refer to Sections&nbsp;<a href="#list-datatype" class="sectionRef"></a> and <a href="#map-datatype" class="sectionRef"></a>.
      </p>
      <p>
        Given such composite datatype literals, the approach extends the SPARQL language with functionality related to the types of composite values that these literals capture. In particular, SPARQL is extended in the following three ways.
      </p>
      <p>
        First, the approach introduces various functions for such literals that can be used in expressions (as given in BIND clauses, FILTER clauses, and SELECT expressions). As an example, consider the following SPARQL query (prefix declarations omitted) that uses two such functions in a BIND clause; one of these functions (<a href="#func_concat">`cdt:concat`</a>) concatenates two lists, returning the resulting list as a literal again, and the other function (<a href="#func_size">`cdt:size`</a>) returns the cardinality of the resulting list.
      </p>
      <p class="issue">
      Can we include both the query and the expected output in these examples? Something like <a href="https://www.w3.org/TR/json-ld11/#example-3-sample-json-ld-document-using-full-iris-instead-of-terms">JSON-LD spec examples</a>?
      </p>
      <pre id="first-functions-example"
           data-transform="updateExample"
           data-content-type="application/sparql-query"
           class="nohighlight example">
        <!--
        SELECT * WHERE {
          ex:s ex:p1 ?l1 .
          ex:s ex:p2 ?l2 .
          BIND( cdt:size( cdt:concat(?l1,?l2) ) AS ?combinedLength )
        }
        -->
      </pre>
      <p>
        When executing this query over the <a href="#first-list-example">first example data above</a> (the example with the two lists), the value produced for the `?combinedLength` variable would be&nbsp;5.
      </p>
      <p>
        As its second extension to SPARQL, the approach introduces a set function called FOLD that produces composite values for groups of solution mappings. The following query illustrates how this function can be used to create lists of persons that have the same name.
      </p>
      
      <pre id="first-fold-example"
           data-transform="updateExample"
           data-content-type="application/sparql-query"
           class="nohighlight example">
        <!--
        SELECT ?name (FOLD(?person) AS ?list) WHERE {
          ?person rdf:type foaf:Person .
          ?person foaf:name ?name .
        }
        GROUP BY ?name
        -->
      </pre>
      <p>
        The third extension to SPARQL is a new operator called UNFOLD that transforms composite values into their individual components and, then, assigns these components separately to a new query variable. The following query illustrates how this operator can be used to extract all elements from all lists represented by the objects of triples that match a given triple pattern.
      </p>
      <pre id="first-fold-example"
           data-transform="updateExample"
           data-content-type="application/sparql-query"
           class="nohighlight example">
        <!--
        SELECT ?element ?list WHERE {
          ex:s ?p ?list .
          UNFOLD( ?list AS ?element )
        }
        -->
      </pre>
      <p>
        When executing this query over the <a href="#first-list-example">first example data above</a>, the query result consists of five solutions: two for the two elements of the list in the first triple of the example data and another three for the three elements of the list in the second triple.
        For a more detailed description and more examples of these three extensions to SPARQL, refer to the extensive <a href="#description-of-literals">informal description of the approach</a>.
      </p>

    </section>

    <section>
      <h2>Conventions</h2>
      <p>
        For the remainder of this document, examples will assume that the following prefixes have been declared to represent the IRIs shown with them here:
      </p>

      <table>
        <tr><td>`:`</td><td>`&lt;http://www.example.org/&gt;`</td></tr>
        <tr><td>`rdf:`</td><td>`&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;`</td></tr>
        <tr><td>`rdfs:`</td><td>`&lt;http://www.w3.org/2000/01/rdf-schema#&gt;`</td></tr>
        <tr><td>`owl:`</td><td>`&lt;http://www.w3.org/2002/07/owl#&gt;`</td></tr>
        <tr><td>`foaf:`</td><td>`&lt;http://xmlns.com/foaf/0.1/&gt;`</td></tr>
        <tr><td>`prov:`</td><td>`&lt;http://www.w3.org/ns/prov#&gt;`</td></tr>
        <tr><td>`dbo:`</td><td>`&lt;http://dbpedia.org/ontology/&gt;`</td></tr>
        <tr><td>`dbr:`</td><td>`&lt;http://dbpedia.org/resource/&gt;`</td></tr>
        <tr><td>`dc:`</td><td>`&lt;http://purl.org/dc/elements/1.1/&gt;`</td></tr>
        <tr><td>`dct:`</td><td>`&lt;http://purl.org/dc/terms/&gt;`</td></tr>
        <tr><td>`rdf-star:`</td><td>`&lt;http://www.w3.org/ns/rdf-star#&gt;`</td></tr>
      </table>

    </section>

    <section id="structure">
      <h2>Structure of this document</h2>
      <p>TODO</p>
    </section>

    <section id="conformance">
      <p>TODO</p>
    </section>

  </section>


  <section id="description" class="informative">
    <h1>Informal Description of the Approach</h1>
    
    <p>TODO</p>

    <section id="description-of-literals">
      <h2>Representation of Composite Values as RDF Literals</h2>
      <p>TODO</p>
    </section>

    <section id="description-of-functions">
      <h2>SPARQL Functions on Composite Datatype Literals</h2>
      <p>TODO</p>
    </section>

    <section id="description-of-fold">
      <h2>FOLD Function</h2>
      <p>TODO</p>
    </section>

    <section id="description-of-unfold">
      <h2>UNFOLD Operator</h2>
      <p>TODO</p>
    </section>

  </section>


  <section id="list-datatype">
    <h2>The cdt:List Datatype</h2>

    <p>
      The <dfn data-lt="cdt:List datatype">cdt:List datatype</dfn> is the <a data-cite="RDF11-CONCEPTS#dfn-datatype">RDF datatype</a> that consists of the <a data-cite="RDF11-CONCEPTS#dfn-value-space">value space</a>, the <a data-cite="RDF11-CONCEPTS#dfn-lexical-space">lexical space</a>, and the <a data-cite="RDF11-CONCEPTS#dfn-lexical-to-value-mapping">lexical-to-value mapping</a> defined in this section (see Subsections <a href="#list-datatype-valuespace" class="sectionRef"></a>, <a href="#list-datatype-lexspace" class="sectionRef"></a>, and <a href="#list-datatype-lex-to-value-mapping" class="sectionRef"></a>, respectively), and that is denoted by the following <a data-cite="RDF11-CONCEPTS#dfn-datatype-iri">datatype IRI</a>:
    </p>
    <p>
      `http://example.org/cdt/List`
    </p>
    <p class="issue" title="Resolve on actual datatype IRI">
    <p>
      Every <a data-cite="RDF11-CONCEPTS#dfn-literal">literal</a> that has this IRI as its <a data-cite="RDF11-CONCEPTS#dfn-datatype-iri">datatype IRI</a> is called a <dfn data-lt="cdt:List literal">cdt:List literal</dfn>. If the <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> of such a literal is in the <a data-cite="RDF11-CONCEPTS#dfn-lexical-space">lexical space</a> of the <a>cdt:List datatype</a>, as defined in Section&nbsp;<a href="#list-datatype-lexspace" class="sectionRef"></a>, then the literal is called a <dfn data-lt="well-formed cdt:List literal">well-formed cdt:List literal</dfn>. In contrast, a <a>cdt:List literal</a> whose lexical form is not in the lexical space of the cdt:List datatype is called an <dfn data-lt="ill-formed cdt:List literal">ill-formed cdt:List literal</dfn>.
    </p>

    <section id="list-datatype-valuespace">
      <h2>Value Space</h2>

      <p>
        The <a data-cite="RDF11-CONCEPTS#dfn-value-space">value space</a> of the <a>cdt:List datatype</a> consists of all finite <a href="https://en.wikipedia.org/wiki/Sequence">sequences</a> of <a>list elements</a>, where the notion of a <dfn data-lt="list element">list element</dfn> is defined as follows:
        <ul>
          <li>every <a data-cite="RDF11-CONCEPTS#dfn-rdf-term">RDF term</a> is a list element and</li>
          <li><a>null</a> is a list element.</li>
        </ul>
        Any such sequence is called <dfn data-lt="term list">term list</dfn>, and the empty sequence of <a>list elements</a> is the <dfn data-lt="empty term list">empty term list</dfn>.
      </p>

      <p>
        <dfn data-lt="null">null</dfn> is a special symbol that can be used as a <a>list element</a> (and as a <a>map value</a>) and that is <em>not</em> an <a data-cite="RDF11-CONCEPTS#dfn-rdf-term">RDF term</a>.
      </p>

      <p class="note">
        Every RDF term MAY occur multiple times in a <a>term list</a>, and so may <a>null</a>.
      </p>

    </section>

    <section id="list-datatype-lexspace">
      <h2>Lexical Space</h2>
        
      <p>
        The <a data-cite="RDF11-CONCEPTS#dfn-lexical-space">lexical space</a> of the <a>cdt:List datatype</a> consists of all strings that are recognized by the <a href="#cdt-grammar-production-List">`List`</a> production of the following grammar (the <a data-cite="XML#sec-notation"><abbr title="Extended Backus-Naur Form">EBNF</abbr> notation</a> used here is defined in XML 1.0 [[EBNF-NOTATION]]).
      </p>
      <p>
        The grammar uses productions from the grammar of the Turtle serialization format for RDF data [[TURTLE]]. In particular, the terminal and nonterminal symbols for which no production rule is provided below (i.e.,
        <a data-cite="TURTLE#grammar-production-IRIREF">`IRIREF`</a>,
        <a data-cite="TURTLE#grammar-production-BLANK_NODE_LABEL">`BLANK_NODE_LABEL`</a>,
        <a data-cite="TURTLE#grammar-production-NumericLiteral">`NumericLiteral`</a>,
        <a data-cite="TURTLE#grammar-production-BooleanLiteral">`BooleanLiteral`</a>,
        <a data-cite="TURTLE#grammar-production-String">`String`</a>,
        and
        <a data-cite="TURTLE#grammar-production-LANGTAG">LANGTAG</a>)
        are defined in the Turtle grammar.
      </p>
      <p>
        The <a href="#cdt-grammar-production-RDFLiteral">`RDFLiteral`</a> production in the given grammar is special as the Turtle grammar also contains a very similar production for the same symbol (see <a data-cite="TURTLE#grammar-production-RDFLiteral">`RDFLiteral`</a> in [[TURTLE]]). The difference is that the version of the rule in the Turtle grammar permits the <a data-cite="RDF11-CONCEPTS#dfn-datatype-iri">datatype IRI</a> of a <a data-cite="RDF11-CONCEPTS#literal">literal</a> to be written as a <a data-cite="TURTLE#prefixed-name">prefixed name</a>, whereas the version of the rule as defined below does not permit datatype IRIs written as prefixed names (but only as absolute IRIs and as <a data-cite="TURTLE#relative-iri">relative IRIs</a>).
      </p>
      <p>
        An additional restriction that is not explicitly captured in the given grammar, but that MUST be ensured by parsers for <a>cdt:List literals</a> (and <a>cdt:Map literals</a>), is that any occurrence of the <a data-cite="TURTLE#grammar-production-IRIREF">`IRIREF`</a> production MUST also match the (more restrictive) `absolute-IRI` production of [[RFC3987]]. Hence, IRI references in the lexical form of <a>cdt:List literals</a> and <a>cdt:Map literals</a> MUST be absolute; they cannot be written as <a data-cite="TURTLE#prefixed-name">prefixed names</a> (see the previous paragraph about the <a href="#cdt-grammar-production-RDFLiteral">`RDFLiteral`</a> production) nor as <a data-cite="TURTLE#relative-iri">relative IRI references</a>.
      </p>

      <table class="grammar">

        <tr id="cdt-grammar-production-List">
          <td>[1]</td>
          <td>`List`</td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <code class="token">'['</code>
            `(`
            <a href="#cdt-grammar-production-NonEmptyListContent">NonEmptyListContent</a>
            `)?`
            <code class="token">']'</code>
          </td>
        </tr>

        <tr id="cdt-grammar-production-NonEmptyListContent">
          <td>[2]</td>
          <td>`NonEmptyListContent`</td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <a href="#cdt-grammar-production-ListElement">ListElement</a>
            `(`
            <code class="token">','</code>
            <a href="#cdt-grammar-production-ListElement">ListElement</a>
            `)*`
          </td>
        </tr>

        <tr id="cdt-grammar-production-ListElement">
          <td>[3]</td>
          <td>`ListElement`</td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <a data-cite="TURTLE#grammar-production-IRIREF">IRIREF</a>
            `|`
            <a data-cite="TURTLE#grammar-production-BLANK_NODE_LABEL">BLANK_NODE_LABEL</a>
            `|`
            <a href="#cdt-grammar-production-RDFLiteral">RDFLiteral</a>
            `|`
            <a data-cite="TURTLE#grammar-production-NumericLiteral">NumericLiteral</a>
            `|`
            <a data-cite="TURTLE#grammar-production-BooleanLiteral">BooleanLiteral</a>
            `|`
            <a href="#cdt-grammar-production-NULL">NULL</a>
            `|`
            <a href="#cdt-grammar-production-List">List</a>
            `|`
            <a href="#cdt-grammar-production-Map">Map</a>
          </td>
        </tr>

        <tr id="cdt-grammar-production-Map">
          <td>[4]</td>
          <td>`Map`</td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <code class="token">'{'</code>
            `(`
            <a href="#cdt-grammar-production-NonEmptyMapContent">NonEmptyMapContent</a>
            `)?`
            <code class="token">'}'</code>
          </td>
        </tr>

        <tr id="cdt-grammar-production-NonEmptyMapContent">
          <td>[5]</td>
          <td>`NonEmptyMapContent`</td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <a href="#cdt-grammar-production-MapEntry">MapEntry</a>
            `(`
            <code class="token">','</code>
            <a href="#cdt-grammar-production-MapEntry">MapEntry</a>
            `)*`
          </td>
        </tr>

        <tr id="cdt-grammar-production-MapEntry">
          <td>[6]</td>
          <td>`MapEntry`</td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <a href="#cdt-grammar-production-MapKey">MapKey</a>
            <code class="token">':'</code>
            <a href="#cdt-grammar-production-MapValue">MapValue</a>
          </td>
        </tr>

        <tr id="cdt-grammar-production-MapKey">
          <td>[7]</td>
          <td>`MapKey`</td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <a data-cite="TURTLE#grammar-production-IRIREF">IRIREF</a>
            `|`
            <a href="#cdt-grammar-production-RDFLiteral">RDFLiteral</a>
            `|`
            <a data-cite="TURTLE#grammar-production-NumericLiteral">NumericLiteral</a>
            `|`
            <a data-cite="TURTLE#grammar-production-BooleanLiteral">BooleanLiteral</a>
          </td>
        </tr>

        <tr id="cdt-grammar-production-MapValue">
          <td>[8]</td>
          <td>`MapValue`</td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <a data-cite="TURTLE#grammar-production-IRIREF">IRIREF</a>
            `|`
            <a data-cite="TURTLE#grammar-production-BLANK_NODE_LABEL">BLANK_NODE_LABEL</a>
            `|`
            <a href="#cdt-grammar-production-RDFLiteral">RDFLiteral</a>
            `|`
            <a data-cite="TURTLE#grammar-production-NumericLiteral">NumericLiteral</a>
            `|`
            <a data-cite="TURTLE#grammar-production-BooleanLiteral">BooleanLiteral</a>
            `|`
            <a href="#cdt-grammar-production-NULL">NULL</a>
            `|`
            <a href="#cdt-grammar-production-List">List</a>
            `|`
            <a href="#cdt-grammar-production-Map">Map</a>
          </td>
        </tr>

        <tr id="cdt-grammar-production-NULL">
          <td>[9]</td>
          <td>`NULL`</td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <code class="token">'null'</code>
          </td>
        </tr>

        <tr id="cdt-grammar-production-RDFLiteral">
          <td>[128s]</td>
          <td>`RDFLiteral`</td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <a data-cite="TURTLE#grammar-production-String">String</a>
            `(`
            <a data-cite="TURTLE#grammar-production-LANGTAG">LANGTAG</a>
            `|`
            <code class="token">'^^'</code> <a data-cite="TURTLE#grammar-production-IRIREF">IRIREF</a>
            `)?`
          </td>
        </tr>

      </table>

      <p class="note">
        The complete grammar can be found in <a href="#cdt-ebnf"></a>.
      </p>

    </section>

    <section id="list-datatype-lex-to-value-mapping">
      <h2>Lexical-To-Value Mapping</h2>
        
      <p>
        The <a data-cite="RDF11-CONCEPTS#dfn-lexical-to-value-mapping">lexical-to-value mapping</a> of the <a>cdt:List datatype</a> is defined as follows for every string&nbsp;|S| that is recognized by the <a href="#cdt-grammar-production-List">`List`</a> production of the grammar defined in Section&nbsp;<a href="#list-datatype-lexspace" class="sectionRef"></a>.
      </p>
      <p>
        If the string&nbsp;|S| does <em>not</em> contain a substring that is recognized by the <a href="#cdt-grammar-production-NonEmptyListContent">`NonEmptyListContent`</a> production of the grammar, then |S| is mapped to the <a>empty term list</a>.
      </p>
      <p>
        Otherwise, let |S|' be the greatest substring of |S| that is recognized by the <a href="#cdt-grammar-production-NonEmptyListContent">`NonEmptyListContent`</a> production and let (|E|<sub>1</sub>, ..., |E|<sub>|n|</sub>) be the sequence of all substrings of |S|' that are recognized by the <a href="#cdt-grammar-production-ListElement">`ListElement`</a> production, in the order in which they appear in |S|'. Then, |S| is mapped to the <a>term list</a>&nbsp;|tm| that consists of |n| <a>list elements</a> such that, for all |i| in {1, ..., |n|}, the |i|-th element in |tm| is the following <a>list element</a>, depending on which of the cases of the <a href="#cdt-grammar-production-ListElement">`ListElement`</a> production recognizes the substring&nbsp;|E|<sub>|i|</sub>:
        <ul>
          <li>
            If |E|<sub>|i|</sub> is recognized by the <a data-cite="TURTLE#grammar-production-IRIREF">`IRIREF`</a> production, then the |i|-th element in |tm| is the IRI constructed from the substring |E|<sub>|i|</sub> according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]].
			<p class="note">
			The procedure described in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]] involves unescaping Turtle's <a href="https://www.w3.org/TR/turtle/#numeric">numeric escape sequences</a>.
			If an IRI appears in the lexical form of a <a>cdt:List literal</a> in a SPARQL query, it will be subject to <em>both</em> Turtle's numeric escaping <em>and</em> SPARQL's <a href="https://www.w3.org/TR/sparql11-query/#codepointEscape">Codepoint Escape Sequences</a> [[SPARQL11-QUERY]].
			For example, including <code>BIND("[&lt;http://example.org/\u005cu0041>]"^^cdt:List AS ?list)</code> in a SPARQL query will result in a <a>well-formed cdt:List literal</a> whose <a data-cite="RDF11-CONCEPTS#dfn-literal-value">value</a> is a <a>term list</a> with the IRI `http://example.org/A` as element.
			</p>
          </li>
          <li>
            If |E|<sub>|i|</sub> is recognized by the <a data-cite="TURTLE#grammar-production-BLANK_NODE_LABEL">`BLANK_NODE_LABEL`</a> production, then the |i|-th element in |tm| is the blank node constructed from the substring |E|<sub>|i|</sub> according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]].
          </li>
          <li>
            If |E|<sub>|i|</sub> is recognized by the <a href="#cdt-grammar-production-RDFLiteral">`RDFLiteral`</a> production, then the |i|-th element in |tm| is a literal that has as its lexical form the string that has matched the first rule argument, <a data-cite="TURTLE#grammar-production-String">`String`</a>, and the datatype IRI and language tag of the literal are as follows.
            <ul>
              <li>If the <a data-cite="TURTLE#grammar-production-LANGTAG">`LANGTAG`</a> rule matched, the datatype IRI is `rdf:langString` and the language tag is the string that has matched the <a data-cite="TURTLE#grammar-production-LANGTAG">`LANGTAG`</a> rule.</li>
              <li>If the `'^^'`<a data-cite="TURTLE#grammar-production-IRIREF">`IRIREF`</a> rule matched, the datatype IRI is the IRI constructed from the <a data-cite="TURTLE#grammar-production-IRIREF">`IRIREF`</a> match according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]], and the literal has no language tag.</li>
              <li>If neither matched, the datatype is `xsd:string` and the literal has no language tag.</li>
            </ul>
          </li>
          <li>
            If |E|<sub>|i|</sub> is recognized by either the <a data-cite="TURTLE#grammar-production-NumericLiteral">`NumericLiteral`</a> production or the <a data-cite="TURTLE#grammar-production-BooleanLiteral">`BooleanLiteral`</a> production, then the |i|-th element in |tm| is the literal constructed from the substring |E|<sub>|i|</sub> according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]].
          </li>
          <li>
            If |E|<sub>|i|</sub> is recognized by the <a href="#cdt-grammar-production-NULL">`NULL`</a> production, then the |i|-th element in |tm| is <a>null</a>.
          </li>
          <li>
            If |E|<sub>|i|</sub> is recognized by the <a href="#cdt-grammar-production-List">`List`</a> production, then the |i|-th element in |tm| is the literal that has the string |E|<sub>|i|</sub> as its lexical form, the IRI `cdt:List` as its datatype IRI, and no language tag.
          </li>
          <li>
            If |E|<sub>|i|</sub> is recognized by the <a href="#cdt-grammar-production-Map">`Map`</a> production, then the |i|-th element in |tm| is the literal that has the string |E|<sub>|i|</sub> as its lexical form, the IRI `cdt:Map` as its datatype IRI, and no language tag.
          </li>
        </ul>
      </p>
      <p>
        Since producing the <a>term list</a> for |S| as defined above relies on the capability to construct RDF terms according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]], it requires a parser that maintains state of the `bnodeLabels` mapping used for parsing Turtle, as defined in <a href="https://www.w3.org/TR/turtle/#sec-parsing-state">Section&nbsp;7.1</a> of [[TURTLE]].
      </p>

      <p class="note">
        By the definition of the <a data-cite="RDF11-CONCEPTS#dfn-lexical-to-value-mapping">lexical-to-value mapping</a> of the <a>cdt:List datatype</a>, there can be no <a>term list</a> that contains a <a>cdt:List literal</a> whose <a data-cite="RDF11-CONCEPTS#dfn-literal-value">literal value</a> is that same term list.
      </p>

    </section>

    <section id="list-datatype-versus-rdflists" class="informative">
      <h2>Relationship to RDF Lists</h2>

      <p class="issue">
        TODO
      </p>

    </section>

  </section>


  <section id="map-datatype">
    <h2>The cdt:Map Datatype</h2>

    <p>
      The <dfn data-lt="cdt:Map datatype">cdt:Map datatype</dfn> is the <a data-cite="RDF11-CONCEPTS#dfn-datatype">RDF datatype</a> that consists of the <a data-cite="RDF11-CONCEPTS#dfn-value-space">value space</a>, the <a data-cite="RDF11-CONCEPTS#dfn-lexical-space">lexical space</a>, and the <a data-cite="RDF11-CONCEPTS#dfn-lexical-to-value-mapping">lexical-to-value mapping</a> defined in this section (see Subsections <a href="#map-datatype-valuespace" class="sectionRef"></a>, <a href="#map-datatype-lexspace" class="sectionRef"></a>, and <a href="#map-datatype-lex-to-value-mapping" class="sectionRef"></a>, respectively), and that is denoted by the following <a data-cite="RDF11-CONCEPTS#dfn-datatype-iri">datatype IRI</a>:
    </p>
    <p>
      `http://example.org/cdt/Map`
    </p>
    <p>
      Every <a data-cite="RDF11-CONCEPTS#dfn-literal">literal</a> that has this IRI as its <a data-cite="RDF11-CONCEPTS#dfn-datatype-iri">datatype IRI</a> is called a <dfn data-lt="cdt:Map literal">cdt:Map literal</dfn>. If the <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> of such a literal is in the <a data-cite="RDF11-CONCEPTS#dfn-lexical-space">lexical space</a> of the <a>cdt:Map datatype</a>, as defined in Section&nbsp;<a href="#map-datatype-lexspace" class="sectionRef"></a>, then the literal is called a <dfn data-lt="well-formed cdt:Map literal">well-formed cdt:Map literal</dfn>. In contrast, a <a>cdt:Map literal</a> whose lexical form is not in the lexical space of the cdt:Map datatype is called an <dfn data-lt="ill-formed cdt:Map literal">ill-formed cdt:Map literal</dfn>.
    </p>

    <section id="map-datatype-valuespace">
      <h2>Value Space</h2>

      <p>
        The <a data-cite="RDF11-CONCEPTS#dfn-value-space">value space</a> of the <a>cdt:Map datatype</a> consists of all <a href="https://en.wikipedia.org/wiki/Function_(mathematics)">functions</a> that map from a <em>finite</em> set of <a>map keys</a> to the set of <a>map values</a>, where the notion of a <dfn data-lt="map key">map key</dfn> is defined as follows:
        <ul>
          <li>every <a data-cite="RDF11-CONCEPTS#dfn-iri">IRI</a> is a map key and</li>
          <li>every <a data-cite="RDF11-CONCEPTS#dfn-literal">literal</a> is a map key,</li>
        </ul>
        and the notion of a <dfn data-lt="map value">map value</dfn> is defined as follows:
        <ul>
          <li>every <a data-cite="RDF11-CONCEPTS#dfn-rdf-term">RDF term</a> is a map value (i.e., every <a data-cite="RDF11-CONCEPTS#dfn-iri">IRI</a>, <a data-cite="RDF11-CONCEPTS#dfn-literal">literal</a>, and <a data-cite="RDF11-CONCEPTS#dfn-blank-node">blank node</a>) and</li>
          <li><a>null</a> is a map value.</li>
        </ul>
        Any such function is called <dfn data-lt="term map">term map</dfn>, and the <a href="https://en.wikipedia.org/wiki/Function_(mathematics)#empty_function">empty function</a> for the set of <a>map values</a> (i.e., the function that maps from the empty set to the set of <a>map values</a>) is the <dfn data-lt="empty term map">empty term map</dfn>.
        Moreover, every pair&nbsp;(|k|,|v|) consisting of a <a>map key</a>&nbsp;|k| and a <a>map value</a>&nbsp;|v| is called a <dfn data-lt="map entry">map entry</dfn> where |k| is called the <dfn data-lt="key of map entry">key</dfn> of the map entry and |v| is called the <dfn data-lt="value of map entry">value</dfn> of the map entry.
      </p>
      <p>
        Given a <a>term map</a>&nbsp;|tm| and a <a>map entry</a>&nbsp;(|k|,|v|), we say that |tm| <dfn data-lt="contains map entry">contains</dfn> this map entry if |k| is in the <a href="https://en.wikipedia.org/wiki/Domain_of_a_function">domain</a> of |tm| and |tm| maps |k| to |v|; i.e., |tm|(|k|)=|v|.
      </p>

      <p class="note">
        The <a>empty term map</a> does not <a>contain</a> any map entries.
      </p>

      <p class="note">
        A <a>term map</a> MAY <a>contain</a> multiple map entries that all have the same <a>value</a>, but they MUST have different <a>keys</a>. It is possible, however, that multiple map entries of a term map MAY have literals with the same <a data-cite="RDF11-CONCEPTS#dfn-literal-value">literal value</a> as their respective keys, as long as all these literals have a different lexical form. For instance, a term map MAY contain two map entries, (|k|,|v|) and (<var>k'</var>,<var>v'</var>), such that |k| is the literal `"0042"^^xsd:integer` and <var>k'</var> is the literal `"42"^^xsd:integer` (using a Turtle representation of these literals for the sake of readability). Clearly, these are two different literals and, thus, two different map keys, but their literal value is the same (the integer&nbsp;42).
      </p>

    </section>

    <section id="map-datatype-lexspace">
      <h2>Lexical Space</h2>

      <p>
        The <a data-cite="RDF11-CONCEPTS#dfn-lexical-space">lexical space</a> of the <a>cdt:Map datatype</a> consists of all strings that are recognized by the <a href="#cdt-grammar-production-Map">`Map`</a> production of the grammar defined in Section&nbsp;<a href="#list-datatype-lexspace" class="sectionRef"></a> and in which all substrings that matched the <a href="#cdt-grammar-production-MapKey">`MapKey`</a> production are different from one another.
      </p>

      <div class="issue">
        <p>
          The constraint about the substrings is not restrictive enough because the <a href="#cdt-grammar-production-MapKey">`MapKey`</a> production recognizes both the generic way of serializing literals in Turtle and the Turtle shorthand notations for some datatypes. For instance, consider the following string:
        </p>
        <pre class="nohighlight">
          "{ 42 : 'value1',  '42'^^&lt;http://www.w3.org/2001/XMLSchema#integer> : 'value2' }"
        </pre>
        <p>
          This string satisfies the definition given above (including the constraint about the substrings) and, thus, would be a valid lexical form for cdt:Map literals. Yet, the keys of the two map entries represented in this string are the exact same literal, which is illegal according to the definition of <a>term maps</a>.
        </p>
      </div>

    </section>

    <section id="map-datatype-lex-to-value-mapping">
      <h2>Lexical-To-Value Mapping</h2>

      <p>
        The <a data-cite="RDF11-CONCEPTS#dfn-lexical-to-value-mapping">lexical-to-value mapping</a> of the <a>cdt:Map datatype</a> is defined as follows for every string&nbsp;|S| that is recognized by the <a href="#cdt-grammar-production-Map">`Map`</a> production of the grammar defined in Section&nbsp;<a href="#list-datatype-lexspace" class="sectionRef"></a>.
      </p>
      <p>
        If the string&nbsp;|S| does <em>not</em> contain a substring that is recognized by the <a href="#cdt-grammar-production-NonEmptyMapContent">`NonEmptyMapContent`</a> production of the grammar, then |S| is mapped to the <a>empty term map</a>.
      </p>
      <p>
        Otherwise, let |S|' be the greatest substring of |S| that is recognized by the <a href="#cdt-grammar-production-NonEmptyMapContent">`NonEmptyMapContent`</a> production, let (|E|<sub>1</sub>, ..., |E|<sub>|n|</sub>) be the sequence of all substrings of |S|' that are recognized by the <a href="#cdt-grammar-production-MapEntry">`MapEntry`</a> production, and for every |i| in {1, ..., |n|}, let <var>K<sub>|i|</sub></var> and <var>V<sub>|i|</sub></var> be the substrings of |E|<sub>|i|</sub> that are recognized by the <a href="#cdt-grammar-production-MapKey">`MapKey`</a> and the <a href="#cdt-grammar-production-MapValue">`MapValue`</a> productions, respectively.
        Then, |S| is mapped to the <a>term map</a>&nbsp;|tm| that <a>contains</a> |n| <a>map entries</a>, one for each substring&nbsp;|E|<sub>|i|</sub>, where |i| in {1, ..., |n|}. The particular map entry (<var>k<sub>|i|</sub></var>,<var>v<sub>|i|</sub></var>) that |tm| contains for |E|<sub>|i|</sub> depends on which of the cases of the <a href="#cdt-grammar-production-MapKey">`MapKey`</a> and the <a href="#cdt-grammar-production-MapValue">`MapValue`</a> productions recognize <var>K<sub>|i|</sub></var> and <var>V<sub>|i|</sub></var>. In particular, depending on <var>K<sub>|i|</sub></var>, <var>k<sub>|i|</sub></var> is defined as follows.
        <ul>
          <li>
            If <var>K<sub>|i|</sub></var> is recognized by the <a data-cite="TURTLE#grammar-production-IRIREF">`IRIREF`</a> production, then <var>k<sub>|i|</sub></var> is the IRI constructed from the substring <var>K<sub>|i|</sub></var> according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]].
          </li>
          <li>
            If <var>K<sub>|i|</sub></var> is recognized by the <a href="#cdt-grammar-production-RDFLiteral">`RDFLiteral`</a> production, then <var>k<sub>|i|</sub></var> is a literal that has as its lexical form the string that has matched the first rule argument, <a data-cite="TURTLE#grammar-production-String">`String`</a>, and the datatype IRI and language tag of the literal are as follows.
            <ul>
              <li>If the <a data-cite="TURTLE#grammar-production-LANGTAG">`LANGTAG`</a> rule matched, the datatype IRI is `rdf:langString` and the language tag is the string that has matched the <a data-cite="TURTLE#grammar-production-LANGTAG">`LANGTAG`</a> rule.</li>
              <li>If the `'^^'`<a data-cite="TURTLE#grammar-production-IRIREF">`IRIREF`</a> rule matched, the datatype IRI is the IRI constructed from the <a data-cite="TURTLE#grammar-production-IRIREF">`IRIREF`</a> match according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]], and the literal has no language tag.</li>
              <li>If neither matched, the datatype is `xsd:string` and the literal has no language tag.</li>
            </ul>
          </li>
          <li>
            If <var>K<sub>|i|</sub></var> is recognized by either the <a data-cite="TURTLE#grammar-production-NumericLiteral">`NumericLiteral`</a> production or the <a data-cite="TURTLE#grammar-production-BooleanLiteral">`BooleanLiteral`</a> production, then <var>k<sub>|i|</sub></var> is the literal constructed from the substring <var>K<sub>|i|</sub></var> according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]].
          </li>
        </ul>
        Moreover, depending on <var>V<sub>|i|</sub></var>, <var>v<sub>|i|</sub></var> is defined as follows.
        <ul>
          <li>
            If <var>V<sub>|i|</sub></var> is recognized by the <a data-cite="TURTLE#grammar-production-IRIREF">`IRIREF`</a> production, then <var>v<sub>|i|</sub></var> is the IRI constructed from the substring <var>V<sub>|i|</sub></var> according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]].
          </li>
          <li>
            If <var>V<sub>|i|</sub></var> is recognized by the <a data-cite="TURTLE#grammar-production-BLANK_NODE_LABEL">`BLANK_NODE_LABEL`</a> production, then <var>v<sub>|i|</sub></var> is the blank node constructed from the substring <var>V<sub>|i|</sub></var> according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]].
          </li>
          <li>
            If <var>V<sub>|i|</sub></var> is recognized by the <a href="#cdt-grammar-production-RDFLiteral">`RDFLiteral`</a> production, then <var>v<sub>|i|</sub></var> is a literal that has as its lexical form the string that has matched the first rule argument, <a data-cite="TURTLE#grammar-production-String">`String`</a>, and the datatype IRI and language tag of the literal are as follows.
            <ul>
              <li>If the <a data-cite="TURTLE#grammar-production-LANGTAG">`LANGTAG`</a> rule matched, the datatype IRI is `rdf:langString` and the language tag is the string that has matched the <a data-cite="TURTLE#grammar-production-LANGTAG">`LANGTAG`</a> rule.</li>
              <li>If the `'^^'`<a data-cite="TURTLE#grammar-production-IRIREF">`IRIREF`</a> rule matched, the datatype IRI is the IRI constructed from the <a data-cite="TURTLE#grammar-production-IRIREF">`IRIREF`</a> match according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]], and the literal has no language tag.</li>
              <li>If neither matched, the datatype is `xsd:string` and the literal has no language tag.</li>
            </ul>
          </li>
          <li>
            If <var>V<sub>|i|</sub></var> is recognized by either the <a data-cite="TURTLE#grammar-production-NumericLiteral">`NumericLiteral`</a> production or the <a data-cite="TURTLE#grammar-production-BooleanLiteral">`BooleanLiteral`</a> production, then <var>v<sub>|i|</sub></var> is the literal constructed from the substring <var>V<sub>|i|</sub></var> according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]].
          </li>
          <li>
            If <var>V<sub>|i|</sub></var> is recognized by the <a href="#cdt-grammar-production-NULL">`NULL`</a> production, then <var>v<sub>|i|</sub></var> is <a>null</a>.
          </li>
          <li>
            If <var>V<sub>|i|</sub></var> is recognized by the <a href="#cdt-grammar-production-List">`List`</a> production, then <var>v<sub>|i|</sub></var> is the literal that has the string <var>V<sub>|i|</sub></var> as its lexical form, the IRI `cdt:List` as its datatype IRI, and no language tag.
          </li>
          <li>
            If <var>V<sub>|i|</sub></var> is recognized by the <a href="#cdt-grammar-production-Map">`Map`</a> production, then <var>v<sub>|i|</sub></var> is the literal that has the string <var>V<sub>|i|</sub></var> as its lexical form, the IRI `cdt:Map` as its datatype IRI, and no language tag.
          </li>
        </ul>
      </p>
      <p>
        Since producing the <a>term map</a> for |S| as defined above relies on the capability to construct RDF terms according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]], it requires a parser that maintains state of the `bnodeLabels` mapping used for parsing Turtle, as defined in <a href="https://www.w3.org/TR/turtle/#sec-parsing-state">Section&nbsp;7.1</a> of [[TURTLE]].
      </p>

      <p class="note">
        The note about unescaping of IRIs as given in Section&nbsp;<a href="#list-datatype-lex-to-value-mapping" class="sectionRef"></a> applies here too.
      </p>

    </section>

    <section id="map-datatype-versus-json" class="informative">
      <h2>Relationship to JSON</h2>

      <p>
        By the definition of the lexical space of the <a>cdt:Map datatype</a> (see Section&nbsp;<a href="#map-datatype-lexspace" class="sectionRef"></a>), strings that match the <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-4">`object`</a> production of the grammar of the JavaScript Object Notation (JSON) [[RFC8259]] can generally be used as a lexical form of a <a>cdt:Map literal</a> (with a few exceptions related to escaping of characters in strings, see the corresponding note in the following list). When doing so, the lexical-to-value mapping of the <a>cdt:Map datatype</a> (see Section&nbsp;<a href="#map-datatype-lex-to-value-mapping" class="sectionRef"></a>) interprets the various elements of the JSON format as follows.
        <ul>
          <li>
            The <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-4">JSON object</a> that is used as the lexical form of the given <a>cdt:Map literal</a> is mapped to a <a>term map</a>. Every name-value pair of the JSON object becomes a <a>map entry</a> that is <a href="#dfn-contains-map-entry">contained</a> in the resulting term map. The <a>map key</a> of each such map entry is a literal created from the name of the corresponding name-value pair by using the rule for JSON string values as defined below. The <a>map value</a> of each such map entry depends on the type of the value of the corresponding name-value pair.
          </li>
          <li>
            A <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-3">JSON value</a> that is another <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-4">JSON object</a> is mapped to a <a>cdt:Map literal</a> that has the JSON object as its lexical form.
          </li>
          <li>
            A <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-3">JSON value</a> that is an <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-5">array</a> is mapped to a <a>cdt:List literal</a> that has the JSON object as its lexical form.
          </li>
          <li>
            A <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-3">JSON value</a> that is a <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-6">number</a> is mapped to a literal with the number as the lexical form, no language tag, and a datatype IRI that is determined based on the following rules.
            <ul>
              <li>If the number has an exponent part (see the `exp` production of the JSON grammar), then the datatype IRI is `xsd:double`.</li>
              <li>If the number has no exponent part but it has a fraction part (see the `frac` production of the JSON grammar), then the datatype IRI is `xsd:decimal`.</li>
              <li>If the number has no exponent part and no fraction part, then the datatype IRI is `xsd:integer`.</li>
            </ul>
          </li>
          <li>
            A <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-3">JSON value</a> that is a <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-7">string</a> is mapped to a literal with datatype `xsd:string`, no language tag, and a lexical form that is the result of using the sequence of characters between the first and the last quotation mark of the string and applying Turtle's unescaping of <a href="https://www.w3.org/TR/turtle/#numeric">numeric escape sequences</a> and <a href="https://www.w3.org/TR/turtle/#string">string escape sequences</a> to this sequence of characters.
            <p class="note">
              The support for escaping of characters in <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-7">strings</a> in JSON goes beyond the <a href="https://www.w3.org/TR/turtle/#numeric">numeric escape sequences</a> and <a href="https://www.w3.org/TR/turtle/#string">string escape sequences</a> in Turtle. In particular, while both Turtle's string escape sequences and JSON support the two-character sequence '\\' to represent the reverse solidus character (i.e., codepoint <a href="https://util.unicode.org/UnicodeJsps/character.jsp?a=005C">U+005C</a> in Unicode), only JSON supports the two-character sequence '\/' to represent the solidus character (codepoint <a href="https://util.unicode.org/UnicodeJsps/character.jsp?a=002F">U+002F</a>). JSON strings that use this two-character escape sequence cannot be used as a lexical form of a cdt:Map literal; attempting to do so will result in a parser error. Moreover, JSON supports encoding of UTF-16 surrogate pairs using 12-character sequences of the form '\uNNNN\uNNNN' which are not recognized by the numeric escape sequences of Turtle as a singular pair. Hence, when using a JSON string with such surrogate pairs as a lexical form of a cdt:Map literal, then the surrogate pairs are not unescaped correctly.
            </p>
          </li>
          <li>
            A <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-3">JSON value</a> that is the name `false` or the name `true` is mapped to a literal with datatype `xsd:boolean`, no language tag, and a lexical form that is the JSON value (i.e., `false` or `true`).
          </li>
          <li>
            A <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-3">JSON value</a> that is the name `null` is mapped to <a>null</a>.
          </li>
        </ul>
      </p>

    </section>

  </section>


  <section id="extension-of-sparql-operators">
    <h2>Extensions of Existing SPARQL Operators</h2>

    <p>
      This section defines extensions of some of the existing operators of SPARQL. In particular, the `=` operator and the `!=` operator are extended both for <a>cdt:List literals</a> and for <a>cdt:Map literals</a>. Implementations of SPARQL that recognize the datatypes defined above MUST implement these operators with the extensions defined in this section.
    </p>

    <p>
      To define the extensions formally, the operator mapping table for binary operators in <a data-cite="SPARQL11-QUERY#OperatorMapping">Section&nbsp;17.3</a> of [[SPARQL11-QUERY]] is extended with the following twelve rows.
    </p>

    <table class="operator">
      <thead>
        <tr>
          <th>Operator</th>
          <th>Type(A)</th>
          <th>Type(B)</th>
          <th>Function</th>
          <th>Result type</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="font-weight:bold">
          <a data-cite="SPARQL11-QUERY#rRelationalExpression">A = B</a></td>
          <td>cdt:List</td>
          <td>cdt:List</td>
          <td><a href="#func_list-equal">list-equal</a>(A, B)</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a data-cite="SPARQL11-QUERY#rRelationalExpression">A = B</a></td>
          <td>cdt:Map</td>
          <td>cdt:Map</td>
          <td><a href="#func_map-equal">map-equal</a>(A, B)</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a data-cite="SPARQL11-QUERY#rRelationalExpression">A != B</a></td>
          <td>cdt:List</td>
          <td>cdt:List</td>
          <td><a href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a href="#func_list-equal">list-equal</a>(A, B))</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a data-cite="SPARQL11-QUERY#rRelationalExpression">A != B</a></td>
          <td>cdt:Map</td>
          <td>cdt:Map</td>
          <td><a href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a href="#func_map-equal">map-equal</a>(A, B))</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a data-cite="SPARQL11-QUERY#rRelationalExpression">A &lt; B</a></td>
          <td>cdt:List</td>
          <td>cdt:List</td>
          <td><a href="#func_list-less-than">list-less-than</a>(A, B)</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a data-cite="SPARQL11-QUERY#rRelationalExpression">A &lt; B</a></td>
          <td>cdt:Map</td>
          <td>cdt:Map</td>
          <td><a href="#func_map-less-than">map-less-than</a>(A, B)</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a data-cite="SPARQL11-QUERY#rRelationalExpression">A &gt; B</a></td>
          <td>cdt:List</td>
          <td>cdt:List</td>
          <td><a href="#func_list-less-than">list-less-than</a>(B, A)</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a data-cite="SPARQL11-QUERY#rRelationalExpression">A &gt; B</a></td>
          <td>cdt:Map</td>
          <td>cdt:Map</td>
          <td><a href="#func_map-less-than">map-less-than</a>(B, A)</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a data-cite="SPARQL11-QUERY#rRelationalExpression">A &lt;= B</a></td>
          <td>cdt:List</td>
          <td>cdt:List</td>
          <td><a data-cite="SPARQL11-QUERY#func-logical-or">logical-or</a>(<a href="#func_list-less-than">list-less-than</a>(A, B), <a href="#func_list-equal">list-equal</a>(A, B))</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a data-cite="SPARQL11-QUERY#rRelationalExpression">A &lt;= B</a></td>
          <td>cdt:Map</td>
          <td>cdt:Map</td>
          <td><a data-cite="SPARQL11-QUERY#func-logical-or">logical-or</a>(<a href="#func_map-less-than">map-less-than</a>(A, B), <a href="#func_map-equal">map-equal</a>(A, B))</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a data-cite="SPARQL11-QUERY#rRelationalExpression">A &gt;= B</a></td>
          <td>cdt:List</td>
          <td>cdt:List</td>
          <td><a data-cite="SPARQL11-QUERY#func-logical-or">logical-or</a>(<a href="#func_list-less-than">list-less-than</a>(B, A), <a href="#func_list-equal">list-equal</a>(A, B))</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a data-cite="SPARQL11-QUERY#rRelationalExpression">A &gt;= B</a></td>
          <td>cdt:Map</td>
          <td>cdt:Map</td>
          <td><a data-cite="SPARQL11-QUERY#func-logical-or">logical-or</a>(<a href="#func_map-less-than">map-less-than</a>(B, A), <a href="#func_map-equal">map-equal</a>(A, B))</td>
          <td>xsd:boolean</td>
        </tr>
      </tbody>
    </table>

    <p>
      The four new functions used in these table rows are defined in Subsections&nbsp;<a href="#func_list-equal" class="sectionRef"></a>, <a href="#func_map-equal" class="sectionRef"></a>, <a href="#func_list-less-than" class="sectionRef"></a>, and <a href="#func_map-less-than" class="sectionRef"></a> below.
    </p>

    <p class="note">
      It should be noted that extending the operator mapping table with these twelve rows changes the behavior of the corresponding operators (`=`, `!=`, `&lt;`, `&gt;`, `&lt;=`, and `&gt;=`) only for cases in which these operators would otherwise (i.e., without the extension) yield a type error. Therefore, this extension is conformant with the SPARQL specification, as explicitly stated in <a data-cite="SPARQL11-QUERY#operatorExtensibility">Section&nbsp;17.3.1</a> of [[SPARQL11-QUERY]].
    </p>

    <section id="func_list-equal">
      <h2>list-equal</h2>

      <p>
        <code>xsd:boolean </code>
        <code style="color:black;font-weight:bold">list-equal</code>
        (
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term<sub>1</sub></var></code>,
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term<sub>2</sub></var></code>
        )
      </p>

      <p>
        This function cannot be used directly in expressions. Instead, the purpose of this function is to define the semantics of the `=` operator when applied to two <a>cdt:List literals</a>.
      </p>

      <p>
        If both <var>term<sub>1</sub></var> and <var>term<sub>2</sub></var> are <a>well-formed cdt:List literals</a>, then the result of this function is determined by the following algorithm.
      </p>
      <div class="algorithm">
        <ol>
          <li>Let <var>list<sub>1</sub></var> be the <a>term list</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a>cdt:List datatype</a> to the <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> of <var>term<sub>1</sub></var> (i.e., <var>list<sub>1</sub></var> is the <a data-cite="RDF11-CONCEPTS#dfn-literal-value">value</a> of <var>term<sub>1</sub></var>).</li>
          <li>Let <var>list<sub>2</sub></var> be the <a>term list</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a>cdt:List datatype</a> to the <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> of <var>term<sub>2</sub></var> (i.e., <var>list<sub>2</sub></var> is the <a data-cite="RDF11-CONCEPTS#dfn-literal-value">value</a> of <var>term<sub>2</sub></var>).</li>
          <li>If both <var>list<sub>1</sub></var> and <var>list<sub>2</sub></var> are the <a>empty term list</a>, then return `true`.</li>
          <li>If the length of <var>list<sub>1</sub></var> is different from the length of <var>list<sub>2</sub></var>, then return `false`.</li>
          <li>Let <var>err</var> be a boolean-typed variable that is initialized with the value `false`.</li>
          <li>For every integer |i| from 1 to |n|, where |n| is the length of <var>list<sub>1</sub></var>:
            <ol>
              <li>Let <var>elmt<sub>1</sub></var> be the |i|-th element in <var>list<sub>1</sub></var>.</li>
              <li>Let <var>elmt<sub>2</sub></var> be the |i|-th element in <var>list<sub>2</sub></var>.</li>
              <li>If <var>elmt<sub>1</sub></var> or <var>elmt<sub>2</sub></var> is <a>null</a>, set the value of <var>err</var> to `true`.</li>
              <li>If neither <var>elmt<sub>1</sub></var> nor <var>elmt<sub>2</sub></var> is <a>null</a> (i.e., <var>elmt<sub>1</sub></var> and <var>elmt<sub>2</sub></var> are RDF terms), then:
                <ol>
                  <li>If evaluating the SPARQL expression <var>elmt<sub>1</sub></var> = <var>elmt<sub>2</sub></var> results in an error, set the value of <var>err</var> to `true`.</li>
                  <li>If evaluating the SPARQL expression <var>elmt<sub>1</sub></var> = <var>elmt<sub>2</sub></var> results in `false`, return `false`.</li>
                </ol>
              </li>
            </ol>
          </li>
          <li>If the value of <var>err</var> is `true`, produce an error.</li>
          <li>Return `true`.</li>
        </ol>
      </div>

      <p>
        If <var>term<sub>1</sub></var> or <var>term<sub>2</sub></var> is an <a>ill-formed cdt:List literal</a>, then this function produces an error.
      </p>

    </section>

    <section id="func_map-equal">
      <h2>map-equal</h2>

      <p>
        <code>xsd:boolean </code>
        <code style="color:black;font-weight:bold">map-equal</code>
        (
           <code><a href="#dfn-cdt-map-literal">cdt:Map</a> <var>term<sub>1</sub></var></code>,
           <code><a href="#dfn-cdt-map-literal">cdt:Map</a> <var>term<sub>2</sub></var></code>
        )
      </p>

      <p>
        This function cannot be used directly in expressions. Instead, the purpose of this function is to define the semantics of the `=` operator when applied to two <a>cdt:Map literals</a>.
      </p>

      <p>
        If both <var>term<sub>1</sub></var> and <var>term<sub>2</sub></var> are <a>well-formed cdt:Map literals</a>, then the result of this function is determined by the following algorithm.
      </p>
      <div class="algorithm">
        <ol>
          <li>Let <var>map<sub>1</sub></var> be the <a>term map</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a>cdt:Map datatype</a> to the <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> of <var>term<sub>1</sub></var> (i.e., <var>map<sub>1</sub></var> is the <a data-cite="RDF11-CONCEPTS#dfn-literal-value">value</a> of <var>term<sub>1</sub></var>).</li>
          <li>Let <var>map<sub>2</sub></var> be the <a>term map</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a>cdt:Map datatype</a> to the <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> of <var>term<sub>2</sub></var> (i.e., <var>map<sub>2</sub></var> is the <a data-cite="RDF11-CONCEPTS#dfn-literal-value">value</a> of <var>term<sub>2</sub></var>).</li>
          <li>If both <var>map<sub>1</sub></var> and <var>map<sub>2</sub></var> are the <a>empty term map</a>, then return `true`.</li>
          <li>If the number of <a>map entries</a> that <var>map<sub>1</sub></var> <a href="#dfn-contains-map-entry">contains</a> is different from the number of <a>map entries</a> that <var>map<sub>2</sub></var> <a href="#dfn-contains-map-entry">contains</a>, then return `false`.</li>
          <li>Let <var>err</var> be a boolean-typed variable that is initialized with the value `false`.</li>
          <li>For every <a>map entry</a> (|k|,|v|) <a href="#dfn-contains-map-entry">contained</a> in <var><sub>1</sub></var>:
            <ol>
              <li>If |k| is not in the domain of <var>map<sub>2</sub></var>, return `false`.</li>
              <li>If |v| is <a>null</a> or <var><sub>2</sub></var>(|k|) is <a>null</a>, set the value of <var>err</var> to `true`.</li>
              <li>If neither |v| nor <var>map<sub>2</sub></var>(|k|) is <a>null</a> (i.e., |v| and <var>map<sub>2</sub></var>(|k|) are RDF terms), then:
                <ol>
                  <li>Let <var>v'</var> be the RDF term <var>map<sub>2</sub></var>(|k|).</li>
                  <li>If evaluating the SPARQL expression <var>v'</var> = |v| results in an error, set the value of <var>err</var> to `true`.</li>
                  <li>If evaluating the SPARQL expression <var>v'</var> = |v| results in `false`, return `false`.</li>
                </ol>
              </li>
            </ol>
          </li>
          <li>If the value of <var>err</var> is `true`, produce an error.</li>
          <li>Return `true`.</li>
        </ol>
      </div>

      <p>
        If <var>term<sub>1</sub></var> or <var>term<sub>2</sub></var> is an <a>ill-formed cdt:Map literal</a>, then this function produces an error.
      </p>

    </section>

    <section id="func_list-less-than">
      <h2>list-less-than</h2>

      <p>
        <code>xsd:boolean </code>
        <code style="color:black;font-weight:bold">list-less-than</code>
        (
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term<sub>1</sub></var></code>,
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term<sub>2</sub></var></code>
        )
      </p>

      <p>
        This function cannot be used directly in expressions. Instead, the purpose of this function is to define the semantics of the `&lt;` operator when applied to two <a>cdt:List literals</a>.
      </p>

      <p>
        If both <var>term<sub>1</sub></var> and <var>term<sub>2</sub></var> are <a>well-formed cdt:List literals</a>, then the result of this function is determined by the following algorithm.
      </p>
      <div class="algorithm">
        <ol>
          <li>Let <var>list<sub>1</sub></var> be the <a>term list</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a>cdt:List datatype</a> to the <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> of <var>term<sub>1</sub></var> (i.e., <var>list<sub>1</sub></var> is the <a data-cite="RDF11-CONCEPTS#dfn-literal-value">value</a> of <var>term<sub>1</sub></var>).</li>
          <li>Let <var>list<sub>2</sub></var> be the <a>term list</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a>cdt:List datatype</a> to the <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> of <var>term<sub>2</sub></var> (i.e., <var>list<sub>2</sub></var> is the <a data-cite="RDF11-CONCEPTS#dfn-literal-value">value</a> of <var>term<sub>2</sub></var>).</li>
          <li>If both <var>list<sub>1</sub></var> and <var>list<sub>2</sub></var> are the <a>empty term list</a>, then return `false`.</li>
          <li>For every integer |i| from 1 to |n|, where |n| is the minimum of the length of <var>list<sub>1</sub></var> and the length of <var>list<sub>2</sub></var>:
            <ol>
              <li>Let <var>elmt<sub>1</sub></var> be the |i|-th element in <var>list<sub>1</sub></var>.</li>
              <li>Let <var>elmt<sub>2</sub></var> be the |i|-th element in <var>list<sub>2</sub></var>.</li>
              <li>If <var>elmt<sub>1</sub></var> or <var>elmt<sub>2</sub></var> is <a>null</a>, produce an error.</li>
              <li>If neither <var>elmt<sub>1</sub></var> nor <var>elmt<sub>2</sub></var> is <a>null</a> (i.e., <var>elmt<sub>1</sub></var> and <var>elmt<sub>2</sub></var> are RDF terms), then:
                <ol>
                  <li>If evaluating the SPARQL expression <var>elmt<sub>1</sub></var> `&lt;` <var>elmt<sub>2</sub></var> results in an error, produce an error.</li>
                  <li>If evaluating the SPARQL expression <var>elmt<sub>1</sub></var> `&lt;` <var>elmt<sub>2</sub></var> results in `true`, return `true`.</li>
                  <li>If evaluating the SPARQL expression <var>elmt<sub>1</sub></var> `&lt;` <var>elmt<sub>2</sub></var> results in `false` and evaluating the SPARQL expression <var>elmt<sub>1</sub></var> `=` <var>elmt<sub>2</sub></var> results in an error, produce an error.</li>
                  <li>If evaluating the SPARQL expression <var>elmt<sub>1</sub></var> `&lt;` <var>elmt<sub>2</sub></var> results in `false` and evaluating the SPARQL expression <var>elmt<sub>1</sub></var> `=` <var>elmt<sub>2</sub></var> results in `false`, return `false`.</li>
                </ol>
              </li>
            </ol>
          </li>
          <li>If the length of <var>list<sub>1</sub></var> is smaller than the length of <var>list<sub>2</sub></var>, return `true`.</li>
          <li>Return `false`.</li>
        </ol>
      </div>

      <p>
        If <var>term<sub>1</sub></var> or <var>term<sub>2</sub></var> is an <a>ill-formed cdt:List literal</a>, then this function produces an error.
      </p>

    </section>

    <section id="func_map-less-than">
      <h2>map-less-than</h2>

      <p>
        <code>xsd:boolean </code>
        <code style="color:black;font-weight:bold">map-less-than</code>
        (
           <code><a href="#dfn-cdt-map-literal">cdt:Map</a> <var>term<sub>1</sub></var></code>,
           <code><a href="#dfn-cdt-map-literal">cdt:Map</a> <var>term<sub>2</sub></var></code>
        )
      </p>

      <p>
        This function cannot be used directly in expressions. Instead, the purpose of this function is to define the semantics of the `&lt;` operator when applied to two <a>cdt:Map literals</a>.
      </p>

      <p>
        If both <var>term<sub>1</sub></var> and <var>term<sub>2</sub></var> are <a>well-formed cdt:Map literals</a>, then the result of this function is determined by the following algorithm.
      </p>
      <div class="algorithm">
        <ol>
          <li>TODO</li>
        </ol>
      </div>

      <p>
        If <var>term<sub>1</sub></var> or <var>term<sub>2</sub></var> is an <a>ill-formed cdt:Map literal</a>, then this function produces an error.
      </p>

    </section>

  </section>


  <section id="list-functions">
    <h2>Functions on Lists</h2>

    <p>
      This section defines <a data-cite="SPARQL11-QUERY#extensionFunctions">SPARQL extension functions</a> specifically for <a>cdt:List literals</a>. These functions can be used in SPARQL expressions for testing values in FILTER clauses and for assigning values in, e.g., BIND clauses and SELECT expressions.
    </p>

    <p>
      Except for <a href="#func_list">cdt:List</a>, these extension functions are evaluated as defined in <a data-cite="SPARQL11-QUERY#invocation">Section&nbsp;17.2.1</a> of [[SPARQL11-QUERY]]. In contrast, <a href="#func_list">cdt:List</a> is a so-called <a data-cite="SPARQL11-QUERY#func-forms">functional form</a> which has specific evaluation rules (as defined in Section&nbsp;<a href="#func_list" class="sectionRef"></a>).
    </p>

    <section id="func_list">
      <h2>cdt:List</h2>

      <p>
        <code><a href="#dfn-cdt-list-literal">cdt:List</a> </code>
        <code style="color:black;font-weight:bold">cdt:List</code>
        (
           <code><a data-cite="SPARQL11-QUERY#expressions">SPARQL expression</a> <var>expr<sub>1</sub></var></code>,
           ...,
           <code><a data-cite="SPARQL11-QUERY#expressions">SPARQL expression</a> <var>expr<sub>|n|</sub></var></code>
        )
      </p>

      <p>
        The result of this function is a <a>cdt:List literal</a> that represents a <a>term list</a>&nbsp;|tm| that contains |n| elements where, for every |i| in {1, ..., |n|}, the element at the |i|-th position of |tm| is constructed as follows. Evaluate the |i|-th expression, <var>expr<sub>|i|</sub></var>, as defined in [[SPARQL11-QUERY]]. If evaluating <var>expr<sub>|i|</sub></var> raises an error, then the element at the |i|-th position of |tm| is <a>null</a>. Otherwise, the element at the |i|-th position of |tm| is the RDF term resulting from the evaluation of <var>expr<sub>|i|</sub></var>.
      </p>
      <p>
        If the function is called without arguments, then the result is a <a>cdt:List literal</a> that represents the <a>empty term list</a>.
      </p>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:List( 'hello', ?x, ?x+1, ?y, &lt;http://example.org/a> )
        </pre>
        <p>
          for the solution mapping <var>&mu;</var>&nbsp;=&nbsp;{?x &rarr; "2"^^xsd:integer} results in the following cdt:List literal.
        </p>
        <pre class="nohighlight">
          "['hello', 2, 3, null, &lt;http://example.org/a>]"^^cdt:List
        </pre>
      </aside>

    </section>

    <section id="func_concat">
      <h2>cdt:concat</h2>

      <p>
        <code><a href="#dfn-cdt-list-literal">cdt:List</a> </code>
        <code style="color:black;font-weight:bold">cdt:concat</code>
        (
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term<sub>1</sub></var></code>,
           ...,
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term<sub>n</sub></var></code>
        )
      </p>

      <p>
        If all arguments (i.e., <var>term<sub>1</sub></var>, ..., <var>term<sub>n</sub></var>) are <a>well-formed cdt:List literals</a>, then the result of this function is a <a>cdt:List literal</a> that represents the <a>term list</a> that is the concatenation of the term lists represented by <var>term<sub>1</sub></var> to <var>term<sub>n</sub></var> (in the order in which these arguments are given). If the function is called without arguments, then the result is a <a>cdt:List literal</a> that represents the <a>empty term list</a>. If the function is called with a single argument and that argument is a well-formed cdt:List literal, then this literal is the result of this function.
      </p>
      <p>
        An error is raised if any of the arguments is not a <a>well-formed cdt:List literal</a>.
      </p>

      <p class="issue">
        We should define the notion of "represents" as used in this definition!
      </p>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:concat( "[1,2,3]"^^cdt:List, "['a',null,'a',2,3]"^^cdt:List )
        </pre>
        <p>
          results in the following cdt:List literal.
        </p>
        <pre class="nohighlight">
          "[1,2,3,'a',null,'a',2,3]"^^cdt:List
        </pre>
      </aside>

    </section>

    <section id="func_contains">
      <h2>cdt:contains</h2>

      <p>
        <code>xsd:boolean </code>
        <code style="color:black;font-weight:bold">cdt:contains</code>
        (
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term<sub>1</sub></var></code>,
           <code><a data-cite="RDF11-CONCEPTS#dfn-rdf-term">RDF term</a> <var>term<sub>2</sub></var></code>
        )
      </p>

      <p>
        If <var>term<sub>1</sub></var> is a <a>well-formed cdt:List literal</a>, then the result of this function is determined as follows. If the <a>term list</a> represented by <var>term<sub>1</sub></var> contains an <a data-cite="RDF11-CONCEPTS#dfn-rdf-term">RDF term</a> <var>term'</var> such that evaluating the SPARQL expression <var>term'</var> = <var>term<sub>2</sub></var> results in `true`, then the result of this function is `true`. If the term map does not contain such an RDF term, then the result of this function is `false`.
      </p>
      <p>
        An error is raised if <var>term<sub>1</sub></var> is not a <a>well-formed cdt:List literal</a>.
      </p>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:contains( "[1,2,3]"^^cdt:List, "02"^^xsd:integer )
        </pre>
        <p>
          results in `true`, whereas the expression
        </p>
        <pre class="nohighlight">
          cdt:contains( "[1,2,3]"^^cdt:List, "2" )
        </pre>
        <p>
          results in `false`.
      </aside>

<!--       <div class="issue" data-number="17"></div> -->
      <div class="issue">
        What about bnodes? See <a href="https://github.com/hartig/SPARQL-CDTs/issues/17">#17</a>.
        <pre class="nohighlight">
        SELECT * WHERE {
          BIND("[_:b,2]"^^cdt:List AS ?list)
          BIND( cdt:head(?list) AS ?elmt)
          BIND( cdt:contains(?list,?elmt) AS ?result)
        }
        </pre>
      </div>

    </section>

    <section id="func_get">
      <h2>cdt:get</h2>

      <p>
        <code><a data-cite="RDF11-CONCEPTS#dfn-rdf-term">RDF term</a> </code>
        <code style="color:black;font-weight:bold">cdt:get</code>
        (
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term</var></code>,
           <code>xsd:integer <var>idx</var></code>
        )
      </p>

      <p>
        If <var>term</var> is a <a>well-formed cdt:List literal</a>, the value of <var>idx</var> is greater than 0 (zero) and smaller or equal than the number of elements of the <a>term list</a> represented by <var>term</var>, and the element at the <var>idx</var>-th position of the term list represented by <var>term</var> is an <a data-cite="RDF11-CONCEPTS#dfn-rdf-term">RDF term</a> (i.e., not <a>null</a>), then the result of this function is that RDF term at the <var>idx</var>-th position of the term list represented by <var>term</var>. In all other cases an error is raised.
      </p>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:get( "[&lt;http://example.org/a>, &lt;http://example.org/b>]"^^cdt:List, 2 )
        </pre>
        <p>
          results in the IRI `http://example.org/b`.
      </aside>

      <div class="note">
        By its definition as given above, <code>cdt:get</code> raises an error not only if the given cdt:List literal is not well-formed but also in the following cases:
        <ul>
          <li>if <var>term</var> is a well-formed cdt:List literal that represents the <a>empty term list</a>,</li>
          <li>if the value of <var>idx</var> is out of the bounds of the term list represented by <var>term</var>, and</li>
          <li>if the element at the <var>idx</var>-th position of the term list represented by <var>term</var> is <a>null</a>.</li>
        </ul>
      </div>

      <p class="note">
        This function uses a 1-based numbering scheme to address the elements in term maps (i.e., the first element of a term map is addressed by an |idx| value of 1), in contrast to a 0-based numbering scheme which is common for addressing elements of arrays in many programming languages. The reason for using 1-based numbering for this function is to remain consistent with existing build-in functions of SPARQL, which are also 1-based (e.g., <a data-cite="SPARQL11-QUERY#func-substr">substr</a> for string literals). Moreover, the 1-based numbering scheme is also used by functions of other W3C languages such as XPath (see, e.g., the XPath <a data-cite="XPATH-FUNCTIONS#func-array-get">array:get</a> function which is similar to cdt:get).
      </p>

    </section>

    <section id="func_head">
      <h2>cdt:head</h2>

      <p>
        <code><a data-cite="RDF11-CONCEPTS#dfn-rdf-term">RDF term</a> </code>
        <code style="color:black;font-weight:bold">cdt:head</code>
        (
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term</var></code>
        )
      </p>

      <p>
        If <var>term</var> is a <a>well-formed cdt:List literal</a>, the <a>term list</a> represented by <var>term</var> contains at least one element, and the element at the first position of this term list is an <a data-cite="RDF11-CONCEPTS#dfn-rdf-term">RDF term</a> (i.e., not <a>null</a>), then the result of this function is that RDF term. In all other cases an error is raised.
      </p>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:head( "[&lt;http://example.org/a>, &lt;http://example.org/b>]"^^cdt:List )
        </pre>
        <p>
          results in the IRI `http://example.org/a`.
      </aside>

      <div class="note">
        By its definition as given above, <code>cdt:head</code> raises an error not only if the given cdt:List literal is not well-formed but also in the following cases:
        <ul>
          <li>if <var>term</var> is a well-formed cdt:List literal that represents the <a>empty term list</a>, and</li>
          <li>if the element at the first position of the term list represented by <var>term</var> is <a>null</a>.</li>
        </ul>
      </div>
    </section>

    <section id="func_reverse">
      <h2>cdt:reverse</h2>

      <p>
        <code><a href="#dfn-cdt-list-literal">cdt:List</a> </code>
        <code style="color:black;font-weight:bold">cdt:reverse</code>
        (
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term</var></code>
        )
      </p>

      <p>
        If <var>term</var> is a <a>well-formed cdt:List literal</a>, then the result of this function is a <a>cdt:List literal</a> that represents the <a>term list</a> that contains all elements of the term list represented by <var>term</var>, in the reverse order (e.g., the first element of the term list of <var>term</var> becomes the last element of the term list represented by the resulting cdt:List literal). This definition implies that
      </p>
      <ul>
        <li>if the term list of <var>term</var> consists of a single element, then the resulting cdt:List literal represents the same term list (with the same element), and</li>
        <li>if <var>term</var> represents the <a>empty term list</a>, then the resulting cdt:List literal also represents the empty term list.</li>
      </ul>
      <p>
        An error is raised if <var>term</var> is not a <a>well-formed cdt:List literal</a>.
      </p>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:reverse( "['a',2,null,4]"^^cdt:List )
        </pre>
        <p>
          results in the following cdt:List literal.
        </p>
        <pre class="nohighlight">
          "[4,null,2,'a']"^^cdt:List
        </pre>
      </aside>

    </section>

    <section id="func_size">
      <h2>cdt:size</h2>

      <p>
        <code>xsd:integer </code>
        <code style="color:black;font-weight:bold">cdt:size</code>
        (
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term</var></code>
        )
      </p>

      <p>
        If <var>term</var> is a <a>well-formed cdt:List literal</a>, then the result of this function is the number of elements that the <a>term list</a> represented by <var>term</var> contains.
      </p>
      <p>
        An error is raised if <var>term</var> is not a <a>well-formed cdt:List literal</a>.
      </p>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:size( "[1,'a','a',4]"^^cdt:List )
        </pre>
        <p>
          results in a literal with the datatype IRI `xsd:integer` and the value 4.
        </p>
      </aside>

    </section>

    <section id="func_subseq">
      <h2>cdt:subseq</h2>

      <p>
        <code><a href="#dfn-cdt-list-literal">cdt:List</a> </code>
        <code style="color:black;font-weight:bold">cdt:subseq</code>
        (
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term</var></code>,
           <code>xsd:integer <var>idx</var></code>
        )
      </p>

      <p>
        <code><a href="#dfn-cdt-list-literal">cdt:List</a> </code>
        <code style="color:black;font-weight:bold">cdt:subseq</code>
        (
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term</var></code>,
           <code>xsd:integer <var>idx</var></code>,
           <code>xsd:integer <var>length</var></code>
        )
      </p>

      <p>
        If <var>term</var> is a <a>well-formed cdt:List literal</a>, then the result of this function is determined as follows. Let |tm| be the <a>term list</a> represented by <var>term</var> and let |n| be the number of elements contained in |tm|.
      </p>
      <ul>
        <li>If the value of <var>idx</var> is greater than 0 (zero) and smaller than |n|+1, and <var>length</var> is not given, then the result of this function is a <a>cdt:List literal</a> that represents the term list that is the sub-sequence of |tm|, starting with the element at the |idx|-th position of |tm| and ending with the last element of |tm|.</li>
        <li>If the value of <var>idx</var> is greater than 0 (zero) and smaller than |n|+1, and the value of <var>length</var> is greater than 0 (zero) and smaller than |n|&minus;|idx|+1, then the result of this function is a <a>cdt:List literal</a> that represents the term list that is the sub-sequence of |tm|, starting with the element at the |idx|-th position of |tm| and ending with the element at position |idx|+|length|&minus;1 of |tm|.</li>
        <li>If the value of <var>idx</var> is greater than 0 (zero) and smaller than |n|+1, and the value of <var>length</var> is 0 (zero), then the result of this function is a <a>cdt:List literal</a> that represents the <a>empty term list</a>.</li>
        <li>If the value of <var>idx</var> is equal to |n|+1, and either <var>length</var> is not given or the value of <var>length</var> is 0 (zero), then the result of this function is a <a>cdt:List literal</a> that represents the <a>empty term list</a>.</li>
      </ul>
      <p>
        In all other cases an error is raised, including the case that <var>term</var> is not a <a>well-formed cdt:List literal</a>.
      </p>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:subseq( "['a',2,null,4]"^^cdt:List, 2 )
        </pre>
        <p>
          results in the following cdt:List literal.
        </p>
        <pre class="nohighlight">
          "[2,null,4]"^^cdt:List
        </pre>
      </aside>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:subseq( "['a',2,null,4]"^^cdt:List, 2, 2 )
        </pre>
        <p>
          results in the following cdt:List literal.
        </p>
        <pre class="nohighlight">
          "[2,null]"^^cdt:List
        </pre>
      </aside>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:subseq( "['a',2,null,4]"^^cdt:List, 2, 0 )
        </pre>
        <p>
          results in the following cdt:List literal.
        </p>
        <pre class="nohighlight">
          "[]"^^cdt:List
        </pre>
      </aside>

      <p class="note">
        As the <a href="#func_get">`cdt:get`</a> function, this function uses a 1-based numbering scheme to address the elements in term maps (i.e., the first element of a term map is addressed by an |idx| value of 1) in order to be consistent with existing build-in functions of SPARQL (e.g., <a data-cite="SPARQL11-QUERY#func-substr">substr</a>) and with functions in other W3C languages such as XPath (e.g., <a data-cite="XPATH-FUNCTIONS#func-array-subarray">array:subarray</a>).
      </p>

      <p class="note">
        This function corresponds to the XPath <a data-cite="XPATH-FUNCTIONS#func-array-subarray">array:subarray</a> function and, for the sake of consistency, is defined using the same rules and error conditions. As a consequence, the following special case of arguments is permitted for this function. For term maps with a size |n|>0, it is permitted to call the function with an <var>idx</var> value equal to |n|+1 as long as the value of <var>length</var> is 0 or <var>length</var> is omitted. When doing so, the result is a <a>cdt:List literal</a> that represents the <a>empty term list</a>.
      </p>

    </section>

    <section id="func_tail">
      <h2>cdt:tail</h2>

      <p>
        <code><a href="#dfn-cdt-list-literal">cdt:List</a> </code>
        <code style="color:black;font-weight:bold">cdt:tail</code>
        (
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term</var></code>
        )
      </p>

      <p>
        If <var>term</var> is a <a>well-formed cdt:List literal</a> and the <a>term list</a> represented by <var>term</var> contains at least one element, then the result of this function is a <a>cdt:List literal</a> that represents the <a>term list</a> that contains all but the first element of the term list represented by <var>term</var>, where the remaining elements are kept in the same order. This definition implies that, if the term list of <var>term</var> consists of a single element, the resulting cdt:List literal must represent the <a>empty term list</a>.
      </p>
      <p>
        An error is raised if <var>term</var> is not a well-formed cdt:List literal or if it is a well-formed cdt:List literal that represents the empty term list.
      </p>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:tail( "['a',2,null,4]"^^cdt:List )
        </pre>
        <p>
          results in the following cdt:List literal.
        </p>
        <pre class="nohighlight">
          "[2,null,4]"^^cdt:List
        </pre>
      </aside>

    </section>

  </section>


  <section id="map-functions">
    <h2>Functions on Maps</h2>

    <p>TODO</p>

  </section>


  <section id="fold">
    <h2>FOLD</h2>

    <p>TODO (FOLD is a <a data-cite="SPARQL11-QUERY#setFunctions">SPARQL set function</a>)<p>

  </section>


  <section id="unfold">
    <h2>UNFOLD</h2>

    <p>
      This section defines an extension of the SPARQL language that adds a new operator called UNFOLD. As illustrated in Section&nbsp;<a href="#description-of-unfold" class="sectionRef"></a>, this operator can be used to transform composite values (given in the form of <a>cdt:List literals</a> or <a>cdt:Map literals</a>) into their individual components and assigns these components separately to new query variables.
    </p>

    <p>
      In particular, recall from Section&nbsp;<a href="#description-of-unfold" class="sectionRef"></a> that there are two variations of this operator: one that assigns a single new query variable (i.e., `UNFOLD(expr AS ?v1)`) and another one that assigns two new query variables (i.e., `UNFOLD(expr AS ?v1, ?v2)`).
      When applied to <a>cdt:List literals</a>, the one-variable version binds the new variable to each of the RDF terms in the corresponding <a>term list</a> (or leaves it unbound for <a>null</a> values) and the two-variables version binds the first new variable to each RDF term in the term list (or leaves it unbound for null values) and the second variable to the corresponding position of the term/null in the list.
      When applied to <a>cdt:Map literals</a>, the one-variable version binds the variable to each of the keys in the <a>term map</a> and the two-variables version binds the first variable to each key in the term map and the second variable to the corresponding value (or leaves it unbound for null values).
    </p>

    <p class="note">
      Note that there is an asymmetry between the two-variables version of UNFOLD for cdt:List literals and the two-variables version for cdt:Map literals. In the case of maps, the values are assigned to the second variable whereas, for lists, the values (the list elements) are assigned to the first variable.
      <br/><br/>
      While it would be possible to eliminate this asymmetry by changing the two-variables version of UNFOLD for cdt:List literals such that the list elements are assigned to the second variable (and the positions to the first variable), doing so would introduce another asymmetry: This asymmetry would then be between the so-changed two-variables version and the one-variable version of UNFOLD for cdt:List literals, because the latter binds the first (and, in this case, only) variable to the values. A follow-up change to eliminate this asymmetry as well may be to define the one-variable version such that it assigns the (single) variable to the positions and not to the list elements. However, this definition would have a very limited practical value and, thus, the initially mentioned asymmetry is considered as the best possible compromise.
    </p>

    <p>
      Adding this new UNFOLD operator to the language requires an extension to the grammar of SPARQL, an extension of the SPARQL algebra, and corresponding extensions both of the process of converting SPARQL graph patterns into SPARQL algebra expressions and of the evaluation semantics. The following sections define these extensions.
    </p>

    <section id="unfold-grammar">
      <h2>Grammar</h2>

      <p>
        Adding the UNFOLD operator to SPARQL requires the following extension of the <a data-cite="SPARQL11-QUERY#rGraphPatternNotTriples">`GraphPatternNotTriples`</a> production of the <a data-cite="SPARQL11-QUERY#sparqlGrammar">SPARQL grammar</a>. The part in which the extended production differs from the corresponding production in the original grammar is marked in bold font. The second production defined below (i.e., <a href="#rUnfold">`Unfold`</a>) needs to be added and has no counterpart in the original grammar. The given production rules use several symbols for which no production rule is provided below (e.g., <a data-cite="SPARQL11-QUERY#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a>, <a data-cite="SPARQL11-QUERY#rExpression">Expression</a>); the production rules for these symbols are defined as given in the original SPARQL grammar.
      </p>

      <table class="grammar">

        <tr id="rGraphPatternNotTriples">
          <td>[56+]</td>
          <td>`GraphPatternNotTriples`</td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <a data-cite="SPARQL11-QUERY#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a>
            `|`
            <a data-cite="SPARQL11-QUERY#rOptionalGraphPattern">OptionalGraphPattern</a>
            `|`
            <a data-cite="SPARQL11-QUERY#rMinusGraphPattern">MinusGraphPattern</a>
            `|`
            <a data-cite="SPARQL11-QUERY#rGraphGraphPattern">GraphGraphPattern</a>
            `|`
            <a data-cite="SPARQL11-QUERY#rServiceGraphPattern">ServiceGraphPattern</a>
            `|`
            <a data-cite="SPARQL11-QUERY#rFilter">Filter</a>
            `|`
            <a data-cite="SPARQL11-QUERY#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a>
            `|`
            <a data-cite="SPARQL11-QUERY#rBind">Bind</a>
            `|`
            <a data-cite="SPARQL11-QUERY#rInlineData">InlineData</a>
            <strong>
            `|`
            <a href="#rUnfold">Unfold</a>
            </strong>
          </td>
        </tr>

        <tr id="rUnfold">
          <td>[174]</td>
          <td>`Unfold`</td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <code class="token">'UNFOLD'</code>
            <code class="token">'('</code>
            <a data-cite="SPARQL11-QUERY#rExpression">Expression</a>
            <code class="token">'AS'</code>
            <a data-cite="SPARQL11-QUERY#rVar">Var</a>
            `(`
            <code class="token">','</code>
            <a data-cite="SPARQL11-QUERY#rVar">Var</a>
            `)?`
            <code class="token">')'</code>
          </td>
        </tr>

      </table>

      <p>
        Two additional constraints MUST be satisfied when using the UNFOLD operator:
      </p>
      <ol>
        <li>
          For every expression of the form `UNFOLD(expr AS v, v')`, `v` and `v'` MUST be two different variables.
        </li>
        <li>
          Second, the variable(s) assigned in an UNFOLD operator must not be already in use; more formally:
        </li>
        <ul>
          <li>For every expression of the form `UNFOLD(expr AS v)`, the variable `v` MUST NOT be <a data-cite="SPARQL11-QUERY#variableScope">in-scope</a> from the preceding elements in the group graph pattern in which the expression is used.</li>
          <li>For every expression of the form `UNFOLD(expr AS v, v')`, the variable `v` MUST NOT be <a data-cite="SPARQL11-QUERY#variableScope">in-scope</a> from the preceding elements in the group graph pattern in which the expression is used, and the same holds for the variable `v'`.</li>
        </ul>
      </ol>

      <p>
        The notion of in-scope variables as used in the second constraint is defined in <a data-cite="SPARQL11-QUERY#variableScope">Section&nbsp;18.2.1</a> of [[SPARQL11-QUERY]]. When using the extended syntax with the UNFOLD operator, this notion must be extended as well. To capture this extension formally, the table in <a data-cite="SPARQL11-QUERY#variableScope">Section&nbsp;18.2.1</a> of [[SPARQL11-QUERY]] is augmented with the following two additional rows.
      </p>
      <table class="inscope">
        <tr>
          <th>Syntax Form</th>
          <th>In-scope variables</th>
        </tr>
        <tr>
          <td>`UNFOLD(expr AS v)` </td>
          <td style="padding-left: 30px;"> `v` is in-scope</td>
        </tr>
        <tr style="padding-left: 30px;">
          <td>`UNFOLD(expr AS v, v')` </td>
          <td> `v` and `v'` are in-scope</td>
        </tr>
      </table>

    </section>

    <section id="unfold-translation">
      <h2>Translation to the Algebra</h2>

      <p>
        Based on the SPARQL grammar, the SPARQL specification <q>defines the process of converting graph patterns and solution modifiers in a SPARQL query string into a SPARQL algebra expression</q> (see <a data-cite="SPARQL11-QUERY#sparqlQuery">Section&nbsp;18.2</a> of [[SPARQL11-QUERY]]). This process must be adapted to consider UNFOLD clauses as added by the extended grammar introduced above. In particular, the step of translating group graph patterns (<a data-cite="SPARQL11-QUERY#rGroupGraphPattern">GroupGraphPattern</a>) during this process needs to be extended. The original algorithm that defines this translation is given in <a data-cite="SPARQL11-QUERY#sparqlTranslateGraphPatterns">Section&nbsp;18.2.2.6</a> of [[SPARQL11-QUERY]]. The extended version of the algorithm is given as follows, where the parts that are added to cover the UNFOLD operator are marked in bold font.
      </p>
      <div style="width: 100%; border: 1px solid; padding: 5px">
        <pre class="nohighlight" style="margin: 0px">
Let G := the empty pattern, a basic graph pattern which is the empty set.

For each element E in the GroupGraphPattern

    If E is of the form OPTIONAL{P}
        Let A := Translate(P)
        If A is of the form Filter(F, A2)
            G := LeftJoin(G, A2, F)
        Else
            G := LeftJoin(G, A, true)
            End
        End

    If E is of the form MINUS{P}
        G := Minus(G, Translate(P))
        End

    If E is of the form BIND(expr AS var)
        G := Extend(G, var, expr)
        End
        </pre>

        <pre class="nohighlight" style="margin: 0px;
                                        font-weight: bold;
                                        padding-left: 4ch;
                                        padding-top: 3ex;
                                        padding-bottom: 3ex;">
    If E is of the form UNFOLD(expr AS var)
        G := Unfold1(G, var, expr)
        End

    If E is of the form UNFOLD(expr AS var1, var2)
        G := Unfold2(G, var1, var2, expr)
        End
        </pre>
        <pre class="nohighlight" style="margin: 0px">
    If E is any other form
        Let A := Translate(E)
        G := Join(G, A)
        End

   End

The result is G.
        </pre>
      </div>

      <p>
        Notice that the extended algorithm uses two new algebra symbols: `Unfold1` and `Unfold2`. Hence, to use this algorithm, the list of symbols in the SPARQL algebra (as given in the second table of <a data-cite="SPARQL11-QUERY#sparqlQuery">Section&nbsp;18.2</a> [[SPARQL11-QUERY]]) needs to be extended by adding these two symbols. The evaluation semantics of algebra expressions that contain any of these two symbols is defined in the following.
      </p>

    </section>

    <section id="unfold-algebra">
      <h2>Algebra</h2>

      <p>
        This section defines operators for evaluating the two new algebra symbols (as <a data-cite="SPARQL11-QUERY#sparqlAlgebra">Section&nbsp;18.5</a> of [[SPARQL11-QUERY]] does for the standard SPARQL algebra symbols). These operators have the same name as the algebra symbols and shall be used in the following section to extend the evaluation semantics of algebra expressions that may contain the two new algebra symbols.
      </p>

      <p>
        The operator for evaluating `Unfold1` is defined as follows.
      </p>

      <div class="defn">
        <p><b>Definition: <dfn id="dfn-Unfold1" style="font-style:normal">Unfold1</dfn></b></p>
        <p>
          Let <var>&mu;</var> be a <a data-cite="SPARQL11-QUERY#defn_sparqlSolutionMapping">solution mapping</a>, |var| be a <a data-cite="SPARQL11-QUERY#defn_QueryVariable">variable</a>, and |expr| be an <a data-cite="SPARQL11-QUERY#expressions">expression</a>.
          <br/>
          Then, Unfold1(<var>&mu;</var>, |var|, |expr|) is a multiset of solution mappings that is defined as follows:
        </p>
        <ul>
          <li>
            If |var|&nbsp;&notin;&nbsp;dom(<var>&mu;</var>) and |expr|(<var>&mu;</var>) is a <a>well-formed cdt:List literal</a>, then
            <ul>
              <li>
                Unfold1(<var>&mu;</var>, |var|, |expr|) = { <var>&mu;</var> | |L| contains <a>null</a> } &cup; <var>&Omega;'</var>, where
                <br/>&nbsp; &nbsp; |L| is the <a>term list</a> represented by the cdt:List literal |expr|(<var>&mu;</var>) and
                <br/>&nbsp; &nbsp; <var>&Omega;'</var> = { <var>&mu;</var> &cup; (|var|, |term|) | |term| is an RDF term in |L| },
              </li>
              <li>
                card[Unfold1(<var>&mu;</var>, |var|, |expr|)](<var>&mu;'</var>) = 0 for every <var>&mu;'</var>&nbsp;&ne;&nbsp;<var>&mu;</var> and <var>&mu;'</var>&nbsp;&notin;&nbsp;<var>&Omega;'</var>,
              </li>
              <li>
                card[Unfold1(<var>&mu;</var>, |var|, |expr|)](<var>&mu;'</var>) is the number of <a>null</a> values in |L| if <var>&mu;'</var>&nbsp;=&nbsp;<var>&mu;</var>, and
              </li>
              <li>
                card[Unfold1(<var>&mu;</var>, |var|, |expr|)](<var>&mu;'</var>) is the number of times the RDF term <var>&mu;'</var>(|var|) is contained in |L| if <var>&mu;'</var>&nbsp;&isin;&nbsp;<var>&Omega;'</var>.
              </li>
            </ul>
          </li>
          <li>
            If |var|&nbsp;&notin;&nbsp;dom(<var>&mu;</var>) and |expr|(<var>&mu;</var>) is a <a>well-formed cdt:Map literal</a>, then
            <ul>
              <li>
                Unfold1(<var>&mu;</var>, |var|, |expr|) = { <var>&mu;</var> &cup; (|var|, |key|) | |key| is the <a>key</a> of a <a>map entry</a> in |M| }, where
                <br/>&nbsp; &nbsp; |M| is the <a>term map</a> represented by the cdt:Map literal |expr|(<var>&mu;</var>),
              </li>
              <li>
                card[Unfold1(<var>&mu;</var>, |var|, |expr|)](<var>&mu;'</var>) = 1 for every <var>&mu;'</var>&nbsp;&isin;&nbsp;Unfold1(<var>&mu;</var>, |var|, |expr|), and
              </li>
              <li>
                card[Unfold1(<var>&mu;</var>, |var|, |expr|)](<var>&mu;'</var>) = 0 for every <var>&mu;'</var>&nbsp;&notin;&nbsp;Unfold1(<var>&mu;</var>, |var|, |expr|).
              </li>
            </ul>
          </li>
          <li>
            If |var| &notin; dom(<var>&mu;</var>) and |expr|(<var>&mu;</var>) is an error or an RDF term that is neither a well-formed cdt:List literal nor a well-formed cdt:Map literal, then
            <ul>
              <li>
                Unfold1(<var>&mu;</var>, |var|, |expr|) = {<var>&mu;</var>},
              </li>
              <li>
                card[Unfold1(<var>&mu;</var>, |var|, |expr|)](<var>&mu;'</var>) = 1 if <var>&mu;'</var>&nbsp;=&nbsp;<var>&mu;</var>, and
              </li>
              <li>
                card[Unfold1(<var>&mu;</var>, |var|, |expr|)](<var>&mu;'</var>) = 0 for every <var>&mu;'</var>&nbsp;&ne;&nbsp;<var>&mu;</var>.
              </li>
            </ul>
          </li>
          <li>
            If |var| &isin; dom(<var>&mu;</var>), then Unfold1(<var>&mu;</var>, |var|, |expr|) is undefined.
          </li>
        </ul>

        <p>
          Let <var>&Omega;</var> a multiset of solution mappings. We define:
          <br/>
          Unfold1(<var>&Omega;</var>, |var|, |expr|) = &#x22C3;<sub><var>&mu;</var> &isin; <var>&Omega;</var></sub> Unfold1(<var>&mu;</var>, |var|, |expr|)
        </p>
      </div>

      <p class="note">
        By the given definition , for cases in which |var|&nbsp;&notin;&nbsp;dom(<var>&mu;</var>) and |expr|(<var>&mu;</var>) is a well-formed cdt:List literal that represents the <a>empty term list</a>, <a>Unfold1</a>(<var>&mu;</var>, |var|, |expr|) is the empty multiset of solution mappings. Similarly, if |var|&nbsp;&notin;&nbsp;dom(<var>&mu;</var>) and |expr|(<var>&mu;</var>) is a well-formed cdt:Map literal that represents the <a>empty term map</a>, then <a>Unfold1</a>(<var>&mu;</var>, |var|, |expr|) is also the empty multiset.
      </p>

      <p>
        The operator for evaluating `Unfold2` is defined as follows.
      </p>

      <div class="defn">
        <p><b>Definition: <dfn id="dfn-Unfold2" style="font-style:normal">Unfold2</dfn></b></p>

          Let <var>&mu;</var> be a <a data-cite="SPARQL11-QUERY#defn_sparqlSolutionMapping">solution mapping</a>, <var>var<sub>1</sub></var> and <var>var<sub>2</sub></var> be two different <a data-cite="SPARQL11-QUERY#defn_QueryVariable">variables</a>, and |expr| be an <a data-cite="SPARQL11-QUERY#expressions">expression</a>.
          <br/>
          Then, Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|) is a multiset of solution mappings that is defined as follows:
        </p>
        <ul>
          <li>
            If <var>var<sub>1</sub></var>&nbsp;&notin;&nbsp;dom(<var>&mu;</var>), <var>var<sub>2</sub></var>&nbsp;&notin;&nbsp;dom(<var>&mu;</var>), and |expr|(<var>&mu;</var>) is a <a>well-formed cdt:List literal</a> such that the <a>term list</a>&nbsp;|L| represented by this literals is a nonempty, then
            <ul>
              <li>
                Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|) = { <var>&mu;</var> &cup; <var>&mu;<sub>|i|</sub></var> &cup; (<var>var<sub>2</sub></var>, |i|) | 1 &le; |i| &le; |n| }, where
                <br/>&nbsp; &nbsp; <var>&mu;<sub>|i|</sub></var> is the empty solution mapping if the element at the |i|-th position of |L| is <a>null</a>,
                <br/>&nbsp; &nbsp; otherwise, <var>&mu;<sub>|i|</sub></var> = (<var>var<sub>1</sub></var>, |term|) where |term| is element at the |i|-th position of |L|, and
                <br/>&nbsp; &nbsp; |n| is the number of elements in |L|,
              </li>
              <li>
                card[Unfold1(<var>&mu;</var>, |var|, |expr|)](<var>&mu;'</var>) = 1 for every <var>&mu;'</var>&nbsp;&isin;&nbsp;Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|), and
              </li>
              <li>
                card[Unfold1(<var>&mu;</var>, |var|, |expr|)](<var>&mu;'</var>) = 0 for every <var>&mu;'</var>&nbsp;&notin;&nbsp;Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|).
              </li>
            </ul>
          </li>
          <li>
            If <var>var<sub>1</sub></var>&nbsp;&notin;&nbsp;dom(<var>&mu;</var>), <var>var<sub>2</sub></var>&nbsp;&notin;&nbsp;dom(<var>&mu;</var>), and |expr|(<var>&mu;</var>) is a <a>well-formed cdt:List literal</a> that represents the <a>empty term list</a>, then Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|) is the empty multiset.
          </li>
          <li>
            If <var>var<sub>1</sub></var>&nbsp;&notin;&nbsp;dom(<var>&mu;</var>), <var>var<sub>2</sub></var>&nbsp;&notin;&nbsp;dom(<var>&mu;</var>), and |expr|(<var>&mu;</var>) is a <a>well-formed cdt:Map literal</a>, then
            <ul>
              <li>
                Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|) = { <var>&mu;</var> &cup; (<var>var<sub>1</sub></var>, |k|) &cup; <var>&mu;<sub>|v|</sub></var> | (|k|,|v|) is a <a>map entry</a> in |M| }, where
                <br/>&nbsp; &nbsp; <var>&mu;<sub>|v|</sub></var> is the empty solution mapping if |v| is <a>null</a>, otherwise, <var>&mu;<sub>|v|</sub></var> = (<var>var<sub>2</sub></var>, |v|), and
                <br/>&nbsp; &nbsp; |M| is the <a>term map</a> represented by the cdt:Map literal |expr|(<var>&mu;</var>),
              </li>
              <li>
                card[Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|)](<var>&mu;'</var>) = 1 for every <var>&mu;'</var>&nbsp;&isin;&nbsp;Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|),
              </li>
              <li>
                card[Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|)](<var>&mu;'</var>) = 0 for every <var>&mu;'</var>&nbsp;&notin;&nbsp;Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|).
              </li>
            </ul>
          </li>
          <li>
            If <var>var<sub>1</sub></var>&nbsp;&notin;&nbsp;dom(<var>&mu;</var>), <var>var<sub>2</sub></var>&nbsp;&notin;&nbsp;dom(<var>&mu;</var>), and |expr|(<var>&mu;</var>) is an error or an RDF term that is neither a well-formed cdt:List literal nor a well-formed cdt:Map literal, then
            <ul>
              <li>
                Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|) = {<var>&mu;</var>},
              </li>
              <li>
                card[Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|)](<var>&mu;'</var>) = 1 if <var>&mu;'</var>&nbsp;=&nbsp;<var>&mu;</var>, and
              </li>
              <li>
                card[Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|)](<var>&mu;'</var>) = 0 for every <var>&mu;'</var>&nbsp;&ne;&nbsp;<var>&mu;</var>.
              </li>
            </ul>
          </li>
          <li>
            If <var>var<sub>1</sub></var>&nbsp;&isin;&nbsp;dom(<var>&mu;</var>) or <var>var<sub>2</sub></var>&nbsp;&isin;&nbsp;dom(<var>&mu;</var>), then Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|) is undefined.
          </li>
        </ul>

        <p>
          Let <var>&Omega;</var> a multiset of solution mappings. We define:
          <br/>
          Unfold2(<var>&Omega;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|) = &#x22C3;<sub><var>&mu;</var> &isin; <var>&Omega;</var></sub> Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|)
        </p>
      </div>

      <p class="note">
        While the given definition captures the case of cdt:List literals with the empty term list explicitly (see the second main bullet point in the definition), the case of cdt:Map literals with the <a>empty term map</a> are captured implicitly as part of the third main bullet point. In this case, the result of <a>Unfold2</a>(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|) is also the empty multiset of solution mappings.
      </p>

    </section>

    <section id="unfold-semantics">
      <h2>Evaluation Semantics</h2>

      <p>
        The SPARQL specification defines a function <q>eval(D(G), algebra expression) as the evaluation of an algebra expression with respect to a dataset D having active graph G</q> (see <a data-cite="SPARQL11-QUERY#sparqlAlgebraEval">Section&nbsp;18.6</a> of [[SPARQL11-QUERY]]). The definition of this function is recursive. To cover algebra expressions that may contain the two new algebra symbols (`Unfold1` and `Unfold2`) the definition of this function needs to be extended with the following two additional cases.
      </p>

      <div class="defn">
        <p><b>Definition: <dfn id="dfn-evalUnfold" style="font-style:normal">Evaluation of Unfold1</dfn></b></p>
        <p>
          eval(D(G), `Unfold1(`<var style="font-style: normal">`P`</var>, <var style="font-style: normal">`var`</var>, <var style="font-style: normal">`expr`</var>`)`) = <a>Unfold1</a>(eval(D(G), <var style="font-style: normal">`P`</var>), <var style="font-style: normal">`var`</var>, <var style="font-style: normal">`expr`</var>)
        </p>
      </div>

      <div class="defn">
        <p><b>Definition: <dfn id="dfn-evalUnfold2" style="font-style:normal">Evaluation of Unfold2</dfn></b></p>
        <p>
          eval(D(G), `Unfold2(`<var style="font-style: normal">`P`</var>, <var style="font-style: normal">`var1`</var>, <var style="font-style: normal">`var2`</var>, <var style="font-style: normal">`expr`</var>`)`) = <a>Unfold2</a>(eval(D(G), <var style="font-style: normal">`P`</var>), <var style="font-style: normal">`var1`</var>, <var style="font-style: normal">`var2`</var>, <var style="font-style: normal">`expr`</var>)
        </p>
      </div>

    </section>

  </section>


  <section class="appendix informative">
    <h2>IANA Considerations</h2>

    <p>TODO</p>

  </section>


  <section class="appendix informative">
    <h2>Mapping Between cdt:List Literals and RDF Lists</h2>

    <p>TODO</p>

  </section>

  <section class="appendix">
    <h2>Complete EBNF Grammars</h2>

    <section class="appendix informative" id="cdt-ebnf">
      <h2>Composite Datatypes EBNF Grammar</h2>
      <p>
        The following is a complete grammar for composite datatype literals (i.e., literals that conform either to the <a>cdt:List datatype</a> or to the <a>cdt:Map datatype</a>). The EBNF used here is defined in XML 1.0 [[EBNF-NOTATION]].
      </p>
      <div data-include="../ebnf/cdt-literals.html"></div>
    </section>

    <section class="appendix informative" id="sparql-cdt-ebnf">
      <h2>SPARQL-CDT EBNF Grammar</h2>
      <p>
        The following is a complete grammar for the SPARQL language with the extensions for composite datatype literals as defined in this document. The EBNF used here is defined in XML 1.0 [[EBNF-NOTATION]].
      </p>
      <div data-include="../ebnf/sparql-cdt.html"></div>
    </section>

  </section>

<!--   <section class="appendix informative" id="issue-summary"> -->
    <!-- A list of issues will magically appear here -->
<!--   </section> -->

</body>
</html>

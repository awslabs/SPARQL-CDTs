<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!--   <title>Composite Datatype Literals in RDF and SPARQL</title> -->
  <title>SPARQL CDTs: Representing and Querying Lists and Maps as RDF Literals</title>
  <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>
  <script class="remove">
   // All config options at https://respec.org/docs/
   var respecConfig = {
      specStatus: "unofficial",
      edDraftURI: "https://w3id.org/awslabs/neptune/SPARQL-CDTs/spec/editors_draft.html",
      latestVersion: "https://w3id.org/awslabs/neptune/SPARQL-CDTs/spec/latest.html",
      testSuiteURI: "https://github.com/awslabs/SPARQL-CDTs/tree/main/tests",
//       implementationReportURI:"https://w3c.github.io/rdf-star/reports/",
      editors: [
        {
          "name": "Olaf Hartig",
          "url": "http://olafhartig.de/",
          "company": "Amazon",
          "companyURL": "https://amazon.com/",
          "orcid": "0000-0002-1741-2090",
          "w3cid": 112469,
        },
        {
          "name": "Gregory Todd Williams",
          "url": "https://kasei.us/",
          "company": "Amazon",
          "companyURL": "https://amazon.com/",
          "w3cid": 38870,
        },
      ],
      github: {
        repoURL: "awslabs/SPARQL-CDTs",
        branch: "main",
      },
      localBiblio: {
        "EBNF-NOTATION": {
          title: "EBNF NOTATION",
          href: "http://www.w3.org/TR/REC-xml/#sec-notation",
          publisher: "W3C",
          date: "26 November 2008",
          status: "W3C Recommendation",
          authors: [
            "Tim Bray",
            "Jean Paoli",
            "C. M. Sperberg-McQueen",
            "Eve Maler",
            "François Yergeau"
          ]
        }
      },
//       wgPublicList: "public-rdf-star",
//       shortName: "rdf-star",
//       group: "rdf-dev",

      xref: ["RDF11-CONCEPTS", "SPARQL11-QUERY", "SPARQL11-UPDATE", "SPARQL11-GSP", "RDF11-MT"],
      maxTocLevel: 3,
    };
    // set publishDate and previousDate in order to make a published draft
    var publishDate = null;
    var previousDate = null;
    if (publishDate !== null && previousDate !== null) {
      var thisVersion = "https://w3c.github.io/rdf-star/cg-spec/" + publishDate + ".html";
      var previousVersion = "https://w3c.github.io/rdf-star/cg-spec/" + previousDate + ".html";
      respecConfig.otherLinks.push({
        key: "This version:",
          data: [
            {
              value: thisVersion,
              href: thisVersion,
            }
          ]
      });
      respecConfig.otherLinks.push({
        key: "Previous version:",
          data: [
            {
              value: previousVersion,
              href: previousVersion,
            }
          ]
      });
      respecConfig.publishDate = publishDate;
      respecConfig.doJsonLd = true;
      respecConfig.canonicalURI = thisVersion;
      window.addEventListener('load', () => {
        document.body.classList.add('no-watermark');
      })
    }
  </script>
  <style>
    /* copied from TR/turtle, and adapted for SPARQL rules */
    .grammar td { font-family: monospace; vertical-align: top; }
    .grammar-literal, .token { color: gray;}
    .grammar_comment { color: #A52A2A; font-style: italic; }

    /* better looking quoted examples */
    .example .example {
      border-left-width: .15em;
    }

    /* better numbering of algorithm steps */
    .algorithm ol {
      counter-reset: numsection;
      list-style-type: none;
    }
    .algorithm ol>li {
      margin: 0.5em 0;
    }
    .algorithm ol>li:before {
      font-weight: bold;
      counter-increment: numsection;
      content: counters(numsection, ".") ") ";
    }

    /* SPARQL modification section */

    .defn	{ 
/*         margin-left:5% ; margin-right: 7%;  */
        margin-top: 0.1ex ; margin-bottom: 0.1ex ;
        border: thin solid #888888;
        padding: 1ex 2ex 0.5ex 2ex ;
        page-break-inside: avoid ;
        background-color: #F0F8F8 ;
    }
    
    div.defn p	{ margin-top: 1ex ; margin-bottom: 1.5ex ;}
    div.defn ul	{ margin-top: 1ex ; margin-bottom: 1.5ex ; }

    .operator {
        border: solid;
        border-width: 1px;
        border-color: #888;
        width: 100%;
        margin: 0px;
    }

    .operator tr {
        border: solid;
        border-color: #888;
        border-width: 1px;
    }
    
    .operator th {
        border: solid;
        border-color: #888;
        border-width: 1px;
        font-weight: bold;
    }

    .operator td {
        border: solid;
        border-color: #888;
        border-width: 1px;
    }

    .inscope {
        border-collapse: collapse;
    }

    .inscope th {
        border: solid;
        border-width: 1px;
        font-weight: bold;
        padding-left:  10px;
        padding-right: 10px;
    }

    .inscope td {
        border: solid;
        border-width: 1px;
        padding-left:  10px;
        padding-right: 10px;
    }

    .sparqlresult {
        border: solid;
        border-width: 1px;
        border-collapse: collapse;
    }

    .sparqlresult th {
        border: solid;
        border-width: 1px;
        font-weight: bold;
        padding-left:  1ex;
        padding-right: 1ex;
    }

    .sparqlresult td {
        border: solid;
        border-width: 1px;
        padding-left:  1ex;
        padding-right: 1ex;
    }
    
    .heavy { color:black; font-weight:bold }
    .small { font-size: smaller; }

    #structure-map table {
      background-image: url("visual-map-bg.svg");
      background-size: 100% 100%;
      background-repeat: no-repeat;
    }

    #structure-map table td {
      width: 33.34%;
    }

    #structure-map .box {
      display: block;
      border: thin solid gray;
      border-radius: 0.5em;
      background-color: white;
      margin: 0.7em 1em;
      padding: 0.35em 0.5em;
      box-shadow: 0.25em 0.25em 0.5em darkgray;
      text-align: center;
    }

    /* remove "unofficial draft" watermark */
    body.no-watermark {
      background: url('https://www.w3.org/StyleSheets/TR/2016/logos/back-cg-draft') no-repeat !important
    }
  </style>
  <script>
    /* copied from JSON-LD specs */
    function updateExample(doc, content) {
      // perform transformations to make it render and prettier
      return _esc(reindent(unComment(doc, content)));
    }

    function _esc(s) {
      return s.replace(/&/g,'&amp;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/</g,'&lt;');
    }

    function reindent(text) {
      // TODO: use trimEnd when Edge supports it
      const lines = text.trimRight().split("\n");
      while (lines.length && !lines[0].trim()) {
        lines.shift();
      }
      const indents = lines.filter(s => s.trim()).map(s => s.search(/[^\s]/));
      const leastIndent = Math.min(...indents);
      return lines.map(s => s.slice(leastIndent)).join("\n");
    }

    function unComment(doc, content) {
      // perform transformations to make it render and prettier
      return content
        .replace(/<!--/, '')
        .replace(/-->/, '')
        .replace(/< !\s*-\s*-/g, '<!--')
        .replace(/-\s*- >/g, '-->')
        .replace(/-\s*-\s*&gt;/g, '--&gt;');
    }
  </script>
</head>
<body>
  <section id="abstract">
    <p>
      This specification defines an approach to represent generic forms of composite values (lists and maps, in particular) as literals in RDF, and corresponding extensions of the SPARQL language. These extensions include an aggregation function to produce such composite values, functions to operate on such composite values in expressions, and a new operator to transform such composite values into their individual components.
    </p>
  </section>
  <section id="sotd">
  </section>

  <section id="introduction">
    <h1>Introduction</h1>

    <section class="informative">
      <h2>Background and Motivation</h2>
      <p>
        The Resource Description Framework (RDF) is a general-purpose framework for representing and exchanging data [[RDF11-PRIMER]], and the SPARQL language is a declarative language for querying and updating RDF data [[SPARQL11-OVERVIEW]].
        Yet, a feature regarding which RDF and SPARQL lag behind other popular data representation forms such as SQL databases and Property Graphs, and their corresponding query languages, is a built-in support for generic types of composite values such as lists, maps, and sets.
        Instead, RDF introduces so-called <a data-cite="RDF11-SCHEMA#ch_containervocab">containers</a> and <a data-cite="RDF11-SCHEMA#ch_collectionvocab">collections</a>, which allow users to model composite values through dedicated vocabulary <em>on top</em> of the core data model.
        This approach has several drawbacks when compared to the alternative of representing composite values as compact, self-contained objects. Namely, it can easily become verbose and bloat up the storage footprint; moreover, extracting information from such containers and collections in SPARQL queries is cumbersome and can even be tricky (e.g., enumerating the elements of an RDF collection in their given order requires a complex query if the size of the collection is not assumed to be known), and manipulating containers and collections in SPARQL is complex (e.g., inserting a value into an RDF collection at a particular position is all but trivial).
      </p>
    </section>

    <section id="structure" class="informative">
      <h2>Structure of this Document (TODO)</h2>
      <p>
        In addition to sections marked as non-normative, all examples and notes in this specification are non-normative. Everything else in this specification is normative.
      </p>
      <p>TODO</p>
    </section>

    <section class="informative">
      <h2>Document Conventions (TODO)</h2>
      <p>
        Examples in this document assume that the following prefixes have been declared to represent the IRIs shown with them here:
      </p>

      <table>
        <tr><td>`:`</td><td>`&lt;http://www.example.org/&gt;`</td></tr>
        <tr><td>`ex:`</td><td>`&lt;http://example.org/&gt;`</td></tr>
        <tr><td>`rdf:`</td><td>`&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;`</td></tr>
        <tr><td>`foaf:`</td><td>`&lt;http://xmlns.com/foaf/0.1/&gt;`</td></tr>
        <tr><td>`cdt:`</td><td>`&lt;http://w3id.org/awslabs/neptune/SPARQL-CDTs/&gt;`</td></tr>
      </table>

    </section>

    <section id="conformance">
    </section>

  </section>


  <section id="description" class="informative">
    <h1>Informal Description of the Approach</h1>

    <section id="description-of-literals">
      <h2>Representation of Composite Values as RDF Literals</h2>

      <p>
        The basis of the approach is to capture composite values (lists and maps) as RDF literals. The components of such a composite value may be RDF terms, including literals representing scalar values (numbers, strings, etc.) as well as literals representing other composite values. The <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> (i.e., the string representation) of such a literal that represents a composite value contains the components of the composite value serialized in a format that is based on the <a href="https://www.w3.org/TR/turtle/">RDF Turtle format</a> [[TURTLE]]. For instance, the literals in the object positions of the following three RDF triples represent lists. Notice that, in the lexical form of these literals, the elements of the lists are separated by commas and enclosed in square brackets.
      </p>
      <pre id="first-list-example"
           data-transform="updateExample"
           data-content-type="text/turtle"
           class="nohighlight example">
        <!--
        ex:s ex:p1 "[ 0.504, 0.344, 0.002, 0.716 ]"^^cdt:List .
        ex:s ex:p2 "[ <http://example.org/alice>, <http://example.org/bob> ]"^^cdt:List .
        ex:s ex:p3 "[ '1999-08-16'^^<http://www.w3.org/2001/XMLSchema#date>, 42 ]"^^cdt:List .
        -->
      </pre>
      <p>
        In addition to lists, the approach considers maps, which are sets of key-value pairs where the keys must be distinct. Within the lexical form, the key-values pairs of such a map are separated by commas and a colon is used as separator between each key and its value, as demonstrated by the literal in the object position of the following triple.
      </p>
      <pre id="first-map-example"
           data-transform="updateExample"
           data-content-type="text/turtle"
           class="nohighlight example">
        <!--
        ex:s ex:p1 "{ 'name' : 'Tuva', 1: <http://example.org/>, 2: null }"^^cdt:Map .
        -->
      </pre>
      <p>
        The previous example also illustrates that, in addition to RDF terms, the approach supports `null` as a special value to be used within maps, as well as in lists. Moreover, the kinds of elements within each list or map may be mixed arbitrarily (defining strongly-typed variations of the proposed composite datatypes is part of our ongoing work).
      </p>
      <p>
        As the examples illustrate, list and map elements that are numeric literals (of particular types) can be written using the Turtle-specific shorthand notation (e.g., `0.504` is a shortened version of `'0.504'^^&lt;http://www.w3.org/2001/XMLSchema#decimal&gt;`), and the same holds for boolean-typed literals. Yet, IRIs cannot be shortened in the ways as are possible in Turtle; instead, within the lexical forms of list and map literals, they must be written as absolute IRIs (which is to avoid loosing the definition of the prefix label or the base IRI when the list and map literals are taken out of context). However, as another form of shorthand notation, our approach allows users to directly nest the lexical forms of lists and maps into one another (but still interpreting such contained lists or maps as literals with the corresponding data type). For instance, the literal in the object position of the following triple represents a map in which both of the key-value pairs have a literal as their value, with one of these literals representing a list and the other one a map.
      </p>
      <pre id="second-map-example"
           data-transform="updateExample"
           data-content-type="text/turtle"
           class="nohighlight example">
        <!--
        ex:s ex:p1 """{
                        'names' : ['Tuva', 'Ada', 'Eva'],
                        'address': {
                            'street': 'Harbor St.',
                            'number': 43,
                        }
                      }"""^^cdt:Map .
        -->
      </pre>
      <p>
        The attentive reader may observe that the lexical form of the literal in the previous example looks like a JSON document, which is not a coincidence. In contrast, our approach is designed such that, by and large, JSON is a subset of what can be used in the lexical forms of the list and map literals (see Section&nbsp;<a href="#map-datatype-versus-json" class="sectionRef"></a> for further details).
      </p>
      <p>
        For the definition of the datatypes used for such list and map literals, refer to Sections&nbsp;<a href="#list-datatype" class="sectionRef"></a> and <a href="#map-datatype" class="sectionRef"></a>, respectively.
      </p>
    </section>

    <section id="description-of-functions">
      <h2>SPARQL Functions on Composite Datatype Literals</h2>

      <p>
        Given such composite datatype literals, this document defines extensions to the SPARQL language that introduce functionality related to the types of composite values that these literals capture. The first of these extensions is a collection of various functions for such literals that can be used in expressions within BIND clauses, FILTER clauses, and SELECT clauses of SPARQL queries.
      </p>
      <p>
        For instance, the following SPARQL query (prefix declarations omitted) uses two such functions in a BIND clause; one of these functions (<a href="#func_concat">`cdt:concat`</a>) concatenates two or more lists, returning the resulting list as a literal again, and the other function (<a href="#func_size">`cdt:size`</a>) returns the cardinality of the resulting list.
      </p>
      <pre id="first-functions-example"
           data-transform="updateExample"
           data-content-type="application/sparql-query"
           class="nohighlight example">
        <!--
        SELECT * WHERE {
          ex:s ex:p1 ?l1 .
          ex:s ex:p2 ?l2 .
          ex:s ex:p3 ?l3 .
          BIND( cdt:size( cdt:concat(?l1,?l2,?l3) ) AS ?combinedLength )
        }
        -->
      </pre>
      <p>
        When executing this query over the <a href="#first-list-example">first example data above</a> (the example with the three lists), the value produced for the `?combinedLength` variable would be&nbsp;8.
      </p>
      <p>
        Further functions for lists that are defined in this document (in addition to <a href="#func_concat">`cdt:concat`</a> and <a href="#func_size">`cdt:size`</a>, as already used in the previous example) are the following:
      </p>
      <ul>
        <li><a href="#func_contains">`cdt:contains`</a> - can be used to check whether a particular RDF term is contained in a given list</li>
        <li><a href="#func_get">`cdt:get`</a> - returns the RDF term that is at a particular position within a given list</li>
        <li><a href="#func_head">`cdt:head`</a> - returns the RDF term that is at the first position within a given list</li>
        <li><a href="#func_reverse">`cdt:reverse`</a> - returns a list in which the elements of a given list are in the reverse order</li>
        <li><a href="#func_subseq">`cdt:subseq`</a> - returns a part of a given list</li></li>
        <li><a href="#func_tail">`cdt:tail`</a> - returns a list with all elements of a given list except for the first element</li>
      </ul>
      <p>
        In addition to functions for lists, the document defines functions for maps. As an example, consider the following SPARQL query (prefix declarations omitted).
      </p>
      <pre id="second-functions-example"
           data-transform="updateExample"
           data-content-type="application/sparql-query"
           class="nohighlight example">
        <!--
        SELECT ?newAddressSubMap WHERE {
          ex:s ex:p1 ?map .
          BIND( cdt:get( ?map, "address" ) AS ?addressSubMap )
          BIND( cdt:put( ?addressSubMap, "number", 42 ) AS ?newAddressSubMap )
        }
        -->
      </pre>
      <p>
        This query focuses on the earlier example with the <a href="#second-map-example">JSON-like map</a> (<a href="#second-map-example" class="sectionRef"></a>). By using the <a href="#func_get">`cdt:get`</a> function, the query obtains the `'address'` object of that map and, then, creates and returns a version of this object in which the value of the `'number'` field is replaced (using <a href="#func_put">`cdt:put`</a>). Hence, the result of the query, when executed over the data of <a href="#second-map-example" class="sectionRef"></a>, is a literal such as the following one.
      </p>
      <pre id="second-map-example"
           data-transform="updateExample"
           data-content-type="text/turtle"
           class="nohighlight example">
        <!--
        "{ 'street': 'Harbor St.', 'number': 42 }"^^cdt:Map .
        -->
      </pre>
      <p>
        In addition to <a href="#func_get">`cdt:get`</a> and <a href="#func_put">`cdt:put`</a>, further functions for maps in this document are:
      </p>
      <ul>
        <li><a href="#func_containsKey">`cdt:containsKey`</a> - can be used to check whether a particular RDF term is a key in a given map</li>
        <li><a href="#func_keys">`cdt:keys`</a> - returns a list of all keys in a given map</li>
        <li><a href="#func_merge">`cdt:merge`</a> - returns a map that is the result of merging two maps</li>
        <li><a href="#func_remove">`cdt:remove`</a> - returns a map resulting from a given map but without a particular key-value pair</li>
        <li><a href="#func_size">`cdt:size`</a> - returns the number of key-value pairs in a given map</li>
      </ul>
      <p>
        While all the functions mentioned above operate on the composite datatype literals introduced in this document, the document also defines functions to construct such literals. In particular, the <a href="#func_list">`cdt:List`</a> function can be used to construct a literal that represents a list consisting of the elements that are passed as arguments to the function. For instance, the following query constructs and returns such a literal with the three integers 1, 2, and 3 as elements of the represented list.
      </p>
      <pre id="constructor-function-example"
           data-transform="updateExample"
           data-content-type="application/sparql-query"
           class="nohighlight example">
        <!--
        SELECT ?list WHERE {
          BIND( 1 AS ?arg )
          BIND( cdt:List(?arg, ?arg+1, ?arg+2) AS ?list )
        }
        -->
      </pre>
      <p>
        Similarly, the <a href="#func_map">`cdt:Map`</a> function can be used to construct a literal representing a map of the key-value pairs that are passed as arguments to that function.
      </p>
      <p>
        For both of these constructor functions, it is possible that some of the given arguments evaluate to an error. For instance, the second and the third argument in the <a href="#constructor-function-example">previous query</a> would evaluate to an error if the variable `?arg` was bound to an IRI (because the `+` operator is not defined for IRIs). For any such argument that evaluates to an error, the corresponding element in the created list or map literal becomes the `null` value, unless it is an argument that specifies the key of a key-value pair for a map literal; in such a case, this key-value pair is ignored because keys cannot be `null`.
      </p>
    </section>

    <section id="description-of-fold">
      <h2>FOLD Aggregate</h2>
      <p>
        Another way to create list and map literals from within SPARQL queries (in addition to the aforementioned two constructor functions, <a href="#func_list">`cdt:List`</a> and <a href="#func_map">`cdt:Map`</a>) is to use the <a href="#fold">FOLD</a> function introduced in this document. As a so-called <a data-cite="SPARQL11-QUERY#setFunctions">set function</a>, which are typically used for aggregation, FOLD produces composite values for groups of solution mappings. The following query illustrates how this function can be used to create lists of persons that have the same surname.
      </p>
      <pre id="simple-fold-list-example"
           data-transform="updateExample"
           data-content-type="application/sparql-query"
           class="nohighlight example">
        <!--
        SELECT ?sname (FOLD(?person) AS ?list) WHERE {
          ?person rdf:type foaf:Person .
          ?person foaf:surname ?sname .
        }
        GROUP BY ?sname
        -->
      </pre>
      <p>
        Notice that the solution mappings within each of the groups in the previous query are not sorted. As a consequence, the order of the elements in the lists created by the query (i.e., the person IRIs in these lists) is undefined and may even be different each time the query is executed. For use cases in which a particular order is required, the FOLD function can be used with an ORDER BY clause. As an example, consider the following query, which extends the previous one with the requirement that the persons within each list are ordered based on their first names.
      </p>
      <pre id="fold-list-with-order-example"
           data-transform="updateExample"
           data-content-type="application/sparql-query"
           class="nohighlight example">
        <!--
        SELECT ?sname (FOLD(?person ORDER BY ?fname) AS ?list) WHERE {
          ?person rdf:type foaf:Person .
          ?person foaf:surname ?sname .
          ?person foaf:firstName ?fname .
        }
        GROUP BY ?sname
        -->
      </pre>
      <p>
        The ORDER BY feature of FOLD works exactly as the ORDER BY clause that can be used in SPARQL queries. Hence, it is possible to specify multiple ordering comparators, each with the optional keywords ASC and DESC (where ASC is the default).
      </p>
      <p>
        In addition to creating list literals, the FOLD function can also be used to create map literals. To this end, two arguments must be passed to the function, where the first argument provides the keys of the key-value pairs to be added to the map, and the second argument provides the corresponding values. The following query illustrates this functionality; it creates a single map literal in which the key-value pairs are surnames paired up with the number of persons in the queried graph that have the respective surname.
      </p>
      <pre id="fold-map-example"
           data-transform="updateExample"
           data-content-type="application/sparql-query"
           class="nohighlight example">
        <!--
        SELECT (FOLD(?sname, ?cnt) AS ?map) WHERE {
          {
            SELECT ?sname (COUNT(*) AS ?cnt) WHERE {
              ?person rdf:type foaf:Person .
              ?person foaf:surname ?sname .
            }
            GROUP BY ?sname
          }
        }
        -->
      </pre>
      <p>
        When using the two-argument version of FOLD, it may be the case that multiple solution mappings within a group to which FOLD is applied result in key-value pairs with the same key. If that is the case, only one of these key-value pairs is added to the map (which one is undefined unless ORDER BY is used within FOLD, in which case it is the last one in the specified order).
      </p>
    </section>

    <section id="description-of-unfold">
      <h2>UNFOLD Operator</h2>
      <p>
        While FOLD compiles values from multiple solution mappings into a composite value, to support the reverse of this process as well this document adds a new operator to SPARQL. This operator, called <a href="#unfold">UNFOLD</a>, breaks composite values into their individual components and assigns these components separately to a new query variable. The following query illustrates how this operator can be used to extract all elements from each list literal of the triples that match a given triple pattern.
      </p>
      <pre id="first-unfold-example"
           data-transform="updateExample"
           data-content-type="application/sparql-query"
           class="nohighlight example">
        <!--
        SELECT ?p ?element WHERE {
          ex:s ?p ?list .
          UNFOLD( ?list AS ?element )
        }
        -->
      </pre>
      <p>
        When executing this query over the <a href="#first-list-example">first example data above</a>, the query result consists of eight solutions as enumerated in the following tabular representation of the result. Notice that the first four solutions in this table are produced from the four elements of the list in the first triple of the example data; the next two solutions are from the two elements of the list in the second triple; and the last two solutions from the two elements of the list in the third triple.
      </p>
      <table class="sparqlresult">
        <tr>
          <th>?p</th>
          <th>?element</th>
        </tr>
        <tr>
          <td>ex:p1</td>
          <td>0.504</td>
        </tr>
        <tr>
          <td>ex:p1</td>
          <td>0.344</td>
        </tr>
        <tr>
          <td>ex:p1</td>
          <td>0.002</td>
        </tr>
        <tr>
          <td>ex:p1</td>
          <td>0.716</td>
        </tr>
        <tr>
          <td>ex:p2</td>
          <td>http://example.org/alice</td>
        </tr>
        <tr>
          <td>ex:p2</td>
          <td>http://example.org/bob</td>
        </tr>
        <tr>
          <td>ex:p3</td>
          <td>'1999-08-16'^^&lt;http://www.w3.org/2001/XMLSchema#date&gt;</td>
        </tr>
        <tr>
          <td>ex:p3</td>
          <td>42</td>
        </tr>
      </table>
      <p>
        If a list literal that is given to the UNFOLD operator contains `null` values, then the variable introduced in the UNFOLD operator remains unbound in the solution mappings created for these `null` elements. Yet, it is also possible to add a second variable in the UNFOLD operator, which then gets assigned an integer that represents the position of the list element assigned to the first variable. The following query illustrates this feature for a list that contains a `null` value.
      </p>
      <pre id="unfold-with-null-example"
           data-transform="updateExample"
           data-content-type="application/sparql-query"
           class="nohighlight example">
        <!--
        SELECT ?element ?pos WHERE {
          BIND( "[42, null, <http://example.org/>]"^^cdt:List AS ?list ).
          UNFOLD( ?list AS ?element, ?pos )
        }
        -->
      </pre>
      <p>
        The result of this query is illustrated in the following table. The empty cell in the table indicates that the solution mapping represented by the corresponding table row does not contain a binding for the corresponding variable (`?element`).
      </p>
      <table class="sparqlresult">
        <tr>
          <th>?element</th>
          <th>?pos</th>
        </tr>
        <tr>
          <td>42</td>
          <td>1</td>
        </tr>
        <tr>
          <td></td>
          <td>2</td>
        </tr>
          <td>http://example.org/</td>
          <td>3</td>
        </tr>
      </table>
      <p>
        The UNFOLD operator can be used for map literals as well. In this case, the one-variable version extracts the keys of the key-value pairs, whereas the two-variables version extracts both the keys (into the first variable) and the their corresponding values (into the second variable). As an example of the latter option, consider the following query.
      </p>
      <pre id="unfold-map-example"
           data-transform="updateExample"
           data-content-type="application/sparql-query"
           class="nohighlight example">
        <!--
        SELECT ?p ?key ?value WHERE {
          ex:s ?p ?map .
          UNFOLD( ?map AS ?key, ?value )
        }
        -->
      </pre>
      <p>
        When executing this query over the <a href="#first-map-example">data of the first map-related example above</a>, the query result consists of the three solutions listed in the following table (where the variable `?value` is unbound in the last solution because the value of the corresponding key-value pair in the map is `null`).
      </p>
      <table class="sparqlresult">
        <tr>
          <th>?p</th>
          <th>?key</th>
          <th>?value</th>
        </tr>
        <tr>
          <td>ex:p1</td>
          <td>"name"</td>
          <td>"Tuva"</td>
        </tr>
        <tr>
          <td>ex:p1</td>
          <td>1</td>
          <td>http://example.org/</td>
        </tr>
          <td>ex:p1</td>
          <td>2</td>
          <td></td>
        </tr>
      </table>
    </section>

    <section id="description-of-comparing">
      <h2>Comparing Composite Datatype Literals</h2>
      <p>
        Another important contribution of this document is to extend the definition of the SPARQL comparison operators (`=`, `!=`, `&lt;`, `&gt;`, `&lt;=`, and `&gt;=`) for list and map literals. The general idea captured by this extension is that two composite values of the same type (i.e., either two lists or two maps) are compared based on a pairwise comparison of the components of the compared composite values.
      </p>
      <p>
        In particular, two list literals are considered equal (`=`) if they contain the same number of elements and, for each position within the lists, the elements at that position are equal (`=`). For instance, `"[42]"^^cdt:List` and `"[42,43]"^^cdt:List` are not equal, and neither are `"[42]"^^cdt:List` and `"['42']"^^cdt:List`. In contrast, `"[42,43]"^^cdt:List` and `"[&nbsp;42&nbsp;,&nbsp;43&nbsp;]"^^cdt:List` are equal, and so are `"['1'^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;]"^^cdt:List` and `"['001'^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;]"^^cdt:List`.
      </p>
      <p>
        Similarly, two map literals are considered equal (`=`) if they contain the same number of key-value pairs, they have the exact same keys, and for each such key, the values associated with that key in both maps compare equal (`=`). The algorithms that define these two comparison processes in detail can be found in Sections&nbsp;<a href="#func_list-equal" class="sectionRef"></a> and <a href="#func_map-equal" class="sectionRef"></a>, respectively.
      </p>
      <p>
        The definition of whether a list literal is smaller (`&lt;`) than another list literal is also captured in terms of an algorithm that iterates over the two lists (see Section&nbsp;<a href="#func_list-less-than" class="sectionRef"></a>). In this case, the iteration stops once it arrives at a position where the respective elements at this position in the two lists do not compare equal (`=`). At this point, if one of these two elements is smaller (`&lt;`) than the other one, then the list with this element is considered smaller. If, however, comparing the two elements results in an error or one of them is `null` and the other one not, then the comparison of the two lists also raises an error. In case the iteration arrives at the end of one of the two lists without stopping, then this list (with fewer elements) is considered smaller.
      </p>
      <p>
        Finally, to define whether a map literal is smaller than another map literal we provide another algorithm (see Section&nbsp;<a href="#func_map-less-than" class="sectionRef"></a>). This algorithm iterates over the key-value pairs of both maps, assuming these pairs are ordered based on their keys. Once the iteration arrives at two such pairs that do not have both the same key and equal values, the iteration stops. At this point, the algorithm first compares the keys of these two pairs. If the two keys are not the same, then the map with the key that would be ordered before the other one is considered smaller. If the keys are the same, the decision is made by comparing the corresponding values (in the same way as done by the algorithm for the list literals).
      </p>
    </section>

    <section id="description-of-ordering">
      <h2>Ordering Composite Datatype Literals</h2>
      <p>
        The last main contribution of this document is to define a relative order of list and map literals, to be used in the context of the ORDER BY clause of SPARQL (and, therefore, also for the aforementioned ORDER BY feature of FOLD). This definition is based on algorithms&mdash;one for list literals and one for map literals&mdash;that are similar to the respective comparison algorithms as mentioned in the previous section. In particular, these algorithms that define the relative order also iterate over the components of a given pair of composite values; i.e., the elements of two lists (resp. the key-value pairs of two maps) are considered in a pairwise manner. The major difference between these algorithms and the comparison algorithms is that the latter apply the smaller-than operator (`&lt;`) at each iteration step whereas the former consider the relative ordering of the list elements (resp. key-value pairs) considered at each iteration step.
      </p>
      <p>
        The effect of this difference can be observed for composite values that contain IRIs or blank nodes. For instance, while the expression
      </p>
      <pre data-content-type="application/sparql-query" class="nohighlight">
        "[&lt;http://example.org/a&gt;]"^^cdt:List  &lt;  "[&lt;http://example.org/b&gt;]"^^cdt:List
      </pre>
      <p>
        yields an error because &lt; is not defined for IRIs, the relative order of the two list literals in this expression is defined (namely based on the relative order of the IRIs they contain).
      </p>
      <p>
        Similarly, the expression
      </p>
      <pre data-content-type="application/sparql-query" class="nohighlight">
        "[&lt;http://example.org/a&gt;]"^^cdt:List  &lt;  "[42]"^^cdt:List
      </pre>
      <p>
        yields an error because &lt; is not defined between IRIs and (numeric) literals, whereas the relative order of the two list literals in this expression is defined (namely based on the fact that <a data-cite="SPARQL11-QUERY#modOrderBy">literals are ordered higher than IRIs</a>).
      </p>
      <p>
        Yet, there are also pairs of list literals and pairs of map literals for which the relative order is undefined. For instance, this is the case for `"['hello'@en]"^^cdt:List` and `"['hello']"^^cdt:List`, because the relative order between language-tagged literals and string literals without language tag <a data-cite="SPARQL11-QUERY#modOrderBy">is undefined in SPARQL</a>.
      </p>
      <p>
        The complete algorithms that define the relative order for list literals and for map literals can be found in Section&nbsp;<a href="#relative-order-of-list-literals" class="sectionRef"></a> and in Section&nbsp;<a href="#relative-order-of-map-literals" class="sec-ref"></a>, respectively.
      </p>
    </section>

  </section>


  <section id="list-datatype">
    <h2>The cdt:List Datatype</h2>

    <p>
      The <dfn data-lt="cdt:List datatype">cdt:List datatype</dfn> is the <a data-cite="RDF11-CONCEPTS#dfn-datatype">RDF datatype</a> that consists of the <a data-cite="RDF11-CONCEPTS#dfn-value-space">value space</a>, the <a data-cite="RDF11-CONCEPTS#dfn-lexical-space">lexical space</a>, and the <a data-cite="RDF11-CONCEPTS#dfn-lexical-to-value-mapping">lexical-to-value mapping</a> defined in this section (see Subsections <a href="#list-datatype-valuespace" class="sectionRef"></a>, <a href="#list-datatype-lexspace" class="sectionRef"></a>, and <a href="#list-datatype-lex-to-value-mapping" class="sectionRef"></a>, respectively), and that is denoted by the following <a data-cite="RDF11-CONCEPTS#dfn-datatype-iri">datatype IRI</a>:
    </p>
    <p>
      `http://w3id.org/awslabs/neptune/SPARQL-CDTs/List`
    </p>
    <p>
      Every <a data-cite="RDF11-CONCEPTS#dfn-literal">literal</a> that has this IRI as its <a data-cite="RDF11-CONCEPTS#dfn-datatype-iri">datatype IRI</a> is called a <dfn data-lt="cdt:List literal">cdt:List literal</dfn>. If the <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> of such a literal is in the <a data-cite="RDF11-CONCEPTS#dfn-lexical-space">lexical space</a> of the <a>cdt:List datatype</a>, as defined in Section&nbsp;<a href="#list-datatype-lexspace" class="sectionRef"></a>, then the literal is called a <dfn data-lt="well-formed cdt:List literal">well-formed cdt:List literal</dfn>. In contrast, a <a>cdt:List literal</a> whose lexical form is not in the lexical space of the cdt:List datatype is called an <dfn data-lt="ill-formed cdt:List literal">ill-formed cdt:List literal</dfn>.
    </p>

    <section id="list-datatype-valuespace">
      <h2>Value Space</h2>

      <p>
        The <a data-cite="RDF11-CONCEPTS#dfn-value-space">value space</a> of the <a>cdt:List datatype</a> consists of all finite <a href="https://en.wikipedia.org/wiki/Sequence">sequences</a> of <a>list elements</a>, where the notion of a <dfn data-lt="list element">list element</dfn> is defined as follows:
        <ul>
          <li>every <a data-cite="RDF11-CONCEPTS#dfn-rdf-term">RDF term</a> is a list element and</li>
          <li><a>null</a> is a list element.</li>
        </ul>
        Any such sequence is called <dfn data-lt="term list">term list</dfn>, and the empty sequence of <a>list elements</a> is the <dfn data-lt="empty term list">empty term list</dfn>.
      </p>

      <p>
        <dfn data-lt="null">null</dfn> is a special symbol that can be used as a <a>list element</a> (and as a <a>map value</a>) and that is <em>not</em> an <a data-cite="RDF11-CONCEPTS#dfn-rdf-term">RDF term</a>.
      </p>

      <p class="note">
        Every RDF term MAY occur multiple times in a <a>term list</a>, and so may <a>null</a>.
      </p>

    </section>

    <section id="list-datatype-lexspace">
      <h2>Lexical Space</h2>
        
      <p>
        The <a data-cite="RDF11-CONCEPTS#dfn-lexical-space">lexical space</a> of the <a>cdt:List datatype</a> consists of all strings that are recognized by the <a href="#cdt-grammar-production-List">`List`</a> production of the following grammar (the <a data-cite="XML#sec-notation"><abbr title="Extended Backus-Naur Form">EBNF</abbr> notation</a> used here is defined in XML 1.0 [[EBNF-NOTATION]]).
      </p>
      <p>
        The grammar uses productions from the grammar of the Turtle serialization format for RDF data [[TURTLE]]. In particular, the terminal and nonterminal symbols for which no production rule is provided below (i.e.,
        <a data-cite="TURTLE#grammar-production-IRIREF">`IRIREF`</a>,
        <a data-cite="TURTLE#grammar-production-BLANK_NODE_LABEL">`BLANK_NODE_LABEL`</a>,
        <a data-cite="TURTLE#grammar-production-NumericLiteral">`NumericLiteral`</a>,
        <a data-cite="TURTLE#grammar-production-BooleanLiteral">`BooleanLiteral`</a>,
        <a data-cite="TURTLE#grammar-production-String">`String`</a>,
        and
        <a data-cite="TURTLE#grammar-production-LANGTAG">LANGTAG</a>)
        are defined in the Turtle grammar.
      </p>
      <p>
        The <a href="#cdt-grammar-production-RDFLiteral">`RDFLiteral`</a> production in the given grammar is special as the Turtle grammar also contains a very similar production for the same symbol (see <a data-cite="TURTLE#grammar-production-RDFLiteral">`RDFLiteral`</a> in [[TURTLE]]). The difference is that the version of the rule in the Turtle grammar permits the <a data-cite="RDF11-CONCEPTS#dfn-datatype-iri">datatype IRI</a> of a <a data-cite="RDF11-CONCEPTS#literal">literal</a> to be written as a <a data-cite="TURTLE#prefixed-name">prefixed name</a>, whereas the version of the rule as defined below does not permit datatype IRIs written as prefixed names (but only as absolute IRIs and as <a data-cite="TURTLE#relative-iri">relative IRIs</a>).
      </p>
      <p>
        An additional restriction that is not explicitly captured in the given grammar is that any occurrence of the <a data-cite="TURTLE#grammar-production-IRIREF">`IRIREF`</a> production MUST&mdash;after handling of <a href="https://www.w3.org/TR/turtle/#numeric">escape sequences</a>&mdash;also match the (more restrictive) `absolute-IRI` production of [[RFC3987]]. Hence, IRI references in the lexical form of <a>cdt:List literals</a> and <a>cdt:Map literals</a> MUST be absolute; they cannot be written as <a data-cite="TURTLE#prefixed-name">prefixed names</a> (see the previous paragraph about the <a href="#cdt-grammar-production-RDFLiteral">`RDFLiteral`</a> production) nor as <a data-cite="TURTLE#relative-iri">relative IRI references</a>.
      </p>

      <table class="grammar">

        <tr id="cdt-grammar-production-List">
          <td>[1]</td>
          <td>`List`</td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <code class="token">'['</code>
            `(`
            <a href="#cdt-grammar-production-NonEmptyListContent">NonEmptyListContent</a>
            `)?`
            <code class="token">']'</code>
          </td>
        </tr>

        <tr id="cdt-grammar-production-NonEmptyListContent">
          <td>[2]</td>
          <td>`NonEmptyListContent`</td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <a href="#cdt-grammar-production-ListElement">ListElement</a>
            `(`
            <code class="token">','</code>
            <a href="#cdt-grammar-production-ListElement">ListElement</a>
            `)*`
          </td>
        </tr>

        <tr id="cdt-grammar-production-ListElement">
          <td>[3]</td>
          <td>`ListElement`</td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <a data-cite="TURTLE#grammar-production-IRIREF">IRIREF</a>
            `|`
            <a data-cite="TURTLE#grammar-production-BLANK_NODE_LABEL">BLANK_NODE_LABEL</a>
            `|`
            <a href="#cdt-grammar-production-RDFLiteral">RDFLiteral</a>
            `|`
            <a data-cite="TURTLE#grammar-production-NumericLiteral">NumericLiteral</a>
            `|`
            <a data-cite="TURTLE#grammar-production-BooleanLiteral">BooleanLiteral</a>
            `|`
            <a href="#cdt-grammar-production-NULL">NULL</a>
            `|`
            <a href="#cdt-grammar-production-List">List</a>
            `|`
            <a href="#cdt-grammar-production-Map">Map</a>
          </td>
        </tr>

        <tr id="cdt-grammar-production-Map">
          <td>[4]</td>
          <td>`Map`</td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <code class="token">'{'</code>
            `(`
            <a href="#cdt-grammar-production-NonEmptyMapContent">NonEmptyMapContent</a>
            `)?`
            <code class="token">'}'</code>
          </td>
        </tr>

        <tr id="cdt-grammar-production-NonEmptyMapContent">
          <td>[5]</td>
          <td>`NonEmptyMapContent`</td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <a href="#cdt-grammar-production-MapEntry">MapEntry</a>
            `(`
            <code class="token">','</code>
            <a href="#cdt-grammar-production-MapEntry">MapEntry</a>
            `)*`
          </td>
        </tr>

        <tr id="cdt-grammar-production-MapEntry">
          <td>[6]</td>
          <td>`MapEntry`</td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <a href="#cdt-grammar-production-MapKey">MapKey</a>
            <code class="token">':'</code>
            <a href="#cdt-grammar-production-MapValue">MapValue</a>
          </td>
        </tr>

        <tr id="cdt-grammar-production-MapKey">
          <td>[7]</td>
          <td>`MapKey`</td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <a data-cite="TURTLE#grammar-production-IRIREF">IRIREF</a>
            `|`
            <a href="#cdt-grammar-production-RDFLiteral">RDFLiteral</a>
            `|`
            <a data-cite="TURTLE#grammar-production-NumericLiteral">NumericLiteral</a>
            `|`
            <a data-cite="TURTLE#grammar-production-BooleanLiteral">BooleanLiteral</a>
          </td>
        </tr>

        <tr id="cdt-grammar-production-MapValue">
          <td>[8]</td>
          <td>`MapValue`</td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <a data-cite="TURTLE#grammar-production-IRIREF">IRIREF</a>
            `|`
            <a data-cite="TURTLE#grammar-production-BLANK_NODE_LABEL">BLANK_NODE_LABEL</a>
            `|`
            <a href="#cdt-grammar-production-RDFLiteral">RDFLiteral</a>
            `|`
            <a data-cite="TURTLE#grammar-production-NumericLiteral">NumericLiteral</a>
            `|`
            <a data-cite="TURTLE#grammar-production-BooleanLiteral">BooleanLiteral</a>
            `|`
            <a href="#cdt-grammar-production-NULL">NULL</a>
            `|`
            <a href="#cdt-grammar-production-List">List</a>
            `|`
            <a href="#cdt-grammar-production-Map">Map</a>
          </td>
        </tr>

        <tr id="cdt-grammar-production-NULL">
          <td>[9]</td>
          <td>`NULL`</td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <code class="token">'null'</code>
          </td>
        </tr>

        <tr id="cdt-grammar-production-RDFLiteral">
          <td>[128s]</td>
          <td>`RDFLiteral`</td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <a data-cite="TURTLE#grammar-production-String">String</a>
            `(`
            <a data-cite="TURTLE#grammar-production-LANGTAG">LANGTAG</a>
            `|`
            <code class="token">'^^'</code> <a data-cite="TURTLE#grammar-production-IRIREF">IRIREF</a>
            `)?`
          </td>
        </tr>

      </table>

      <p class="note">
        The complete grammar can be found in <a href="#cdt-ebnf"></a>.
      </p>

    </section>

    <section id="list-datatype-lex-to-value-mapping">
      <h2>Lexical-To-Value Mapping</h2>
        
      <p>
        The <a data-cite="RDF11-CONCEPTS#dfn-lexical-to-value-mapping">lexical-to-value mapping</a> of the <a>cdt:List datatype</a> is defined for every string that is recognized by the <a href="#cdt-grammar-production-List">`List`</a> production of the grammar defined in Section&nbsp;<a href="#list-datatype-lexspace" class="sectionRef"></a>.
      </p>
      <p>
        For the definition of this mapping, we assume an injective function&nbsp;<dfn data-lt="bnl2bn">bnl2bn</dfn> from the set of all strings recognized by the <a data-cite="TURTLE#grammar-production-BLANK_NODE_LABEL">`BLANK_NODE_LABEL`</a> production of the grammar to the set of all blank nodes. Hence, <i><a>bnl2bn</a></i> maps every string recognized by the <a data-cite="TURTLE#grammar-production-BLANK_NODE_LABEL">`BLANK_NODE_LABEL`</a> production to a distinct blank node.
      </p>
      <p>
        Then, given a string&nbsp;|S| that is recognized by the <a href="#cdt-grammar-production-List">`List`</a> production of the grammar, the <a>term list</a> that |S| is mapped to is defined as follows.
      </p>
      <p>
        If the string&nbsp;|S| does <em>not</em> contain a substring that is recognized by the <a href="#cdt-grammar-production-NonEmptyListContent">`NonEmptyListContent`</a> production of the grammar, then |S| is mapped to the <a>empty term list</a>.
      </p>
      <p>
        Otherwise, let |S|' be the greatest substring of |S| that is recognized by the <a href="#cdt-grammar-production-NonEmptyListContent">`NonEmptyListContent`</a> production and let (<var>E<sub>1</sub></var>, ..., <var>E<sub>|n|</sub></var>) be the sequence of all substrings of |S|' that are recognized by the <a href="#cdt-grammar-production-ListElement">`ListElement`</a> production, in the order in which they appear in |S|'. Then, |S| is mapped to the <a>term list</a>&nbsp;|tm| that consists of |n| <a>list elements</a> such that, for all |i| in {1, ..., |n|}, the |i|-th element in |tm| is the following <a>list element</a>, depending on which of the cases of the <a href="#cdt-grammar-production-ListElement">`ListElement`</a> production recognizes the substring&nbsp;<var>E<sub>|i|</sub></var>:
        <ul>
          <li>
            If <var>E<sub>|i|</sub></var> is recognized by the <a data-cite="TURTLE#grammar-production-IRIREF">`IRIREF`</a> production, then the |i|-th element in |tm| is the IRI constructed from the substring <var>E<sub>|i|</sub></var> according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]].
            <p class="note">
              The procedure described in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]] involves unescaping Turtle's <a href="https://www.w3.org/TR/turtle/#numeric">numeric escape sequences</a>.
              If an IRI appears in the lexical form of a <a>cdt:List literal</a> in a SPARQL query, it will be subject to <em>both</em> Turtle's numeric escaping <em>and</em> SPARQL's <a href="https://www.w3.org/TR/sparql11-query/#codepointEscape">Codepoint Escape Sequences</a> [[SPARQL11-QUERY]].
              For example, including <code>BIND("[&lt;http://example.org/\u005cu0041>]"^^cdt:List AS ?list)</code> in a SPARQL query will result in a <a>well-formed cdt:List literal</a> whose <a data-cite="RDF11-CONCEPTS#dfn-literal-value">value</a> is a <a>term list</a> with the IRI `http://example.org/A` as element.
              <br/><br/>
              In contrast, if the literal <code>"[&lt;http://example.org/\u005cu0041>]"^^cdt:List</code> occurs in a Turtle file, then the literal is not pre-processed for SPARQL's codepoint escape sequences but the IRI inside the lexical form of the literal is still subject to unescaping the numeric escape sequences.
              The result of this unescaping is the substring <code>http://example.org/\u0041</code> which is not a valid IRI.
            </p>
          </li>
          <li>
            If <var>E<sub>|i|</sub></var> is recognized by the <a data-cite="TURTLE#grammar-production-BLANK_NODE_LABEL">`BLANK_NODE_LABEL`</a> production, then the |i|-th element in |tm| is the blank node <i><a>bnl2bn</a></i>(<var>E<sub>|i|</sub></var>).
          </li>
          <li>
            If <var>E<sub>|i|</sub></var> is recognized by the <a href="#cdt-grammar-production-RDFLiteral">`RDFLiteral`</a> production, then the |i|-th element in |tm| is a literal that has as its lexical form the string that has matched the first rule argument, <a data-cite="TURTLE#grammar-production-String">`String`</a>, and the datatype IRI and language tag of the literal are as follows.
            <ul>
              <li>If the <a data-cite="TURTLE#grammar-production-LANGTAG">`LANGTAG`</a> rule matched, the datatype IRI is `rdf:langString` and the language tag is the string that has matched the <a data-cite="TURTLE#grammar-production-LANGTAG">`LANGTAG`</a> rule.</li>
              <li>If the `'^^'`<a data-cite="TURTLE#grammar-production-IRIREF">`IRIREF`</a> rule matched, the datatype IRI is the IRI constructed from the <a data-cite="TURTLE#grammar-production-IRIREF">`IRIREF`</a> match according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]], and the literal has no language tag.</li>
              <li>If neither matched, the datatype is `xsd:string` and the literal has no language tag.</li>
            </ul>
          </li>
          <li>
            If <var>E<sub>|i|</sub></var> is recognized by either the <a data-cite="TURTLE#grammar-production-NumericLiteral">`NumericLiteral`</a> production or the <a data-cite="TURTLE#grammar-production-BooleanLiteral">`BooleanLiteral`</a> production, then the |i|-th element in |tm| is the literal constructed from the substring <var>E<sub>|i|</sub></var> according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]].
          </li>
          <li>
            If <var>E<sub>|i|</sub></var> is recognized by the <a href="#cdt-grammar-production-NULL">`NULL`</a> production, then the |i|-th element in |tm| is <a>null</a>.
          </li>
          <li>
            If <var>E<sub>|i|</sub></var> is recognized by the <a href="#cdt-grammar-production-List">`List`</a> production, then the |i|-th element in |tm| is the literal that has the string <var>E<sub>|i|</sub></var> as its lexical form, the IRI `cdt:List` as its datatype IRI, and no language tag.
          </li>
          <li>
            If <var>E<sub>|i|</sub></var> is recognized by the <a href="#cdt-grammar-production-Map">`Map`</a> production, then the |i|-th element in |tm| is the literal that has the string <var>E<sub>|i|</sub></var> as its lexical form, the IRI `cdt:Map` as its datatype IRI, and no language tag.
          </li>
        </ul>
      </p>
      <p>
        Since producing the <a>term list</a> for |S| as defined above relies on the capability to construct RDF terms according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]], it requires a parser that maintains state of the `bnodeLabels` mapping used for parsing Turtle, as defined in <a href="https://www.w3.org/TR/turtle/#sec-parsing-state">Section&nbsp;7.1</a> of [[TURTLE]].
      </p>

      <p class="note">
        By the definition of the <a data-cite="RDF11-CONCEPTS#dfn-lexical-to-value-mapping">lexical-to-value mapping</a> of the <a>cdt:List datatype</a>, there can be no <a>term list</a> that contains a <a>cdt:List literal</a> whose <a data-cite="RDF11-CONCEPTS#dfn-literal-value">literal value</a> is that same term list.
      </p>

    </section>

    <section id="list-datatype-versus-rdflists" class="informative">
      <h2>Relationship to RDF Collections</h2>

      <p>
        The RDF Collection vocabulary, as introduced in <a data-cite="RDF11-SCHEMA#ch_collectionvocab">Section&nbsp;5.2</a> of [[RDF11-SCHEMA]], provides vocabulary terms to describe lists of resources explicitly by using RDF triples. For instance, the triples in the following snippet of Turtle (prefix declarations omitted) describe a list consisting of two resources that are denoted by the IRIs `http://example.org/alice` and `http://example.org/bob`, respectively.
      </p>
      <pre id="rdf-list-example"
           data-transform="updateExample"
           data-content-type="text/turtle"
           class="nohighlight example">
        <!--
        ex:book1 ex:authors _:b1 .
        _:b1 rdf:first <http://example.org/alice> .
        _:b1 rdf:rest _:b2 .
        _:b2 rdf:first <http://example.org/bob> .
        _:b2 rdf:rest rdf:nil .
        -->
      </pre>

      <p>
        Some serialization formats for RDF, including Turtle [[TURTLE]], provide some form of shorthand notation based on which such lists can be written in a more concise way. For instance, by using the <a data-cite="TURTLE#collections">Turtle syntax for collections</a>, the snippet of Turtle as given in the previous example can be shortened as follows.
      </p>
      <pre id="concise-rdf-list-example"
           data-transform="updateExample"
           data-content-type="text/turtle"
           class="nohighlight example">
        <!--
        ex:book1 ex:authors (<http://example.org/alice> <http://example.org/bob>) .
        -->
      </pre>

      <p>
        Note that even if the latter snippet of Turtle looks more compact, it still captures the same set of five RDF triples as the snippet of Turtle in <a href="#rdf-list-example" class="exampleRef"></a>.
      </p>

      <p>
        Such lists can be converted into <a>cdt:List literals</a> and vice versa. The remainder of this section introduces generic approaches to describe such conversions using the SPARQL language. These approaches are generic in the sense that they do not make any assumptions about the given lists that are to be converted (such as assuming knowledge of the list size or of the absence of duplicate entries).
      </p>

      <p>
        To <strong>convert an RDF collection into a cdt:List literal</strong> by using a SPARQL query, this query needs to traverse the corresponding `rdf:rest` triples using a <a data-cite="SPARQL11-QUERY#propertypaths">property path expression</a>, collect the object of each `rdf:first` triple along the path, and finally combine these objects as <a>list elements</a> of a <a>term list</a> for a <a>cdt:List literal</a> by using the FOLD aggregate defined in Section&nbsp;<a href="#fold" class="sectionRef"></a>. Additionally, to preserve the order of the list elements, grouping needs to be used for each position in the given list and the number of path traversal steps to this position need to be counted. The following query illustrates how this approach can be used in the context of the example data above.
      </p>
      <pre id="duplicate-aware-order-preserving-rdf-list-to-cdt-list-example"
           data-transform="updateExample"
           data-content-type="application/sparql-query"
           class="nohighlight example">
        <!--
        SELECT ( FOLD(?elmt ORDER BY ?index) AS ?cdtList ) WHERE {
          {
            SELECT ?position (COUNT(?step) AS ?index) WHERE {
              ex:book1 ex:authors ?rdfList .
              ?rdfList rdf:rest* ?step .
              ?step rdf:rest* ?position .
            }
            GROUP BY ?position
          }

          ?position rdf:first ?elmt .
        }
        -->
      </pre>

      <p>
        If the given list is known to be free of duplicates, the query can be slightly simplified:
      </p>
      <pre id="duplicate-free-order-preserving-rdf-list-to-cdt-list-example"
           data-transform="updateExample"
           data-content-type="application/sparql-query"
           class="nohighlight example">
        <!--
        SELECT ( FOLD(?elmt ORDER BY ?index) AS ?cdtList ) WHERE {
          {
            SELECT ?elmt (COUNT(?step) AS ?index) WHERE {
              ex:book1 ex:authors ?rdfList .
              ?rdfList rdf:rest* ?step .
              ?step rdf:rest* ?position .
              ?position rdf:first ?elmt .
            }
            GROUP BY ?elmt
          }
        }
        -->
      </pre>

      <p>
        If the order of the list elements does not need to be preserved, an even simpler version of the query without grouping and counting can be used (which is also duplicate preserving in case the given list contains duplicate entries):
      </p>
      <pre id="order-agnostic-rdf-list-to-cdt-list-example"
           data-transform="updateExample"
           data-content-type="application/sparql-query"
           class="nohighlight example">
        <!--
        SELECT ( FOLD(?elmt) AS ?cdtList ) WHERE {
          ex:book1 ex:authors ?rdfList .
          ?rdfList rdf:rest/rdf:first ?elmt .
        }
        -->
      </pre>

      <p>
        To <strong>convert a cdt:List literal into an RDF collection</strong> a `CONSTRUCT` query needs to be used that produces the relevant RDF triples based on the RDF collection vocabulary. The `WHERE` clause of such a query needs to use the `UNFOLD` operator (see Section&nbsp;<a href="#unfold" class="sectionRef"></a>) to obtain each <a>list element</a> together with its position within the <a>term list</a> represented by the given cdt:List literal. The positions can then be associated with blank nodes to be used for the various resources based on which the structure of the created RDF collection is built (the following query creates a <a>cdt:Map literal</a> as an intermediary structure for this purpose). Special care needs to be taken to correctly close the RDF collection with the term `rdf:nil`, for which the position of each element needs to be compared with the size of the list (as can be obtained with the `cdt:size` function defined in Section&nbsp;<a href="#func_size" class="sectionRef"></a>). Finally, to properly handle empty lists as well, the whole query pattern <em>for the non-empty lists</em> needs to be placed within an `OPTIONAL` block and a second `OPTIONAL` block needs to be added to cover the cases of empty lists. The following query illustrates this approach for all cdt:List literals in the object positions of triples with the IRI `ex:authorList` as predicate.
      </p>
      <pre id="complete-cdt-list-to-rdf-list-example"
           data-transform="updateExample"
           data-content-type="application/sparql-query"
           class="nohighlight example">
        <!--
        CONSTRUCT {
          ?s ex:authors ?firstStep .
          ?thisStep rdf:first ?elmt .
          ?thisStep rdf:rest ?rest .
        }
        WHERE {
          OPTIONAL { # for the cases of non-empty lists
            {
              SELECT ?s ?list (FOLD(?pos, BNODE()) AS ?listHeads) WHERE {
                ?s ex:authorList ?list .
                FILTER( DATATYPE(?list) = cdt:List )
                UNFOLD( ?list AS ?elmt, ?pos )
              }
              GROUP BY ?s ?list
            }

            UNFOLD( ?list AS ?elmt, ?pos )
            BIND( cdt:get(?listHeads, ?pos) AS ?thisStep )
            BIND( cdt:size(?list) AS ?size )
            BIND( IF( ?pos=?size,
                      rdf:nil,
                      cdt:get(?listHeads, ?pos+1)
                  ) AS ?rest )
            BIND( cdt:get(?listHeads, 1) AS ?firstStep )
          }
          OPTIONAL { # for the cases of empty lists
            ?s ex:authorList ?list .
            FILTER( DATATYPE(?list) = cdt:List )
            FILTER( cdt:size(?list) = 0 )
            BIND( rdf:nil AS ?firstStep )
          }
        }
        -->
      </pre>

      <p>
        It needs to be emphasized that, for cdt:List literals that represent term lists with <a>null</a> values, the given query creates no `rdf:first` triples for the corresponding positions in the resulting RDF collection (but the `rdf:rest` triples for these positions are created by the query). The reason for this is that the `UNFOLD` operator leaves the variable `?elmt` unbound for the positions where a term list has a null value.
      </p>

      <p>
        Notice also that the query contains two `FILTER` clauses (one in each `OPTIONAL` block) that ensure the datatype of the literals bound to the variable `?list` is indeed `cdt:List`. The purpose of these two `FILTER` clauses is to avoid accidentially creating RDF collections from potentially matching cdt:Map literals (as the `UNFOLD` operator and the `cdt:size` function can be applied to such literals as well). For cases in which it is guaranteed, however, that `?list` would not be bound to any cdt:Map literal, the query can be slightly simplified by removing these two `FILTER` clauses.
      </p>

      <p>
        Another possible simplification (orthogonal to aforementioned one about removing the two `FILTER` clauses) can be applied if the cdt:List literals that are to be converted are guaranteed to represent only nonempty term lists. In this case, the whole pattern within the first `OPTIONAL` block does not need to be wrapped within an `OPTIONAL` block and the second `OPTIONAL` block can be removed completely.
      </p>

    </section>

  </section>



  <section id="map-datatype">
    <h2>The cdt:Map Datatype</h2>

    <p>
      The <dfn data-lt="cdt:Map datatype">cdt:Map datatype</dfn> is the <a data-cite="RDF11-CONCEPTS#dfn-datatype">RDF datatype</a> that consists of the <a data-cite="RDF11-CONCEPTS#dfn-value-space">value space</a>, the <a data-cite="RDF11-CONCEPTS#dfn-lexical-space">lexical space</a>, and the <a data-cite="RDF11-CONCEPTS#dfn-lexical-to-value-mapping">lexical-to-value mapping</a> defined in this section (see Subsections <a href="#map-datatype-valuespace" class="sectionRef"></a>, <a href="#map-datatype-lexspace" class="sectionRef"></a>, and <a href="#map-datatype-lex-to-value-mapping" class="sectionRef"></a>, respectively), and that is denoted by the following <a data-cite="RDF11-CONCEPTS#dfn-datatype-iri">datatype IRI</a>:
    </p>
    <p>
      `http://w3id.org/awslabs/neptune/SPARQL-CDTs/Map`
    </p>
    <p>
      Every <a data-cite="RDF11-CONCEPTS#dfn-literal">literal</a> that has this IRI as its <a data-cite="RDF11-CONCEPTS#dfn-datatype-iri">datatype IRI</a> is called a <dfn data-lt="cdt:Map literal">cdt:Map literal</dfn>. If the <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> of such a literal is in the <a data-cite="RDF11-CONCEPTS#dfn-lexical-space">lexical space</a> of the <a>cdt:Map datatype</a>, as defined in Section&nbsp;<a href="#map-datatype-lexspace" class="sectionRef"></a>, then the literal is called a <dfn data-lt="well-formed cdt:Map literal">well-formed cdt:Map literal</dfn>. In contrast, a <a>cdt:Map literal</a> whose lexical form is not in the lexical space of the cdt:Map datatype is called an <dfn data-lt="ill-formed cdt:Map literal">ill-formed cdt:Map literal</dfn>.
    </p>

    <section id="map-datatype-valuespace">
      <h2>Value Space</h2>

      <p>
        The <a data-cite="RDF11-CONCEPTS#dfn-value-space">value space</a> of the <a>cdt:Map datatype</a> consists of all <a href="https://en.wikipedia.org/wiki/Function_(mathematics)">functions</a> that map from a <em>finite</em> set of <a>map keys</a> to the set of <a>map values</a>, where the notion of a <dfn data-lt="map key">map key</dfn> is defined as follows:
        <ul>
          <li>every <a data-cite="RDF11-CONCEPTS#dfn-iri">IRI</a> is a map key and</li>
          <li>every <a data-cite="RDF11-CONCEPTS#dfn-literal">literal</a> is a map key,</li>
        </ul>
        and the notion of a <dfn data-lt="map value">map value</dfn> is defined as follows:
        <ul>
          <li>every <a data-cite="RDF11-CONCEPTS#dfn-rdf-term">RDF term</a> is a map value (i.e., every <a data-cite="RDF11-CONCEPTS#dfn-iri">IRI</a>, <a data-cite="RDF11-CONCEPTS#dfn-literal">literal</a>, and <a data-cite="RDF11-CONCEPTS#dfn-blank-node">blank node</a>) and</li>
          <li><a>null</a> is a map value.</li>
        </ul>
        Any such function is called <dfn data-lt="term map">term map</dfn>, and the <a href="https://en.wikipedia.org/wiki/Function_(mathematics)#empty_function">empty function</a> for the set of <a>map values</a> (i.e., the function that maps from the empty set to the set of <a>map values</a>) is the <dfn data-lt="empty term map">empty term map</dfn>.
        Moreover, every pair&nbsp;(|k|,|v|) consisting of a <a>map key</a>&nbsp;|k| and a <a>map value</a>&nbsp;|v| is called a <dfn data-lt="map entry">map entry</dfn> where |k| is called the <dfn data-lt="key of map entry">key</dfn> of the map entry and |v| is called the <dfn data-lt="value of map entry">value</dfn> of the map entry.
      </p>
      <p>
        Given a <a>term map</a>&nbsp;|tm| and a <a>map entry</a>&nbsp;(|k|,|v|), we say that |tm| <dfn data-lt="contains map entry">contains</dfn> this map entry if |k| is in the <a href="https://en.wikipedia.org/wiki/Domain_of_a_function">domain</a> of |tm| and |tm| maps |k| to |v|; i.e., |tm|(|k|)=|v|.
      </p>

      <p class="note">
        The <a>empty term map</a> does not <a>contain</a> any map entries.
      </p>

      <div class="note">
        <p>
          A <a>term map</a> MAY <a>contain</a> multiple map entries that all have the same <a>value</a>, but they MUST have different <a>keys</a>. It is possible, however, that multiple map entries of a term map MAY have literals with the same <a data-cite="RDF11-CONCEPTS#dfn-literal-value">literal value</a> as their respective keys, as long as all these literals have a different lexical form. For instance, a term map MAY contain two map entries, (|k|,|v|) and (<var>k'</var>,<var>v'</var>), such that |k| is the literal `"0042"^^xsd:integer` and <var>k'</var> is the literal `"42"^^xsd:integer` (using a Turtle representation of these literals for the sake of readability). Clearly, these are two different literals and, thus, two different map keys, but their literal value is the same (the integer&nbsp;42).
        </p>
        <p>
          Distinguishing map keys that are literals based on their lexical form rather than their value is a deliberate design decision. If the distinction was based on the value instead, then the distinction could be made only for literals with <a data-cite="RDF11-CONCEPTS#dfn-recognized-datatype-iris">recognized datatype IRIs</a>. This would not only raise the question of what to do with map keys that are literals with an unrecognized datatype IRI, but it would also make the notion of map keys (and what makes them different from one another) dependent on the set of datatype IRIs recognized by the RDF processing system. Such a dependency may then result in different and potentially incompatible behavior in terms of how cdt:Map literals are handled by different RDF processing systems that support different sets of recognized datatype IRIs. Distinguishing map keys that are literals based on their lexical form avoids such incompatibilities.
        </p>
      </div>

    </section>

    <section id="map-datatype-lexspace">
      <h2>Lexical Space</h2>

      <p>
        The <a data-cite="RDF11-CONCEPTS#dfn-lexical-space">lexical space</a> of the <a>cdt:Map datatype</a> consists of all strings that are recognized by the <a href="#cdt-grammar-production-Map">`Map`</a> production of the grammar defined in Section&nbsp;<a href="#list-datatype-lexspace" class="sectionRef"></a> and in which all substrings that matched the <a href="#cdt-grammar-production-MapKey">`MapKey`</a> production are different from one another.
      </p>

      <div class="issue">
        <p>
          The constraint about the substrings is not restrictive enough because the <a href="#cdt-grammar-production-MapKey">`MapKey`</a> production recognizes both the generic way of serializing literals in Turtle and the Turtle shorthand notations for some datatypes. For instance, consider the following string:
        </p>
        <pre class="nohighlight">
          "{ 42 : 'value1',  '42'^^&lt;http://www.w3.org/2001/XMLSchema#integer> : 'value2' }"
        </pre>
        <p>
          This string satisfies the definition given above (including the constraint about the substrings) and, thus, would be a valid lexical form for cdt:Map literals. Yet, the keys of the two map entries represented in this string are the exact same literal, which is illegal according to the definition of <a>term maps</a>.
        </p>
      </div>

    </section>

    <section id="map-datatype-lex-to-value-mapping">
      <h2>Lexical-To-Value Mapping</h2>

      <p>
        The <a data-cite="RDF11-CONCEPTS#dfn-lexical-to-value-mapping">lexical-to-value mapping</a> of the <a>cdt:Map datatype</a> is defined as follows for every string&nbsp;|S| that is recognized by the <a href="#cdt-grammar-production-Map">`Map`</a> production of the grammar defined in Section&nbsp;<a href="#list-datatype-lexspace" class="sectionRef"></a>. The definition assumes the same <i><a>bnl2bn</a></i> function as assumed for the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping of the cdt:List datatype</a>.
      </p>
      <p>
        If the string&nbsp;|S| does <em>not</em> contain a substring that is recognized by the <a href="#cdt-grammar-production-NonEmptyMapContent">`NonEmptyMapContent`</a> production of the grammar, then |S| is mapped to the <a>empty term map</a>.
      </p>
      <p>
        Otherwise, let |S|' be the greatest substring of |S| that is recognized by the <a href="#cdt-grammar-production-NonEmptyMapContent">`NonEmptyMapContent`</a> production, let (|E|<sub>1</sub>, ..., |E|<sub>|n|</sub>) be the sequence of all substrings of |S|' that are recognized by the <a href="#cdt-grammar-production-MapEntry">`MapEntry`</a> production, and for every |i| in {1, ..., |n|}, let <var>K<sub>|i|</sub></var> and <var>V<sub>|i|</sub></var> be the substrings of <var>E<sub>|i|</sub></var> that are recognized by the <a href="#cdt-grammar-production-MapKey">`MapKey`</a> and the <a href="#cdt-grammar-production-MapValue">`MapValue`</a> productions, respectively.
        Then, |S| is mapped to the <a>term map</a>&nbsp;|tm| that <a>contains</a> |n| <a>map entries</a>, one for each substring&nbsp;<var>E<sub>|i|</sub></var>, where |i| in {1, ..., |n|}. The particular map entry (<var>k<sub>|i|</sub></var>,<var>v<sub>|i|</sub></var>) that |tm| contains for <var>E<sub>|i|</sub></var> depends on which of the cases of the <a href="#cdt-grammar-production-MapKey">`MapKey`</a> and the <a href="#cdt-grammar-production-MapValue">`MapValue`</a> productions recognize <var>K<sub>|i|</sub></var> and <var>V<sub>|i|</sub></var>. In particular, depending on <var>K<sub>|i|</sub></var>, <var>k<sub>|i|</sub></var> is defined as follows.
        <ul>
          <li>
            If <var>K<sub>|i|</sub></var> is recognized by the <a data-cite="TURTLE#grammar-production-IRIREF">`IRIREF`</a> production, then <var>k<sub>|i|</sub></var> is the IRI constructed from the substring <var>K<sub>|i|</sub></var> according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]].
          </li>
          <li>
            If <var>K<sub>|i|</sub></var> is recognized by the <a href="#cdt-grammar-production-RDFLiteral">`RDFLiteral`</a> production, then <var>k<sub>|i|</sub></var> is a literal that has as its lexical form the string that has matched the first rule argument, <a data-cite="TURTLE#grammar-production-String">`String`</a>, and the datatype IRI and language tag of the literal are as follows.
            <ul>
              <li>If the <a data-cite="TURTLE#grammar-production-LANGTAG">`LANGTAG`</a> rule matched, the datatype IRI is `rdf:langString` and the language tag is the string that has matched the <a data-cite="TURTLE#grammar-production-LANGTAG">`LANGTAG`</a> rule.</li>
              <li>If the `'^^'`<a data-cite="TURTLE#grammar-production-IRIREF">`IRIREF`</a> rule matched, the datatype IRI is the IRI constructed from the <a data-cite="TURTLE#grammar-production-IRIREF">`IRIREF`</a> match according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]], and the literal has no language tag.</li>
              <li>If neither matched, the datatype is `xsd:string` and the literal has no language tag.</li>
            </ul>
          </li>
          <li>
            If <var>K<sub>|i|</sub></var> is recognized by either the <a data-cite="TURTLE#grammar-production-NumericLiteral">`NumericLiteral`</a> production or the <a data-cite="TURTLE#grammar-production-BooleanLiteral">`BooleanLiteral`</a> production, then <var>k<sub>|i|</sub></var> is the literal constructed from the substring <var>K<sub>|i|</sub></var> according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]].
          </li>
        </ul>
        Moreover, depending on <var>V<sub>|i|</sub></var>, <var>v<sub>|i|</sub></var> is defined as follows.
        <ul>
          <li>
            If <var>V<sub>|i|</sub></var> is recognized by the <a data-cite="TURTLE#grammar-production-IRIREF">`IRIREF`</a> production, then <var>v<sub>|i|</sub></var> is the IRI constructed from the substring <var>V<sub>|i|</sub></var> according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]].
          </li>
          <li>
            If <var>V<sub>|i|</sub></var> is recognized by the <a data-cite="TURTLE#grammar-production-BLANK_NODE_LABEL">`BLANK_NODE_LABEL`</a> production, then <var>v<sub>|i|</sub></var> is the blank node <i><a>bnl2bn</a></i>(<var>V<sub>|i|</sub></var>).
          </li>
          <li>
            If <var>V<sub>|i|</sub></var> is recognized by the <a href="#cdt-grammar-production-RDFLiteral">`RDFLiteral`</a> production, then <var>v<sub>|i|</sub></var> is a literal that has as its lexical form the string that has matched the first rule argument, <a data-cite="TURTLE#grammar-production-String">`String`</a>, and the datatype IRI and language tag of the literal are as follows.
            <ul>
              <li>If the <a data-cite="TURTLE#grammar-production-LANGTAG">`LANGTAG`</a> rule matched, the datatype IRI is `rdf:langString` and the language tag is the string that has matched the <a data-cite="TURTLE#grammar-production-LANGTAG">`LANGTAG`</a> rule.</li>
              <li>If the `'^^'`<a data-cite="TURTLE#grammar-production-IRIREF">`IRIREF`</a> rule matched, the datatype IRI is the IRI constructed from the <a data-cite="TURTLE#grammar-production-IRIREF">`IRIREF`</a> match according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]], and the literal has no language tag.</li>
              <li>If neither matched, the datatype is `xsd:string` and the literal has no language tag.</li>
            </ul>
          </li>
          <li>
            If <var>V<sub>|i|</sub></var> is recognized by either the <a data-cite="TURTLE#grammar-production-NumericLiteral">`NumericLiteral`</a> production or the <a data-cite="TURTLE#grammar-production-BooleanLiteral">`BooleanLiteral`</a> production, then <var>v<sub>|i|</sub></var> is the literal constructed from the substring <var>V<sub>|i|</sub></var> according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]].
          </li>
          <li>
            If <var>V<sub>|i|</sub></var> is recognized by the <a href="#cdt-grammar-production-NULL">`NULL`</a> production, then <var>v<sub>|i|</sub></var> is <a>null</a>.
          </li>
          <li>
            If <var>V<sub>|i|</sub></var> is recognized by the <a href="#cdt-grammar-production-List">`List`</a> production, then <var>v<sub>|i|</sub></var> is the literal that has the string <var>V<sub>|i|</sub></var> as its lexical form, the IRI `cdt:List` as its datatype IRI, and no language tag.
          </li>
          <li>
            If <var>V<sub>|i|</sub></var> is recognized by the <a href="#cdt-grammar-production-Map">`Map`</a> production, then <var>v<sub>|i|</sub></var> is the literal that has the string <var>V<sub>|i|</sub></var> as its lexical form, the IRI `cdt:Map` as its datatype IRI, and no language tag.
          </li>
        </ul>
      </p>
      <p>
        Since producing the <a>term map</a> for |S| as defined above relies on the capability to construct RDF terms according to the table in <a href="https://www.w3.org/TR/turtle/#sec-parsing-terms">Section&nbsp;7.2</a> of [[TURTLE]], it requires a parser that maintains state of the `bnodeLabels` mapping used for parsing Turtle, as defined in <a href="https://www.w3.org/TR/turtle/#sec-parsing-state">Section&nbsp;7.1</a> of [[TURTLE]].
      </p>

      <p class="note">
        The note about unescaping of IRIs as given in Section&nbsp;<a href="#list-datatype-lex-to-value-mapping" class="sectionRef"></a> applies here too.
      </p>

    </section>

    <section id="map-datatype-versus-json" class="informative">
      <h2>Relationship to JSON</h2>

      <p>
        By the definition of the lexical space of the <a>cdt:Map datatype</a> (see Section&nbsp;<a href="#map-datatype-lexspace" class="sectionRef"></a>), strings that match the <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-4">`object`</a> production of the grammar of the JavaScript Object Notation (JSON) [[RFC8259]] can generally be used as a lexical form of a <a>cdt:Map literal</a> (with a few exceptions related to escaping of characters in strings, see the corresponding note in the following list). When doing so, the lexical-to-value mapping of the <a>cdt:Map datatype</a> (see Section&nbsp;<a href="#map-datatype-lex-to-value-mapping" class="sectionRef"></a>) interprets the various elements of the JSON format as follows.
        <ul>
          <li>
            The <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-4">JSON object</a> that is used as the lexical form of the given <a>cdt:Map literal</a> is mapped to a <a>term map</a>. Every name-value pair of the JSON object becomes a <a>map entry</a> that is <a href="#dfn-contains-map-entry">contained</a> in the resulting term map. The <a>map key</a> of each such map entry is a literal created from the name of the corresponding name-value pair by using the rule for JSON string values as defined below. The <a>map value</a> of each such map entry depends on the type of the value of the corresponding name-value pair.
          </li>
          <li>
            A <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-3">JSON value</a> that is another <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-4">JSON object</a> is mapped to a <a>cdt:Map literal</a> that has the JSON object as its lexical form.
          </li>
          <li>
            A <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-3">JSON value</a> that is an <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-5">array</a> is mapped to a <a>cdt:List literal</a> that has the JSON object as its lexical form.
          </li>
          <li>
            A <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-3">JSON value</a> that is a <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-6">number</a> is mapped to a literal with the number as the lexical form, no language tag, and a datatype IRI that is determined based on the following rules.
            <ul>
              <li>If the number has an exponent part (see the `exp` production of the JSON grammar), then the datatype IRI is `xsd:double`.</li>
              <li>If the number has no exponent part but it has a fraction part (see the `frac` production of the JSON grammar), then the datatype IRI is `xsd:decimal`.</li>
              <li>If the number has no exponent part and no fraction part, then the datatype IRI is `xsd:integer`.</li>
            </ul>
          </li>
          <li>
            A <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-3">JSON value</a> that is a <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-7">string</a> is mapped to a literal with datatype `xsd:string`, no language tag, and a lexical form that is the result of using the sequence of characters between the first and the last quotation mark of the string and applying Turtle's unescaping of <a href="https://www.w3.org/TR/turtle/#numeric">numeric escape sequences</a> and <a href="https://www.w3.org/TR/turtle/#string">string escape sequences</a> to this sequence of characters.
            <p class="note">
              The support for escaping of characters in <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-7">strings</a> in JSON goes beyond the <a href="https://www.w3.org/TR/turtle/#numeric">numeric escape sequences</a> and <a href="https://www.w3.org/TR/turtle/#string">string escape sequences</a> in Turtle. In particular, while both Turtle's string escape sequences and JSON support the two-character sequence '\\' to represent the reverse solidus character (i.e., codepoint <a href="https://util.unicode.org/UnicodeJsps/character.jsp?a=005C">U+005C</a> in Unicode), only JSON supports the two-character sequence '\/' to represent the solidus character (codepoint <a href="https://util.unicode.org/UnicodeJsps/character.jsp?a=002F">U+002F</a>). JSON strings that use this two-character escape sequence cannot be used as a lexical form of a cdt:Map literal; attempting to do so will result in a parser error. Moreover, JSON supports encoding of UTF-16 surrogate pairs using 12-character sequences of the form '\uNNNN\uNNNN' which are not recognized by the numeric escape sequences of Turtle as a singular pair. Hence, when using a JSON string with such surrogate pairs as a lexical form of a cdt:Map literal, then the surrogate pairs are not unescaped correctly.
            </p>
          </li>
          <li>
            A <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-3">JSON value</a> that is the name `false` or the name `true` is mapped to a literal with datatype `xsd:boolean`, no language tag, and a lexical form that is the JSON value (i.e., `false` or `true`).
          </li>
          <li>
            A <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-3">JSON value</a> that is the name `null` is mapped to <a>null</a>.
          </li>
        </ul>
      </p>

    </section>

  </section>



  <section id="extension-of-sparql-operators">
    <h2>Extensions of Existing SPARQL Operators</h2>

    <p>
      This section defines extensions of some of the existing operators of SPARQL. In particular, the `=` operator and the `!=` operator are extended both for <a>cdt:List literals</a> and for <a>cdt:Map literals</a>. Implementations of SPARQL that recognize the datatypes defined above MUST implement these operators with the extensions defined in this section.
    </p>

    <p>
      To define the extensions formally, the operator mapping table for binary operators in <a data-cite="SPARQL11-QUERY#OperatorMapping">Section&nbsp;17.3</a> of [[SPARQL11-QUERY]] is extended with the following twelve rows.
    </p>

    <table class="operator">
      <thead>
        <tr>
          <th>Operator</th>
          <th>Type(A)</th>
          <th>Type(B)</th>
          <th>Function</th>
          <th>Result type</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="font-weight:bold">
          <a data-cite="SPARQL11-QUERY#rRelationalExpression">A = B</a></td>
          <td>cdt:List</td>
          <td>cdt:List</td>
          <td><a href="#func_list-equal">list-equal</a>(A, B)</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a data-cite="SPARQL11-QUERY#rRelationalExpression">A = B</a></td>
          <td>cdt:Map</td>
          <td>cdt:Map</td>
          <td><a href="#func_map-equal">map-equal</a>(A, B)</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a data-cite="SPARQL11-QUERY#rRelationalExpression">A != B</a></td>
          <td>cdt:List</td>
          <td>cdt:List</td>
          <td><a href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a href="#func_list-equal">list-equal</a>(A, B))</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a data-cite="SPARQL11-QUERY#rRelationalExpression">A != B</a></td>
          <td>cdt:Map</td>
          <td>cdt:Map</td>
          <td><a href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a href="#func_map-equal">map-equal</a>(A, B))</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a data-cite="SPARQL11-QUERY#rRelationalExpression">A &lt; B</a></td>
          <td>cdt:List</td>
          <td>cdt:List</td>
          <td><a href="#func_list-less-than">list-less-than</a>(A, B)</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a data-cite="SPARQL11-QUERY#rRelationalExpression">A &lt; B</a></td>
          <td>cdt:Map</td>
          <td>cdt:Map</td>
          <td><a href="#func_map-less-than">map-less-than</a>(A, B)</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a data-cite="SPARQL11-QUERY#rRelationalExpression">A &gt; B</a></td>
          <td>cdt:List</td>
          <td>cdt:List</td>
          <td><a href="#func_list-less-than">list-less-than</a>(B, A)</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a data-cite="SPARQL11-QUERY#rRelationalExpression">A &gt; B</a></td>
          <td>cdt:Map</td>
          <td>cdt:Map</td>
          <td><a href="#func_map-less-than">map-less-than</a>(B, A)</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a data-cite="SPARQL11-QUERY#rRelationalExpression">A &lt;= B</a></td>
          <td>cdt:List</td>
          <td>cdt:List</td>
          <td><a data-cite="SPARQL11-QUERY#func-logical-or">logical-or</a>(<a href="#func_list-less-than">list-less-than</a>(A, B), <a href="#func_list-equal">list-equal</a>(A, B))</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a data-cite="SPARQL11-QUERY#rRelationalExpression">A &lt;= B</a></td>
          <td>cdt:Map</td>
          <td>cdt:Map</td>
          <td><a data-cite="SPARQL11-QUERY#func-logical-or">logical-or</a>(<a href="#func_map-less-than">map-less-than</a>(A, B), <a href="#func_map-equal">map-equal</a>(A, B))</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a data-cite="SPARQL11-QUERY#rRelationalExpression">A &gt;= B</a></td>
          <td>cdt:List</td>
          <td>cdt:List</td>
          <td><a data-cite="SPARQL11-QUERY#func-logical-or">logical-or</a>(<a href="#func_list-less-than">list-less-than</a>(B, A), <a href="#func_list-equal">list-equal</a>(A, B))</td>
          <td>xsd:boolean</td>
        </tr>
        <tr>
          <td style="font-weight:bold">
          <a data-cite="SPARQL11-QUERY#rRelationalExpression">A &gt;= B</a></td>
          <td>cdt:Map</td>
          <td>cdt:Map</td>
          <td><a data-cite="SPARQL11-QUERY#func-logical-or">logical-or</a>(<a href="#func_map-less-than">map-less-than</a>(B, A), <a href="#func_map-equal">map-equal</a>(A, B))</td>
          <td>xsd:boolean</td>
        </tr>
      </tbody>
    </table>

    <p>
      The four new functions used in these table rows are defined in Subsections&nbsp;<a href="#func_list-equal" class="sectionRef"></a>, <a href="#func_map-equal" class="sectionRef"></a>, <a href="#func_list-less-than" class="sectionRef"></a>, and <a href="#func_map-less-than" class="sectionRef"></a> below.
    </p>

    <p class="note">
      It should be noted that extending the operator mapping table with these twelve rows changes the behavior of the corresponding operators (`=`, `!=`, `&lt;`, `&gt;`, `&lt;=`, and `&gt;=`) only for cases in which these operators would otherwise (i.e., without the extension) yield a type error. Therefore, this extension is conformant with the SPARQL specification, as explicitly stated in <a data-cite="SPARQL11-QUERY#operatorExtensibility">Section&nbsp;17.3.1</a> of [[SPARQL11-QUERY]].
    </p>

    <section id="func_list-equal">
      <h2>list-equal</h2>

      <p>
        <code>xsd:boolean </code>
        <code style="color:black;font-weight:bold">list-equal</code>
        (
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term<sub>1</sub></var></code>,
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term<sub>2</sub></var></code>
        )
      </p>

      <p>
        This function cannot be used directly in expressions. Instead, the purpose of this function is to define the semantics of the `=` operator when applied to two <a>cdt:List literals</a>.
      </p>

      <p>
        If both <var>term<sub>1</sub></var> and <var>term<sub>2</sub></var> are <a>well-formed cdt:List literals</a>, then the result of this function is determined by the following algorithm.
      </p>
      <div class="algorithm">
        <ol>
          <li>Let <var>list<sub>1</sub></var> be the <a>term list</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a>cdt:List datatype</a> to the <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> of <var>term<sub>1</sub></var> (i.e., <var>list<sub>1</sub></var> is the <a data-cite="RDF11-CONCEPTS#dfn-literal-value">value</a> of <var>term<sub>1</sub></var>).</li>
          <li>Let <var>list<sub>2</sub></var> be the <a>term list</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a>cdt:List datatype</a> to the <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> of <var>term<sub>2</sub></var> (i.e., <var>list<sub>2</sub></var> is the <a data-cite="RDF11-CONCEPTS#dfn-literal-value">value</a> of <var>term<sub>2</sub></var>).</li>
          <li>If both <var>list<sub>1</sub></var> and <var>list<sub>2</sub></var> are the <a>empty term list</a>, then return `true`.</li>
          <li>If the length of <var>list<sub>1</sub></var> is different from the length of <var>list<sub>2</sub></var>, then return `false`.</li>
          <li>For every integer |i| from 1 to |n|, where |n| is the length of <var>list<sub>1</sub></var>:
            <ol>
              <li>Let <var>elmt<sub>1</sub></var> be the |i|-th element in <var>list<sub>1</sub></var>.</li>
              <li>Let <var>elmt<sub>2</sub></var> be the |i|-th element in <var>list<sub>2</sub></var>.</li>
              <li>If <var>elmt<sub>1</sub></var> is <a>null</a> and <var>elmt<sub>2</sub></var> is not <a>null</a>, return `false`.</li>
              <li>If <var>elmt<sub>2</sub></var> is <a>null</a> and <var>elmt<sub>1</sub></var> is not <a>null</a>, return `false`.</li>
              <li>If neither <var>elmt<sub>1</sub></var> nor <var>elmt<sub>2</sub></var> is <a>null</a>, then:
                <ol>
                  <li>If <var>elmt<sub>1</sub></var> is a blank node and <var>elmt<sub>2</sub></var> is a blank node, terminate with an error.</li>
                  <li>If evaluating the SPARQL expression <var>elmt<sub>1</sub></var> = <var>elmt<sub>2</sub></var> results in an error, terminate with an error.</li>
                  <li>If evaluating the SPARQL expression <var>elmt<sub>1</sub></var> = <var>elmt<sub>2</sub></var> results in `false`, return `false`.</li>
                </ol>
              </li>
            </ol>
          </li>
          <li>Return `true`.</li>
        </ol>
      </div>

      <p>
        If <var>term<sub>1</sub></var> or <var>term<sub>2</sub></var> is an <a>ill-formed cdt:List literal</a>, then this function produces an error.
      </p>

      <div class="note">
        Whenever the given algorithm, during its pairwise comparison of the elements of the two given lists, comes across a pair in which both elements are <a>null</a>, the algorithm advances to the next pair of elements. In this sense, the algorithm considers null values to be indistinguishable from one another. This behavior is necessary to guarantee that an expression such as the following evaluates to `true` (rather than to `false` or to an error).
        <pre data-content-type="application/sparql-query" class="nohighlight">
          "[null]"^^cdt:List = "[null]"^^cdt:List
        </pre>
        Guaranteeing that this expression evaluates to `true` is necessary for the following reason. Notice that the two arguments in this expression are identical (i.e., they are the same literal, with the same lexical form and the same datatype IRI). Therefore, by the definition of the `=` operator in [[SPARQL11-QUERY]], the evaluation of the expression is `true` if `cdt:List` is <em>not</em> in the set of <a data-cite="RDF11-CONCEPTS#dfn-recognized-datatype-iris">recognized datatype IRIs</a> (i.e., if the RDF processing system does not support `cdt:List`). Then, the version of the `=` operator for systems that support `cdt:List` (i.e., the version of the operator as defined by the list-equal function in this section) must also return `true`, because "no additional operator may yield a result that replaces any result other than a type error" (see <a data-cite="SPARQL11-QUERY#operatorExtensibility">Section&nbsp;17.3.1</a> of [[SPARQL11-QUERY]]).
      </div>

    </section>

    <section id="func_map-equal">
      <h2>map-equal</h2>

      <p>
        <code>xsd:boolean </code>
        <code style="color:black;font-weight:bold">map-equal</code>
        (
           <code><a href="#dfn-cdt-map-literal">cdt:Map</a> <var>term<sub>1</sub></var></code>,
           <code><a href="#dfn-cdt-map-literal">cdt:Map</a> <var>term<sub>2</sub></var></code>
        )
      </p>

      <p>
        This function cannot be used directly in expressions. Instead, the purpose of this function is to define the semantics of the `=` operator when applied to two <a>cdt:Map literals</a>.
      </p>

      <p>
        If both <var>term<sub>1</sub></var> and <var>term<sub>2</sub></var> are <a>well-formed cdt:Map literals</a>, then the result of this function is determined by the following algorithm.
      </p>
      <div class="algorithm">
        <ol>
          <li>Let <var>map<sub>1</sub></var> be the <a>term map</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a>cdt:Map datatype</a> to the <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> of <var>term<sub>1</sub></var> (i.e., <var>map<sub>1</sub></var> is the <a data-cite="RDF11-CONCEPTS#dfn-literal-value">value</a> of <var>term<sub>1</sub></var>).</li>
          <li>Let <var>map<sub>2</sub></var> be the <a>term map</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a>cdt:Map datatype</a> to the <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> of <var>term<sub>2</sub></var> (i.e., <var>map<sub>2</sub></var> is the <a data-cite="RDF11-CONCEPTS#dfn-literal-value">value</a> of <var>term<sub>2</sub></var>).</li>
          <li>If both <var>map<sub>1</sub></var> and <var>map<sub>2</sub></var> are the <a>empty term map</a>, then return `true`.</li>
          <li>If the number of <a>map entries</a> that <var>map<sub>1</sub></var> <a href="#dfn-contains-map-entry">contains</a> is different from the number of <a>map entries</a> that <var>map<sub>2</sub></var> <a href="#dfn-contains-map-entry">contains</a>, then return `false`.</li>
          <li>Let |error| be a boolean-typed flag that is initialized with the value `false`.</li>
          <li>For every <a>map entry</a> (|k|, <var>v<sub>1</sub></var>) <a href="#dfn-contains-map-entry">contained</a> in <var>map<sub>1</sub></var>:
            <ol>
              <li>If |k| is not in the domain of <var>map<sub>2</sub></var>, return `false`.</li>
              <li>Let <var>v<sub>2</sub></var> be the map value <var>map<sub>2</sub></var>(|k|).</li>
              <li>If <var>v<sub>1</sub></var> is <a>null</a> and <var>v<sub>2</sub></var> is not <a>null</a>, return `false`.</li>
              <li>If <var>v<sub>2</sub></var> is <a>null</a> and <var>v<sub>1</sub></var> is not <a>null</a>, return `false`.</li>
              <li>If neither <var>v<sub>1</sub></var> nor <var>v<sub>2</sub></var> is <a>null</a>, then:
                <ol>
                  <li>If <var>v<sub>1</sub></var> is a blank node and <var>v<sub>2</sub></var> is a blank node, set |error| to `true` and move on to the next map entry in <var>map<sub>1</sub></var> (i.e., skip over the remaining instructions within this for loop).</li>
                  <li>If evaluating the SPARQL expression <var>v<sub>2</sub></var> = <var>v<sub>1</sub></var> results in an error, set |error| to `true` and move on to the next map entry in <var>map<sub>1</sub></var> (i.e., skip over the remaining instructions within this for loop).</li>
                  <li>If evaluating the SPARQL expression <var>v<sub>2</sub></var> = <var>v<sub>1</sub></var> results in `false`, return `false`.</li>
                </ol>
              </li>
            </ol>
          </li>
          <li>If |error| is `true`, terminate with an error.</li>
          <li>Return `true`.</li>
        </ol>
      </div>

      <p>
        If <var>term<sub>1</sub></var> or <var>term<sub>2</sub></var> is an <a>ill-formed cdt:Map literal</a>, then this function produces an error.
      </p>

    </section>

    <section id="func_list-less-than">
      <h2>list-less-than</h2>

      <p>
        <code>xsd:boolean </code>
        <code style="color:black;font-weight:bold">list-less-than</code>
        (
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term<sub>1</sub></var></code>,
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term<sub>2</sub></var></code>
        )
      </p>

      <p>
        This function cannot be used directly in expressions. Instead, the purpose of this function is to define the semantics of the `&lt;` operator when applied to two <a>cdt:List literals</a>.
      </p>

      <p>
        If both <var>term<sub>1</sub></var> and <var>term<sub>2</sub></var> are <a>well-formed cdt:List literals</a>, then the result of this function is determined by the following algorithm.
      </p>
      <div class="algorithm">
        <ol>
          <li>Let <var>list<sub>1</sub></var> be the <a>term list</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a>cdt:List datatype</a> to the <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> of <var>term<sub>1</sub></var> (i.e., <var>list<sub>1</sub></var> is the <a data-cite="RDF11-CONCEPTS#dfn-literal-value">value</a> of <var>term<sub>1</sub></var>).</li>
          <li>Let <var>list<sub>2</sub></var> be the <a>term list</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a>cdt:List datatype</a> to the <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> of <var>term<sub>2</sub></var> (i.e., <var>list<sub>2</sub></var> is the <a data-cite="RDF11-CONCEPTS#dfn-literal-value">value</a> of <var>term<sub>2</sub></var>).</li>
          <li>If both <var>list<sub>1</sub></var> and <var>list<sub>2</sub></var> are the <a>empty term list</a>, then return `false`.</li>
          <li>For every integer |i| from 1 to |n|, where |n| is the minimum of the length of <var>list<sub>1</sub></var> and the length of <var>list<sub>2</sub></var>:
            <ol>
              <li>Let <var>elmt<sub>1</sub></var> be the |i|-th element in <var>list<sub>1</sub></var>.</li>
              <li>Let <var>elmt<sub>2</sub></var> be the |i|-th element in <var>list<sub>2</sub></var>.</li>
              <li>If <var>elmt<sub>1</sub></var> is <a>null</a> and <var>elmt<sub>2</sub></var> is <a>null</a>, return `false`.</li>
              <li>If <var>elmt<sub>1</sub></var> is <a>null</a> or <var>elmt<sub>2</sub></var> is <a>null</a>, terminate with an error.</li>
              <li>If <var>elmt<sub>1</sub></var> is a blank node and <var>elmt<sub>2</sub></var> is a blank node, terminate with an error.</li>
              <li>If evaluating the SPARQL expression <var>elmt<sub>1</sub></var> `&lt;` <var>elmt<sub>2</sub></var> results in `true` or in `false` (i.e., not in an error), return this result.</li>
              <li>If evaluating the SPARQL expression <var>elmt<sub>1</sub></var> `=` <var>elmt<sub>2</sub></var> results in an error, terminate with an error.</li>
              <li>If evaluating the SPARQL expression <var>elmt<sub>1</sub></var> `=` <var>elmt<sub>2</sub></var> results in `false`, return `false`.</li>
            </ol>
          </li>
          <li>If the length of <var>list<sub>1</sub></var> is smaller than the length of <var>list<sub>2</sub></var>, return `true`.</li>
          <li>Return `false`.</li>
        </ol>
      </div>

      <p>
        If <var>term<sub>1</sub></var> or <var>term<sub>2</sub></var> is an <a>ill-formed cdt:List literal</a>, then this function produces an error.
      </p>

    </section>

    <section id="func_map-less-than">
      <h2>map-less-than</h2>

      <p>
        <code>xsd:boolean </code>
        <code style="color:black;font-weight:bold">map-less-than</code>
        (
           <code><a href="#dfn-cdt-map-literal">cdt:Map</a> <var>term<sub>1</sub></var></code>,
           <code><a href="#dfn-cdt-map-literal">cdt:Map</a> <var>term<sub>2</sub></var></code>
        )
      </p>

      <p>
        This function cannot be used directly in expressions. Instead, the purpose of this function is to define the semantics of the `&lt;` operator when applied to two <a>cdt:Map literals</a>.
      </p>

      <p>
        If both <var>term<sub>1</sub></var> and <var>term<sub>2</sub></var> are <a>well-formed cdt:Map literals</a>, then the result of this function is determined by the following algorithm.
      </p>
      <div class="algorithm">
        <ol>
          <li>Let <var>map<sub>1</sub></var> be the <a>term map</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a>cdt:Map datatype</a> to the <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> of <var>term<sub>1</sub></var> (i.e., <var>map<sub>1</sub></var> is the <a data-cite="RDF11-CONCEPTS#dfn-literal-value">value</a> of <var>term<sub>1</sub></var>).</li>
          <li>Let <var>map<sub>2</sub></var> be the <a>term map</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a>cdt:Map datatype</a> to the <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> of <var>term<sub>2</sub></var> (i.e., <var>map<sub>2</sub></var> is the <a data-cite="RDF11-CONCEPTS#dfn-literal-value">value</a> of <var>term<sub>2</sub></var>).</li>
          <li>If both <var>map<sub>1</sub></var> and <var>map<sub>2</sub></var> are the <a>empty term map</a>, then return `false`.</li>
          <li>Let <var>entryset<sub>1</sub></var> be the set of all <a>map entries</a> that are <a href="#dfn-contains-map-entry">contained</a> in <var>map<sub>1</sub></var>.</li>
          <li>Let <var>entryset<sub>2</sub></var> be the set of all <a>map entries</a> that are <a href="#dfn-contains-map-entry">contained</a> in <var>map<sub>2</sub></var>.</li>
          <li>Let <var>entrylist<sub>1</sub></var> be a list of all map entries in <var>entryset<sub>1</sub></var>, ordered based on their respective <a>map keys</a> by using the following order:
            <ul>
              <li>Map entries with map keys that are IRIs are listed first, ordered based on comparing the string representation of these IRIs using the `&lt;` operator (i.e., the IRIs are used as the lexical form of literals with the datatype `xsd:string` and the order is then determined by comparing these literals using the `&lt;` operator)</li>
              <li>The remaining map entries have map keys that are literals. They are primarily ordered based on the string representation of their datatype IRIs (i.e., using these datatype IRIs as the lexical form of literals with the datatype `xsd:string` and, then, determining the order by comparing these string literals using the `&lt;` operator). Literals of the same datatype are ordered based on their lexical form (i.e., replacing their datatype IRI by `xsd:string` and, then, using the `&lt;` operator for the resulting string literals). Finally, literals with datatype `rdf:langString` that have the same lexical form are sorted based on the string representation of their language tags.
              </li>
              <div class="note">The process of ordering the map entries is equivalent to performing the following query (in which `term1` is <var>term<sub>1</sub></var>).
                <pre data-content-type="application/sparql-query" class="nohighlight">
                  SELECT ?k ?v WHERE {
                    UNFOLD( term1 AS ?k, ?v )
                  }
                  ORDER BY  ISLITERAL(?k)  STR(DATATYPE(?k))  STR(?k)  LANG(?k)
                </pre>
              </div>
            </ul>
          </li>
          <li>Let <var>entrylist<sub>2</sub></var> be a list of all map entries in <var>entryset<sub>2</sub></var>, ordered in the same way as <var>entrylist<sub>1</sub></var>.</li>
          <li>For every integer |i| from 1 to |n|, where |n| is the minimum of the respective length of <var>entrylist<sub>1</sub></var> and of <var>entrylist<sub>2</sub></var>:
            <ol>
              <li>Let (<var>k<sub>1</sub></var>, <var>v<sub>1</sub></var>) be the |i|-th <a>map entry</a> in <var>entrylist<sub>1</sub></var>.</li>
              <li>Let (<var>k<sub>2</sub></var>, <var>v<sub>2</sub></var>) be the |i|-th <a>map entry</a> in <var>entrylist<sub>2</sub></var>.</li>
              <li>If evaluating the SPARQL expression <a data-cite="SPARQL11-QUERY#func-sameTerm">`SAMETERM`</a>(<var>k<sub>1</sub></var>, <var>k<sub>2</sub></var>) results in `false`, then:
                <ol>
                  <li>Return `true` if <var>k<sub>1</sub></var> is ordered before <var>k<sub>2</sub></var> according to the ordering of map keys as defined above for creating <var>entrylist<sub>1</sub></var>.</li>
                  <li>Return `false`.</li>
                </ol>
              </li>
              <li>If <var>v<sub>1</sub></var> is <a>null</a> and <var>v<sub>2</sub></var> is <a>null</a>, return `false`.</li>
              <li>If <var>v<sub>1</sub></var> is <a>null</a> or <var>v<sub>2</sub></var> is <a>null</a>, terminate with an error.</li>
              <li>If evaluating the SPARQL expression <var>v<sub>1</sub></var> &lt; <var>v<sub>2</sub></var> results in `true` or in `false` (i.e., not an error), return this result.</li>

              <li>If evaluating the SPARQL expression <var>v<sub>1</sub></var> = <var>v<sub>2</sub></var> results in an error, terminate with an error.</li>
              <li>If evaluating the SPARQL expression <var>v<sub>1</sub></var> = <var>v<sub>2</sub></var> results in `false`, return `false`.</li>
            </ol>
          </li>
          <li>Return `true` if the length of <var>entrylist<sub>1</sub></var> is smaller than the length of <var>entrylist<sub>2</sub></var>.</li>
          <li>Return `false`.</li>
        </ol>
      </div>

      <p>
        If <var>term<sub>1</sub></var> or <var>term<sub>2</sub></var> is an <a>ill-formed cdt:Map literal</a>, then this function produces an error.
      </p>

    </section>

  </section>


  <section id="combined-functions">
    <h2>Functions on Lists and Maps</h2>

    <p>
      This section defines <a data-cite="SPARQL11-QUERY#extensionFunctions">SPARQL extension functions</a> which operate over both <a>cdt:List literals</a> and <a>cdt:Map literals</a>. These functions can be used in SPARQL expressions for testing values in FILTER clauses and for assigning values in, e.g., BIND clauses and SELECT expressions.
    </p>

    <p>
      These extension functions are evaluated as defined in <a data-cite="SPARQL11-QUERY#invocation">Section&nbsp;17.2.1</a> of [[SPARQL11-QUERY]].
    </p>

    <section id="func_get">
      <h2>cdt:get</h2>

      <p>
        <code><a data-cite="RDF11-CONCEPTS#dfn-rdf-term">RDF term</a> </code>
        <code style="color:black;font-weight:bold">cdt:get</code>
        (
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term</var></code>,
           <code>xsd:integer <var>idx</var></code>
        )
      </p>

      <p>
        If <var>term</var> is a <a>well-formed cdt:List literal</a>, the value of <var>idx</var> is greater than 0 (zero) and smaller or equal than the number of elements of the <a>term list</a> represented by <var>term</var>, and the element at the <var>idx</var>-th position of the term list represented by <var>term</var> is an <a data-cite="RDF11-CONCEPTS#dfn-rdf-term">RDF term</a> (i.e., not <a>null</a>), then the result of this function is that RDF term at the <var>idx</var>-th position of the term list represented by <var>term</var>. In all other cases an error is raised.
      </p>

      <p>
        <code><a data-cite="RDF11-CONCEPTS#dfn-rdf-term">RDF term</a> </code>
        <code style="color:black;font-weight:bold">cdt:get</code>
        (
           <code><a href="#dfn-cdt-map-literal">cdt:Map</a> <var>term</var></code>,
           <code><a data-cite="RDF11-CONCEPTS#dfn-rdf-term">RDF term</a> <var>key</var></code>
        )
      </p>

      <p>
        If <var>term</var> is a <a>well-formed cdt:Map literal</a>, and there exists a <a>map entry</a> (<var>k</var>,<var>v</var>) in the <a>term map</a> represented by <var>term</var> where <var>k</var> is the same term as <var>key</var> and <var>v</var> is an <a data-cite="RDF11-CONCEPTS#dfn-rdf-term">RDF term</a> (i.e., not <a>null</a>), then the result of this function is <var>v</var>. In all other cases an error is raised.
      </p>


      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:get( "[&lt;http://example.org/a>, &lt;http://example.org/b>]"^^cdt:List, 2 )
        </pre>
        <p>
          results in the IRI `http://example.org/b`.
      </aside>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:get( "{2: &lt;http://example.org/a>, 1: &lt;http://example.org/b>}"^^cdt:Map, 2 )
        </pre>
        <p>
          results in the IRI `http://example.org/a`.
      </aside>

      <div class="note">
        By its definition as given above, <code>cdt:get</code> for cdt:List literals raises an error not only if the given cdt:List literal is not well-formed but also in the following cases:
        <ul>
          <li>if <var>term</var> is a well-formed cdt:List literal that represents the <a>empty term list</a>,</li>
          <li>if the value of <var>idx</var> is out of the bounds of the term list represented by <var>term</var>, and</li>
          <li>if the element at the <var>idx</var>-th position of the term list represented by <var>term</var> is <a>null</a>.</li>
        </ul>
        Similarly, <code>cdt:get</code> for cdt:Map literals raises an error not only if the given cdt:Map literal is not well-formed but also in the following cases:
        <ul>
          <li>if <var>term</var> is a well-formed cdt:Map literal that represents the <a>empty term map</a>,</li>
          <li>if <var>key</var> is not a map key in the term map represented by <var>term</var>, and</li>
          <li>if the value associated with <var>key</var> in the term map represented by <var>term</var> is <a>null</a>.</li>
        </ul>
      </div>

      <p class="note">
        The list version of the function uses a 1-based numbering scheme to address the elements in term list (i.e., the first element of a term list is addressed by an |idx| value of 1), in contrast to a 0-based numbering scheme which is common for addressing elements of arrays in many programming languages. The reason for using 1-based numbering for this function is to remain consistent with existing build-in functions of SPARQL, which are also 1-based (e.g., <a data-cite="SPARQL11-QUERY#func-substr">substr</a> for string literals). Moreover, the 1-based numbering scheme is also used by functions of other W3C languages such as XPath (see, e.g., the XPath <a data-cite="XPATH-FUNCTIONS#func-array-get">array:get</a> function which is similar to cdt:get).
      </p>

    </section>

    <section id="func_size">
      <h2>cdt:size</h2>

      <p>
        <code>xsd:integer </code>
        <code style="color:black;font-weight:bold">cdt:size</code>
        (
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term</var></code>
        )
      </p>

      <p>
        If <var>term</var> is a <a>well-formed cdt:List literal</a>, then the result of this function is the number of elements that the <a>term list</a> represented by <var>term</var> contains.
      </p>
      <p>
        An error is raised if <var>term</var> is not a <a>well-formed cdt:List literal</a>.
      </p>

      <p>
        <code>xsd:integer </code>
        <code style="color:black;font-weight:bold">cdt:size</code>
        (
           <code><a href="#dfn-cdt-map-literal">cdt:Map</a> <var>term</var></code>
        )
      </p>

      <p>
        If <var>term</var> is a <a>well-formed cdt:Map literal</a>, then the result of this function is the number of map entries in the <a>term map</a> represented by <var>term</var>.
      </p>
      <p>
        An error is raised if <var>term</var> is not a <a>well-formed cdt:Map literal</a>.
      </p>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:size( "[1,'a','a',4]"^^cdt:List )
        </pre>
        <p>
          results in a literal with the datatype IRI `xsd:integer` and the value 4.
        </p>
      </aside>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:size( "{1:'a','a':4}"^^cdt:Map )
        </pre>
        <p>
          results in a literal with the datatype IRI `xsd:integer` and the value 2.
        </p>
      </aside>

    </section>

  </section>

  <section id="list-functions">
    <h2>Functions on Lists</h2>

    <p>
      This section defines <a data-cite="SPARQL11-QUERY#extensionFunctions">SPARQL extension functions</a> specifically for <a>cdt:List literals</a>. These functions can be used in SPARQL expressions for testing values in FILTER clauses and for assigning values in, e.g., BIND clauses and SELECT expressions.
    </p>

    <p>
      Except for <a href="#func_list">cdt:List</a>, these extension functions are evaluated as defined in <a data-cite="SPARQL11-QUERY#invocation">Section&nbsp;17.2.1</a> of [[SPARQL11-QUERY]]. In contrast, <a href="#func_list">cdt:List</a> is a so-called <a data-cite="SPARQL11-QUERY#func-forms">functional form</a> which has specific evaluation rules (as defined in Section&nbsp;<a href="#func_list" class="sectionRef"></a>).
    </p>

    <section id="func_list">
      <h2>cdt:List</h2>

      <p>
        <code><a href="#dfn-cdt-list-literal">cdt:List</a> </code>
        <code style="color:black;font-weight:bold">cdt:List</code>
        (
           <code><a data-cite="SPARQL11-QUERY#expressions">SPARQL expression</a> <var>expr<sub>1</sub></var></code>,
           ...,
           <code><a data-cite="SPARQL11-QUERY#expressions">SPARQL expression</a> <var>expr<sub>|n|</sub></var></code>
        )
      </p>

      <p>
        The result of this function is a <a>cdt:List literal</a> that represents a <a>term list</a>&nbsp;|tm| that contains |n| elements where, for every |i| in {1, ..., |n|}, the element at the |i|-th position of |tm| is constructed as follows. Evaluate the |i|-th expression, <var>expr<sub>|i|</sub></var>, as defined in [[SPARQL11-QUERY]]. If evaluating <var>expr<sub>|i|</sub></var> raises an error, then the element at the |i|-th position of |tm| is <a>null</a>. Otherwise, the element at the |i|-th position of |tm| is the RDF term resulting from the evaluation of <var>expr<sub>|i|</sub></var>.
      </p>
      <p>
        If the function is called without arguments, then the result is a <a>cdt:List literal</a> that represents the <a>empty term list</a>.
      </p>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:List( 'hello', ?x, ?x+1, ?y, &lt;http://example.org/a> )
        </pre>
        <p>
          for the solution mapping <var>&mu;</var>&nbsp;=&nbsp;{?x &rarr; "2"^^xsd:integer} results in the following cdt:List literal.
        </p>
        <pre class="nohighlight">
          "['hello', 2, 3, null, &lt;http://example.org/a>]"^^cdt:List
        </pre>
      </aside>

    </section>

    <section id="func_concat">
      <h2>cdt:concat</h2>

      <p>
        <code><a href="#dfn-cdt-list-literal">cdt:List</a> </code>
        <code style="color:black;font-weight:bold">cdt:concat</code>
        (
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term<sub>1</sub></var></code>,
           ...,
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term<sub>n</sub></var></code>
        )
      </p>

      <p>
        If all arguments (i.e., <var>term<sub>1</sub></var>, ..., <var>term<sub>n</sub></var>) are <a>well-formed cdt:List literals</a>, then the result of this function is a <a>cdt:List literal</a> that represents the <a>term list</a> that is the concatenation of the term lists represented by <var>term<sub>1</sub></var> to <var>term<sub>n</sub></var> (in the order in which these arguments are given). If the function is called without arguments, then the result is a <a>cdt:List literal</a> that represents the <a>empty term list</a>. If the function is called with a single argument and that argument is a well-formed cdt:List literal, then this literal is the result of this function.
      </p>
      <p>
        An error is raised if any of the arguments is not a <a>well-formed cdt:List literal</a>.
      </p>

      <p class="issue">
        We should define the notion of "represents" as used in this definition!
      </p>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:concat( "[1,2,3]"^^cdt:List, "['a',null,'a',2,3]"^^cdt:List )
        </pre>
        <p>
          results in the following cdt:List literal.
        </p>
        <pre class="nohighlight">
          "[1,2,3,'a',null,'a',2,3]"^^cdt:List
        </pre>
      </aside>

    </section>

    <section id="func_contains">
      <h2>cdt:contains</h2>

      <p>
        <code>xsd:boolean </code>
        <code style="color:black;font-weight:bold">cdt:contains</code>
        (
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term<sub>1</sub></var></code>,
           <code><a data-cite="RDF11-CONCEPTS#dfn-rdf-term">RDF term</a> <var>term<sub>2</sub></var></code>
        )
      </p>

      <p>
        If <var>term<sub>1</sub></var> is a <a>well-formed cdt:List literal</a>, then the result of this function is determined by the following algorithm.
      </p>
      <div class="algorithm">
        <ol>
          <li>If <var>term<sub>2</sub></var> is a blank node, return `false`.</li>
          <li>If the <a>term list</a> represented by <var>term<sub>1</sub></var> contains an <a data-cite="RDF11-CONCEPTS#dfn-rdf-term">RDF term</a> <var>term'</var> such that evaluating the SPARQL expression <var>term'</var> = <var>term<sub>2</sub></var> results in `true`, return `true`.</li>
          <li>Return `false`.</li>
        </ol>
      </div>

      <p>
        An error is raised if <var>term<sub>1</sub></var> is not a <a>well-formed cdt:List literal</a>.
      </p>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:contains( "[1,2,3]"^^cdt:List, "02"^^xsd:integer )
        </pre>
        <p>
          results in `true`, whereas the expression
        </p>
        <pre class="nohighlight">
          cdt:contains( "[1,2,3]"^^cdt:List, "2" )
        </pre>
        <p>
          results in `false`.
      </aside>

    </section>

    <section id="func_head">
      <h2>cdt:head</h2>

      <p>
        <code><a data-cite="RDF11-CONCEPTS#dfn-rdf-term">RDF term</a> </code>
        <code style="color:black;font-weight:bold">cdt:head</code>
        (
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term</var></code>
        )
      </p>

      <p>
        If <var>term</var> is a <a>well-formed cdt:List literal</a>, the <a>term list</a> represented by <var>term</var> contains at least one element, and the element at the first position of this term list is an <a data-cite="RDF11-CONCEPTS#dfn-rdf-term">RDF term</a> (i.e., not <a>null</a>), then the result of this function is that RDF term. In all other cases an error is raised.
      </p>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:head( "[&lt;http://example.org/a>, &lt;http://example.org/b>]"^^cdt:List )
        </pre>
        <p>
          results in the IRI `http://example.org/a`.
      </aside>

      <div class="note">
        By its definition as given above, <code>cdt:head</code> raises an error not only if the given cdt:List literal is not well-formed but also in the following cases:
        <ul>
          <li>if <var>term</var> is a well-formed cdt:List literal that represents the <a>empty term list</a>, and</li>
          <li>if the element at the first position of the term list represented by <var>term</var> is <a>null</a>.</li>
        </ul>
      </div>
    </section>

    <section id="func_reverse">
      <h2>cdt:reverse</h2>

      <p>
        <code><a href="#dfn-cdt-list-literal">cdt:List</a> </code>
        <code style="color:black;font-weight:bold">cdt:reverse</code>
        (
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term</var></code>
        )
      </p>

      <p>
        If <var>term</var> is a <a>well-formed cdt:List literal</a>, then the result of this function is a <a>cdt:List literal</a> that represents the <a>term list</a> that contains all elements of the term list represented by <var>term</var>, in the reverse order (e.g., the first element of the term list of <var>term</var> becomes the last element of the term list represented by the resulting cdt:List literal). This definition implies that
      </p>
      <ul>
        <li>if the term list of <var>term</var> consists of a single element, then the resulting cdt:List literal represents the same term list (with the same element), and</li>
        <li>if <var>term</var> represents the <a>empty term list</a>, then the resulting cdt:List literal also represents the empty term list.</li>
      </ul>
      <p>
        An error is raised if <var>term</var> is not a <a>well-formed cdt:List literal</a>.
      </p>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:reverse( "['a',2,null,4]"^^cdt:List )
        </pre>
        <p>
          results in the following cdt:List literal.
        </p>
        <pre class="nohighlight">
          "[4,null,2,'a']"^^cdt:List
        </pre>
      </aside>

    </section>

    <section id="func_subseq">
      <h2>cdt:subseq</h2>

      <p>
        <code><a href="#dfn-cdt-list-literal">cdt:List</a> </code>
        <code style="color:black;font-weight:bold">cdt:subseq</code>
        (
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term</var></code>,
           <code>xsd:integer <var>idx</var></code>
        )
      </p>

      <p>
        <code><a href="#dfn-cdt-list-literal">cdt:List</a> </code>
        <code style="color:black;font-weight:bold">cdt:subseq</code>
        (
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term</var></code>,
           <code>xsd:integer <var>idx</var></code>,
           <code>xsd:integer <var>length</var></code>
        )
      </p>

      <p>
        If <var>term</var> is a <a>well-formed cdt:List literal</a>, then the result of this function is determined as follows. Let |tm| be the <a>term list</a> represented by <var>term</var> and let |n| be the number of elements contained in |tm|.
      </p>
      <ul>
        <li>If the value of <var>idx</var> is greater than 0 (zero) and smaller than |n|+1, and <var>length</var> is not given, then the result of this function is a <a>cdt:List literal</a> that represents the term list that is the sub-sequence of |tm|, starting with the element at the |idx|-th position of |tm| and ending with the last element of |tm|.</li>
        <li>If the value of <var>idx</var> is greater than 0 (zero) and smaller than |n|+1, and the value of <var>length</var> is greater than 0 (zero) and smaller than |n|&minus;|idx|+1, then the result of this function is a <a>cdt:List literal</a> that represents the term list that is the sub-sequence of |tm|, starting with the element at the |idx|-th position of |tm| and ending with the element at position |idx|+|length|&minus;1 of |tm|.</li>
        <li>If the value of <var>idx</var> is greater than 0 (zero) and smaller than |n|+1, and the value of <var>length</var> is 0 (zero), then the result of this function is a <a>cdt:List literal</a> that represents the <a>empty term list</a>.</li>
        <li>If the value of <var>idx</var> is equal to |n|+1, and either <var>length</var> is not given or the value of <var>length</var> is 0 (zero), then the result of this function is a <a>cdt:List literal</a> that represents the <a>empty term list</a>.</li>
      </ul>
      <p>
        In all other cases an error is raised, including the case that <var>term</var> is not a <a>well-formed cdt:List literal</a>.
      </p>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:subseq( "['a',2,null,4]"^^cdt:List, 2 )
        </pre>
        <p>
          results in the following cdt:List literal.
        </p>
        <pre class="nohighlight">
          "[2,null,4]"^^cdt:List
        </pre>
      </aside>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:subseq( "['a',2,null,4]"^^cdt:List, 2, 2 )
        </pre>
        <p>
          results in the following cdt:List literal.
        </p>
        <pre class="nohighlight">
          "[2,null]"^^cdt:List
        </pre>
      </aside>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:subseq( "['a',2,null,4]"^^cdt:List, 2, 0 )
        </pre>
        <p>
          results in the following cdt:List literal.
        </p>
        <pre class="nohighlight">
          "[]"^^cdt:List
        </pre>
      </aside>

      <p class="note">
        As the <a href="#func_get">`cdt:get`</a> function, this function uses a 1-based numbering scheme to address the elements in term maps (i.e., the first element of a term map is addressed by an |idx| value of 1) in order to be consistent with existing build-in functions of SPARQL (e.g., <a data-cite="SPARQL11-QUERY#func-substr">substr</a>) and with functions in other W3C languages such as XPath (e.g., <a data-cite="XPATH-FUNCTIONS#func-array-subarray">array:subarray</a>).
      </p>

      <p class="note">
        This function corresponds to the XPath <a data-cite="XPATH-FUNCTIONS#func-array-subarray">array:subarray</a> function and, for the sake of consistency, is defined using the same rules and error conditions. As a consequence, the following special case of arguments is permitted for this function. For term maps with a size |n|>0, it is permitted to call the function with an <var>idx</var> value equal to |n|+1 as long as the value of <var>length</var> is 0 or <var>length</var> is omitted. When doing so, the result is a <a>cdt:List literal</a> that represents the <a>empty term list</a>.
      </p>

    </section>

    <section id="func_tail">
      <h2>cdt:tail</h2>

      <p>
        <code><a href="#dfn-cdt-list-literal">cdt:List</a> </code>
        <code style="color:black;font-weight:bold">cdt:tail</code>
        (
           <code><a href="#dfn-cdt-list-literal">cdt:List</a> <var>term</var></code>
        )
      </p>

      <p>
        If <var>term</var> is a <a>well-formed cdt:List literal</a> and the <a>term list</a> represented by <var>term</var> contains at least one element, then the result of this function is a <a>cdt:List literal</a> that represents the <a>term list</a> that contains all but the first element of the term list represented by <var>term</var>, where the remaining elements are kept in the same order. This definition implies that, if the term list of <var>term</var> consists of a single element, the resulting cdt:List literal must represent the <a>empty term list</a>.
      </p>
      <p>
        An error is raised if <var>term</var> is not a well-formed cdt:List literal or if it is a well-formed cdt:List literal that represents the empty term list.
      </p>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:tail( "['a',2,null,4]"^^cdt:List )
        </pre>
        <p>
          results in the following cdt:List literal.
        </p>
        <pre class="nohighlight">
          "[2,null,4]"^^cdt:List
        </pre>
      </aside>

    </section>

  </section>



  <section id="map-functions">
    <h2>Functions on Maps</h2>

    <p>
      This section defines <a data-cite="SPARQL11-QUERY#extensionFunctions">SPARQL extension functions</a> specifically for <a>cdt:Map literals</a>. These functions can be used in SPARQL expressions for testing values in FILTER clauses and for assigning values in, e.g., BIND clauses and SELECT expressions.
    </p>

    <p>
      Except for <a href="#func_map">cdt:Map</a> and <a href="#func_put">cdt:put</a>, these extension functions are evaluated as defined in <a data-cite="SPARQL11-QUERY#invocation">Section&nbsp;17.2.1</a> of [[SPARQL11-QUERY]]. In contrast, <a href="#func_map">cdt:Map</a> and <a href="#func_put">cdt:put</a> are so-called <a data-cite="SPARQL11-QUERY#func-forms">functional forms</a> which have specific evaluation rules (as defined in Section&nbsp;<a href="#func_map" class="sectionRef"></a> and Section&nbsp;<a href="#func_put" class="sectionRef"></a>, respectively).
    </p>

    <section id="func_map">
      <h2>cdt:Map</h2>

      <p>
        <code><a href="#dfn-cdt-map-literal">cdt:Map</a> </code>
        <code style="color:black;font-weight:bold">cdt:Map</code>
        (
           <code><a data-cite="SPARQL11-QUERY#expressions">SPARQL expression</a> <var>expr<sub>1</sub></var></code>,
           ...,
           <code><a data-cite="SPARQL11-QUERY#expressions">SPARQL expression</a> <var>expr<sub>|n|</sub></var></code>
        )
      </p>

      <p>
        If |n| is an even number, then the result of this function is a <a>cdt:Map literal</a> that represents a <a>term map</a>&nbsp;|tm| that contains up to |n|/2 map entries, produced by the following algorithm.
      </p>
      <div class="algorithm">
        <ol>
          <li>Initialize |tm| as the <a>empty term map</a>.</li>
          <li>For every integer |i| from 1 to |n|/2:
            <ol>
              <li>Evaluate the (2<var>i</var>-1)-th expression, <var>expr<sub>2<var>i</var>-1</sub></var>, as defined in [[SPARQL11-QUERY]].</li>
              <li>If evaluating <var>expr<sub>2<var>i</var>-1</sub></var> did not raise an error and the RDF term resulting from this evaluation is a <a>map key</a>, then:
                <ol>
                  <li>Let |k| be the RDF term resulting from the evaluation of <var>expr<sub>2<var>i</var>-1</sub></var>.</li>
                  <li>Evaluate the 2<var>i</var>-th expression, <var>expr<sub>2<var>i</var></sub></var>, as defined in [[SPARQL11-QUERY]].</li>
                  <li>Let |v| be the RDF term resulting from the evaluation of <var>expr<sub>2<var>i</var></sub></var> if this evaluation did not raise and error; otherwise, let |v| be <a>null</a>.</li>
                  <li>If |tm| contains a <a>map entry</a> (<var>k'</var>,<var>v'</var>) such that |k|=<var>k'</var>, then replace this map entry (<var>k'</var>,<var>v'</var>) by the map entry (|k|,|v|). Otherwise, add the map entry (|k|,|v|) to |tm|.</li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </div>
        
      <p>
        If |n| is an odd number, an error is raised.
      </p>

      <p class="note">
        By the given definition, every argument to this function that is meant to produce the <a>map key</a> of a <a>map entry</a> for the constructed <a>term map</a> but that evaluates to an error or to an RDF term that is not a map key is ignored, and so is the directly following argument (i.e., the expression that is meant to produce the corresponding <a>map value</a>).
      </p>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:Map( 'hello', ?x, ?x+1, ?y )
        </pre>
        <p>
          for the solution mapping <var>&mu;</var>&nbsp;=&nbsp;{?x &rarr; "2"^^xsd:integer} results in the following cdt:List literal.
        </p>
        <pre class="nohighlight">
          "{'hello': 2, 3: null}"^^cdt:Map
        </pre>
      </aside>

      <p class="note">
        If the `cdt:Map` function is called without arguments (i.e., |n|=0), then the result is a <a>cdt:Map literal</a> that represents the <a>empty term map</a>.
      </p>

    </section>

    <section id="func_containsKey">
      <h2>cdt:containsKey</h2>

      <p>
        <code>xsd:boolean </code>
        <code style="color:black;font-weight:bold">cdt:containsKey</code>
        (
           <code><a href="#dfn-cdt-map-literal">cdt:Map</a> <var>term<sub>1</sub></var></code>,
           <code><a data-cite="RDF11-CONCEPTS#dfn-rdf-term">RDF term</a> <var>term<sub>2</sub></var></code>
        )
      </p>

      <p>
        If <var>term<sub>1</sub></var> is a <a>well-formed cdt:Map literal</a>, then the result of this function is determined by the following algorithm.
      </p>
      <div class="algorithm">
        <ol>
          <li>If the <a>term map</a> represented by <var>term<sub>1</sub></var> contains a <a>map entry</a> (<var>k</var>,<var>v</var>) such that <var>k</var> is the same term as <var>term<sub>2</sub></var>, return `true`.</li>
          <li>Return `false`.</li>
        </ol>
      </div>

      <p>
        An error is raised if <var>term<sub>1</sub></var> is not a <a>well-formed cdt:Map literal</a>.
      </p>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:containsKey( "{'02'^^&lt;http://www.w3.org/2001/XMLSchema#integer>: 'two'}"^^cdt:Map, "02"^^xsd:integer )
        </pre>
        <p>
          results in `true`, whereas the expression
        </p>
        <pre class="nohighlight">
          cdt:containsKey( "{'02'^^&lt;http://www.w3.org/2001/XMLSchema#integer>: 'two'}"^^cdt:Map, 2 )
        </pre>
        <p>
          results in `false`.
      </aside>

    </section>

    <section id="func_keys">
      <h2>cdt:keys</h2>

      <p>
        <code><a href="#dfn-cdt-list-literal">cdt:List</a> </code>
        <code style="color:black;font-weight:bold">cdt:keys</code>
        (
           <code><a href="#dfn-cdt-map-literal">cdt:Map</a> <var>term</var></code>
        )
      </p>

      <p>
        If <var>term</var> is a <a>well-formed cdt:Map literal</a>, then the result of this function is a <a href="#dfn-cdt-list-literal">cdt:List literal</a> that represents a <a>term list</a> that consists of all <a>map keys</a> of the <a>map entries</a> contained in the <a>term map</a> represented by <var>term</var>.
        The order of the elements in this term list is undefined.
      </p>

      <p>
        If <var>term</var> is an <a>ill-formed cdt:Map literal</a>, then this function produces an error.
      </p>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:keys( "{'02'^^&lt;http://www.w3.org/2001/XMLSchema#integer>: 'two', 2: 'also two'}"^^cdt:Map )
        </pre>
        <p>
          results in one of the following two cdt:List literals (either ordering of keys is acceptable).
        </p>
        <pre class="nohighlight">
          "['02'^^&lt;http://www.w3.org/2001/XMLSchema#integer>, '2'^^&lt;http://www.w3.org/2001/XMLSchema#integer>]"^^cdt:List
          "['2'^^&lt;http://www.w3.org/2001/XMLSchema#integer>, '02'^^&lt;http://www.w3.org/2001/XMLSchema#integer>]"^^cdt:List
        </pre>
        <p>
          Note that, beyond the ordering variations, the lexical forms of the literals within the resulting lists may also vary as long as the resulting cdt:list literal is equal to any of the two aforementioned cdt:List literals. For instance, the following cdt:List literal is also a valid result.
        </p>
        <pre class="nohighlight">
          "['02'^^&lt;http://www.w3.org/2001/XMLSchema#integer>, 2]"^^cdt:List
        </pre>
      </aside>

      <p class="note">
        If the <a>term map</a> represented by <var>term</var> is the <a>empty term map</a>, then the resulting <a href="#dfn-cdt-list-literal">cdt:List literal</a> represents the <a>empty term list</a>.
      </p>

    </section>

    <section id="func_merge">
      <h2>cdt:merge</h2>

      <p>
        <code><a href="#dfn-cdt-map-literal">cdt:Map</a> </code>
        <code style="color:black;font-weight:bold">cdt:merge</code>
        (
           <code><a href="#dfn-cdt-map-literal">cdt:Map</a> <var>term<sub>1</sub></var></code>,
           <code><a href="#dfn-cdt-map-literal">cdt:Map</a> <var>term<sub>2</sub></var></code>
        )
      </p>

      <p>
        If <var>term<sub>1</sub></var> is a <a>well-formed cdt:Map literal</a> and <var>term<sub>2</sub></var> is a <a>well-formed cdt:Map literal</a>, then the result of this function is a <a href="#dfn-cdt-map-literal">cdt:Map literal</a> that represents a <a>term map</a> containing all <a>map entries</a> contained in the term map represented by <var>term<sub>1</sub></var>, together with every map entry (|k|,|v|) that is contained in the term map represented by <var>term<sub>2</sub></var> and that has a <a>map key</a>&nbsp;|k| that is not in the domain of the term map of <var>term<sub>1</sub></var>.
      </p>

      <p>
        If <var>term<sub>1</sub></var> is an <a>ill-formed cdt:Map literal</a> or <var>term<sub>2</sub></var> is an <a>ill-formed cdt:Map literal</a>, then this function produces an error.
      </p>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:merge( "{1: 'one', 2: 'two'}"^^cdt:Map, "{1: 'another one', 3: 'three'}"^^cdt:Map )
        </pre>
        <p>
          results in the following cdt:Map literal (or any other cdt:Map literal that is <a href="#func_map-equal">equal</a> to the given one).
        </p>
        <pre class="nohighlight">
          "{1: 'one', 2: 'two', 3: 'three'}"^^cdt:Map
        </pre>
      </aside>

      <p class="note">
        By the definition of the <code>cdt:merge</code> function, and as illustrated in the example above, if the term maps of the two given cdt:Map literals contain map entries with the same key, then the respective map entry from the first of the two literals is used for the resulting merged term map. The rationale for defining <code>cdt:merge</code> in this way is to be consistent with the default way in which the XPath <a data-cite="XPATH-FUNCTIONS#func-map-merge">map:merge</a> function handles duplicate keys.
      </p>

      <p class="note">
        If the term map represented by any of the two given cdt:Map literals is the <a>empty term map</a>, then the cdt:Map literal returned by this function represents exactly the same term map as the other of the two given cdt:Map literals (which may, of course, be the empty term map as well).
      </p>

    </section>

    <section id="func_put">
      <h2>cdt:put</h2>

      <p>
        <code><a href="#dfn-cdt-map-literal">cdt:Map</a> </code>
        <code style="color:black;font-weight:bold">cdt:put</code>
        (
           <code><a data-cite="SPARQL11-QUERY#expressions">SPARQL expression</a> <var>expr<sub>1</sub></var></code>,
           <code><a data-cite="SPARQL11-QUERY#expressions">SPARQL expression</a> <var>expr<sub>2</sub></var></code>
        )
      </p>

      <p>
        <code><a href="#dfn-cdt-map-literal">cdt:Map</a> </code>
        <code style="color:black;font-weight:bold">cdt:put</code>
        (
           <code><a data-cite="SPARQL11-QUERY#expressions">SPARQL expression</a> <var>expr<sub>1</sub></var></code>,
           <code><a data-cite="SPARQL11-QUERY#expressions">SPARQL expression</a> <var>expr<sub>2</sub></var></code>,
           <code><a data-cite="SPARQL11-QUERY#expressions">SPARQL expression</a> <var>expr<sub>3</sub></var></code>
        )
      </p>

      <p>
        If evaluating the expression <var>expr<sub>1</sub></var> results in a <a>well-formed cdt:Map literal</a>, hereafter denoted by |lit|, and evaluating the expression <var>expr<sub>2</sub></var> results in a <a>map key</a>, hereafter denoted by |key|, then the result of this function is a <a href="#dfn-cdt-map-literal">cdt:Map literal</a> that represents a <a>term map</a>&nbsp;|tm| produced by the following algorithm.
      </p>
      <div class="algorithm">
        <ol>
          <li>Initialize |tm| as the <a>empty term map</a>.</li>
          <li>Let <var>tm'</var> be the <a>term map</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a>cdt:Map datatype</a> to the <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> of |lit| (i.e., <var>tm'</var> is the <a data-cite="RDF11-CONCEPTS#dfn-literal-value">value</a> of |lit|).</li>
          <li>For every <a>map entry</a> (|k|,|v|) that is <a href="#dfn-contains-map-entry">contained</a> in <var>tm'</var>:
            <ol>
              <li>If |k| is not the same term as |key|, add the map entry (|k|,|v|) to |tm|.</li>
            </ol>
          </li>
          <li>If the expression <var>expr<sub>3</sub></var> is given and evaluating this expression does not result in an error, then add the map entry (|key|,&nbsp;|term|) to |tm|, where |term| is the RDF terms resulting from the evaluation of <var>expr<sub>3</sub></var>.</li>
          <li>If the expression <var>expr<sub>3</sub></var> is not given or evaluating this expression results in an error, then add the map entry (|key|,&nbsp;<a>null</a>) to |tm|.</li>
        </ol>
      </div>

      <p>
        In all other cases an error is raised.
      </p>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:put( "{1: 'one'}"^^cdt:Map, 2 )
        </pre>
        <p>
          results in the following cdt:Map literal (or any other cdt:Map literal that is <a href="#func_map-equal">equal</a> to the given one).
        </p>
        <pre class="nohighlight">
          "{1: 'one', 2: null}"^^cdt:Map
        </pre>
      </aside>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:put( "{1: 'one', 2: null}"^^cdt:Map, 2, "two" )
        </pre>
        <p>
          results in the following cdt:Map literal (or any other cdt:Map literal that is <a href="#func_map-equal">equal</a> to the given one).
        </p>
        <pre class="nohighlight">
          "{1: 'one', 2: 'two'}"^^cdt:Map
        </pre>
      </aside>

      <p class="note">
        If the <a>term map</a> <var>tm'</var> represented by |lit| contains a map entry&nbsp;(|k|,|v|) such that |k| is the same term as |key| and |v| is the same term as the result of evaluating <var>expr<sub>3</sub></var> (resp. |v| is <a>null</a> and either <var>expr<sub>3</sub></var> is not given or evaluating <var>expr<sub>3</sub></var> results in an error), then the <a href="#dfn-cdt-map-literal">cdt:Map literal</a> returned by this function represents exactly the same term map as |lit|; i.e., <var>tm'</var>.
      </p>

    </section>

    <section id="func_remove">
      <h2>cdt:remove</h2>

      <p>
        <code><a href="#dfn-cdt-map-literal">cdt:Map</a> </code>
        <code style="color:black;font-weight:bold">cdt:remove</code>
        (
           <code><a href="#dfn-cdt-map-literal">cdt:Map</a> <var>term<sub>1</sub></var></code>,
           <code><a data-cite="RDF11-CONCEPTS#dfn-rdf-term">RDF term</a> <var>term<sub>2</sub></var></code>
        )
      </p>

      <p>
        If <var>term<sub>1</sub></var> is a <a>well-formed cdt:Map literal</a> and <var>term<sub>2</sub></var> is a <a>map key</a>, then the result of this function is a <a href="#dfn-cdt-map-literal">cdt:Map literal</a> that represents a <a>term map</a> containing all <a>map entries</a> contained in the term map represented by <var>term<sub>1</sub></var>, except for any map entry whose map key is the same term as <var>term<sub>2</sub></var>.
      </p>

      <p>
        If <var>term<sub>1</sub></var> is a <a>well-formed cdt:Map literal</a> and <var>term<sub>2</sub></var> is not a <a>map key</a>, then the result of this function is <var>term<sub>1</sub></var>.
      </p>

      <p>
        If <var>term<sub>1</sub></var> is an <a>ill-formed cdt:Map literal</a>, then this function produces an error.
      </p>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:remove( "{1: 'one', 2: null}"^^cdt:Map, 2 )
        </pre>
        <p>
          results in the following cdt:Map literal (or any other cdt:Map literal that is <a href="#func_map-equal">equal</a> to the given one).
        </p>
        <pre class="nohighlight">
          "{1: 'one'}"^^cdt:Map
        </pre>
      </aside>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:remove( "{1: 'one'}"^^cdt:Map, 1 )
        </pre>
        <p>
          results in a cdt:Map literal that represents the <a>empty term map</a>.
        </p>
      </aside>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:remove( "{'01'^^&lt;http://www.w3.org/2001/XMLSchema#integer>: 'one'}"^^cdt:Map, '1'^^&lt;http://www.w3.org/2001/XMLSchema#integer> )
        </pre>
        <p>
          results in the cdt:Map literal given as the first argument (or any other cdt:Map literal that is <a href="#func_map-equal">equal</a> to the given one). The fact that the term map represented by the given cdt:Map literal is not changed in this case is because the map key of the map entry in this term map is not the same term as the second argument given to the function (while both are literals that even represent the same <a data-cite="RDF11-CONCEPTS#dfn-literal-value">value</a>, they having different <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical forms</a>).
        </p>
      </aside>

      <aside class="example">
        <p>
          Evaluating the SPARQL expression
        </p>
        <pre class="nohighlight">
          cdt:remove( "{'01'^^&lt;http://www.w3.org/2001/XMLSchema#integer>: 'one'}"^^cdt:Map, BNODE() )
        </pre>
        <p>
          results in the cdt:Map literal given as the first argument, because the second argument is a blank node, which is not a <a>map key</a>.
        </p>
      </aside>

    </section>

  </section>


  <section id="extension-of-order-by">
    <h2>Extension of ORDER BY</h2>

    <p>
      This section extends the definition of the <a data-cite="SPARQL11-QUERY#modOrderBy">`ORDER BY` clause of SPARQL</a> to explicitly define the relative order of two RDF terms that both are <a>cdt:List literals</a> or <a>cdt:Map literals</a>.
    </p>

    <p>
      According to the definition of `ORDER BY` ordering in <a data-cite="SPARQL11-QUERY#modOrderBy">Section&nbsp;15.1</a> of [[SPARQL11-QUERY]], <a>cdt:List literals</a> and <a>cdt:Map literals</a> are ordered higher than any blank node and any IRI (because they are RDF literals).
    </p>

    <section id="relative-order-of-list-literals">
      <h2>Relative Order of cdt:List Literals</h2>

      <p>
        Given two <a>cdt:List literals</a> <var>lit<sub>1</sub></var> and <var>lit<sub>2</sub></var>, if they both are <a href="#dfn-well-formed-cdt-list-literal">well-formed</a>, the relative order of these two literals is determined by the algorithm listed below. In brief, the algorithm operates as follows: It iterates over the <a>term lists</a> of both literals and compares their elements pairwise. For every pair for which both elements are <a>null</a>, the algorithm advances to the next pair. Once the algorithm comes across a pair with only one null value, the corresponding cdt:List literal that contains this null value is ordered lower than the other cdt:List literal. If none of the two elements in the current pair is null, and one of the two elements is ordered higher than the other element, then the cdt:List literal from which this higher-ordered element originates is defined as ordered higher than the other cdt:List literal. It may also be possible that the relative order of the two elements in such a pair is undefined. In such a case the relative order of the two cdt:List literals is undefined as well, unless the two elements are equal, in which case the algorithm also advances to the next pair. If the algorithm reaches the end of at least one of the two term lists and the other term list contains further elements, then the cdt:List literal with the larger term list is ordered higher. If no decision can be made based on any of the aforementioned conditions, then the relative order of the two literals is determined based on their lexical forms.
      </p>
      <div class="algorithm">
        <ol>
          <li>Let <var>list<sub>1</sub></var> be the <a>term list</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a>cdt:List datatype</a> to the <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> of <var>lit<sub>1</sub></var> (i.e., <var>list<sub>1</sub></var> is the <a data-cite="RDF11-CONCEPTS#dfn-literal-value">value</a> of <var>lit<sub>1</sub></var>).</li>
          <li>Let <var>list<sub>2</sub></var> be the <a>term list</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a>cdt:List datatype</a> to the <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> of <var>lit<sub>2</sub></var> (i.e., <var>list<sub>2</sub></var> is the <a data-cite="RDF11-CONCEPTS#dfn-literal-value">value</a> of <var>lit<sub>2</sub></var>).</li>

          <li>For every integer |i| from 1 to |n|, where |n| is the minimum of the length of <var>list<sub>1</sub></var> and the length of <var>list<sub>2</sub></var>:
            <ol>
              <li>Let <var>elmt<sub>1</sub></var> be the |i|-th element in <var>list<sub>1</sub></var>.</li>
              <li>Let <var>elmt<sub>2</sub></var> be the |i|-th element in <var>list<sub>2</sub></var>.</li>
              <li>If <var>elmt<sub>1</sub></var> is <a>null</a> and <var>elmt<sub>2</sub></var> is not null, then <var>lit<sub>2</sub></var> is ordered higher than <var>lit<sub>1</sub></var>.</li>
              <li>If <var>elmt<sub>2</sub></var> is <a>null</a> and <var>elmt<sub>1</sub></var> is not null, then <var>lit<sub>1</sub></var> is ordered higher than <var>lit<sub>2</sub></var>.</li>
              <li>If neither <var>elmt<sub>1</sub></var> nor <var>elmt<sub>2</sub></var> is null (i.e., both are RDF terms), then:
                <ol>
                  <li>If the relative order of <var>elmt<sub>1</sub></var> and <var>elmt<sub>2</sub></var> is defined such that <var>elmt<sub>1</sub></var> is ordered higher than <var>elmt<sub>2</sub></var>&nbsp;(according to the definition in <a data-cite="SPARQL11-QUERY#modOrderBy">Section&nbsp;15.1</a> of [[SPARQL11-QUERY]], and also considering the extension of this definition as provided in this section), then <var>lit<sub>1</sub></var> is ordered higher than <var>lit<sub>2</sub></var>.</li>
                  <li>If the relative order of <var>elmt<sub>1</sub></var> and <var>elmt<sub>2</sub></var> is defined such that <var>elmt<sub>2</sub></var> is ordered higher than <var>elmt<sub>1</sub></var>, then <var>lit<sub>2</sub></var> is ordered higher than <var>lit<sub>1</sub></var>.</li>
                  <li>If evaluating the SPARQL expression <var>elmt<sub>1</sub></var> = <var>elmt<sub>2</sub></var> results in `false` or in an error, then the relative order of <var>lit<sub>1</sub></var> and <var>lit<sub>2</sub></var> is undefined.</li>
                </ol>
              </li>
            </ol>
          </li>

          <li>If the length of <var>list<sub>1</sub></var> is greater than the length of <var>list<sub>2</sub></var>, then <var>lit<sub>1</sub></var> is ordered higher than <var>lit<sub>2</sub></var>.</li>
          <li>If the length of <var>list<sub>2</sub></var> is greater than the length of <var>list<sub>1</sub></var>, then <var>lit<sub>2</sub></var> is ordered higher than <var>lit<sub>1</sub></var>.</li>

          <li>Let <var>str<sub>1</sub></var> be the literal that has the same lexical form as <var>lit<sub>1</sub></var> and the datatype IRI `xsd:string`.</li>
          <li>Let <var>str<sub>2</sub></var> be the literal that has the same lexical form as <var>lit<sub>2</sub></var> and the datatype IRI `xsd:string`.</li>
          <li>If <var>str<sub>1</sub></var> is ordered higher than <var>str<sub>2</sub></var>, then <var>lit<sub>1</sub></var> is ordered higher than <var>lit<sub>2</sub></var>.</li>
          <li>If <var>str<sub>2</sub></var> is ordered higher than <var>str<sub>1</sub></var>, then <var>lit<sub>2</sub></var> is ordered higher than <var>lit<sub>1</sub></var>.</li>

          <li>The relative order of <var>lit<sub>1</sub></var> and <var>lit<sub>2</sub></var> is undefined.</li>
        </ol>
      </div>

      <p>
        If at least one of the two literals, <var>lit<sub>1</sub></var> or <var>lit<sub>2</sub></var>, is <a href="#dfn-ill-formed-cdt-list-literal">ill-formed</a>, then their relative order is undefined.
      </p>

    </section>

    <section id="relative-order-of-map-literals">
      <h2>Relative Order of cdt:Map Literals</h2>

      <p>
        Given two <a>cdt:Map literals</a> <var>lit<sub>1</sub></var> and <var>lit<sub>2</sub></var>, if they both are <a href="#dfn-well-formed-cdt-map-literal">well-formed</a>, the relative order of these two literals is determined by the following algorithm.
      </p>
      <div class="algorithm">
        <ol>
          <li>Let <var>map<sub>1</sub></var> be the <a>term map</a> obtained by applying the <a href="#list-datatype-lex-to-value-mapping">lexical-to-value mapping</a> of the <a>cdt:Map datatype</a> to the <a data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</a> of <var>lit<sub>1</sub></var> (i.e., <var>map<sub>1</sub></var> is the <a data-cite="RDF11-CONCEPTS#dfn-literal-value">value</a> of <var>lit<sub>1</sub></var>).</li>
          <li>Let <var>map<sub>2</sub></var> be the term map obtained by applying the lexical-to-value mapping of the cdt:Map datatype to the lexical form of <var>lit<sub>2</sub></var> (i.e., <var>map<sub>2</sub></var> is the value of <var>lit<sub>2</sub></var>).</li>
          <li>Let <var>entrylist<sub>1</sub></var> be a list of all <a>map entries</a> that are <a href="#dfn-contains-map-entry">contained</a> in <var>map<sub>1</sub></var>, ordered based on their respective <a>map keys</a> by using the same order as defined in Step&nbsp;6 of the algorithm in Section&nbsp;<a href="#func_map-less-than" class="sectionRef"></a>.</li>
          <li>Let <var>entrylist<sub>2</sub></var> be a list of all map entries that are contained in <var>map<sub>2</sub></var>, ordered in the same way as <var>entrylist<sub>1</sub></var>.</li>
          <li>For every integer |i| from 1 to |n|, where |n| is the minimum of the respective length of <var>entrylist<sub>1</sub></var> and of <var>entrylist<sub>2</sub></var>:
            <ol>
              <li>Let (<var>k<sub>1</sub></var>, <var>v<sub>1</sub></var>) be the |i|-th map entry in <var>entrylist<sub>1</sub></var>.</li>
              <li>Let (<var>k<sub>2</sub></var>, <var>v<sub>2</sub></var>) be the |i|-th map entry in <var>entrylist<sub>2</sub></var>.</li>
              <li>If evaluating the SPARQL expression <a data-cite="SPARQL11-QUERY#func-sameTerm">`SAMETERM`</a>(<var>k<sub>1</sub></var>, <var>k<sub>2</sub></var>) results in `false`, then:
                <ol>
                  <li>If <var>k<sub>1</sub></var> is ordered before <var>k<sub>2</sub></var> according to the ordering of map keys as used above for creating <var>entrylist<sub>1</sub></var> (and as defined in Step&nbsp;6 of the algorithm in Section&nbsp;<a href="#func_map-less-than" class="sectionRef"></a>), then <var>lit<sub>1</sub></var> is ordered before <var>lit<sub>2</sub></var>.</li>
                  <li><var>lit<sub>2</sub></var> is ordered before <var>lit<sub>1</sub></var>.</li>
                </ol>
              </li>
              <li>If <var>v<sub>1</sub></var> is <a>null</a> and <var>v<sub>2</sub></var> is not null, then <var>lit<sub>2</sub></var> is ordered higher than <var>lit<sub>1</sub></var>.</li>
              <li>If <var>v<sub>2</sub></var> is null and <var>v<sub>1</sub></var> is not null, then <var>lit<sub>1</sub></var> is ordered higher than <var>lit<sub>2</sub></var>.</li>
              <li>If neither <var>v<sub>1</sub></var> nor <var>v<sub>2</sub></var> is null (i.e., both are RDF terms), then:
                <ol>
                  <li>If the order of <var>v<sub>1</sub></var> and <var>v<sub>2</sub></var> is defined such that <var>v<sub>1</sub></var> is ordered higher than <var>v<sub>2</sub></var>, then <var>lit<sub>1</sub></var> is ordered higher than <var>lit<sub>2</sub></var>.</li>
                  <li>If the order of <var>v<sub>1</sub></var> and <var>v<sub>2</sub></var> is defined such that <var>v<sub>2</sub></var> is ordered higher than <var>v<sub>1</sub></var>, then <var>lit<sub>2</sub></var> is ordered higher than <var>lit<sub>1</sub></var>.</li>
                  <li>If evaluating the SPARQL expression <var>v<sub>1</sub></var> = <var>v<sub>2</sub></var> results in `false` or in an error, then the relative order of <var>lit<sub>1</sub></var> and <var>lit<sub>2</sub></var> is undefined.</li>
                </ol>
              </li>
            </ol>
          </li>

          <li>If the length of <var>entrylist<sub>1</sub></var> is greater than the length of <var>entrylist<sub>2</sub></var>, then <var>lit<sub>1</sub></var> is ordered higher than <var>lit<sub>2</sub></var>.</li>
          <li>If the length of <var>entrylist<sub>2</sub></var> is greater than the length of <var>entrylist<sub>1</sub></var>, then <var>lit<sub>2</sub></var> is ordered higher than <var>lit<sub>1</sub></var>.</li>

          <li>Let <var>str<sub>1</sub></var> be the literal that has the same lexical form as <var>lit<sub>1</sub></var> and the datatype IRI `xsd:string`.</li>
          <li>Let <var>str<sub>2</sub></var> be the literal that has the same lexical form as <var>lit<sub>2</sub></var> and the datatype IRI `xsd:string`.</li>
          <li>If <var>str<sub>1</sub></var> is ordered higher than <var>str<sub>2</sub></var>, then <var>lit<sub>1</sub></var> is ordered higher than <var>lit<sub>2</sub></var>.</li>
          <li>If <var>str<sub>2</sub></var> is ordered higher than <var>str<sub>1</sub></var>, then <var>lit<sub>2</sub></var> is ordered higher than <var>lit<sub>1</sub></var>.</li>

          <li>The relative order of <var>lit<sub>1</sub></var> and <var>lit<sub>2</sub></var> is undefined.</li>
        </ol>
      </div>

      <p>
        If at least one of the two literals, <var>lit<sub>1</sub></var> or <var>lit<sub>2</sub></var>, is <a href="#dfn-ill-formed-cdt-map-literal">ill-formed</a>, then their relative order is undefined.
      </p>

    </section>

  </section>


  <section id="fold">
    <h2>FOLD</h2>

    <p>
      This section defines a new SPARQL <a data-cite="SPARQL11-QUERY#setFunctions">Set Function</a>, `FOLD`, used to construct composite values.
      As illustrated in Section&nbsp;<a href="#description-of-fold" class="sectionRef"></a>, this function can be used to collect individual values into <a>cdt:List literals</a> and <a>cdt:Map literals</a>.
    </p>

    <section id="fold-grammar">
      <h2>Grammar</h2>

      <p>
        Adding the FOLD aggregate to SPARQL requires the following extension of the <a data-cite="SPARQL11-QUERY#rAggregate">`Aggregate`</a> production of the <a data-cite="SPARQL11-QUERY#sparqlGrammar">SPARQL grammar</a>. The part in which the extended production differs from the corresponding production in the original grammar is marked in bold font. The given production rule uses several symbols for which no production rule is provided below (e.g., <a data-cite="SPARQL11-QUERY#rExpression">Expression</a>, <a data-cite="SPARQL11-QUERY#rOrderCondition">OrderCondition</a>); the production rules for these symbols are defined as given in the original SPARQL grammar.
      </p>

      <table class="grammar">

        <tr id="rAggregate">
          <td>[127+]</td>
          <td>`Aggregate`</td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <code>&nbsp;
            <span class="token">'COUNT'</span>
            <span class="token">'('</span>
            <span class="token">'DISTINCT'</span>?
            ( <span class="token">'*'</span> | <a data-cite="SPARQL11-QUERY#rExpression">Expression</a> )
            <span class="token">')'</span>
            <br/>
            `|`
            <span class="token">'SUM'</span>
            <span class="token">'('</span>
            <span class="token">'DISTINCT'</span>?
            <a data-cite="SPARQL11-QUERY#rExpression">Expression</a>
            <span class="token">')'</span>
            <br/>
            `|`
            <span class="token">'MIN'</span>
            <span class="token">'('</span>
            <span class="token">'DISTINCT'</span>?
            <a data-cite="SPARQL11-QUERY#rExpression">Expression</a>
            <span class="token">')'</span>
            <br/>
            `|`
            <span class="token">'MAX'</span>
            <span class="token">'('</span>
            <span class="token">'DISTINCT'</span>?
            <a data-cite="SPARQL11-QUERY#rExpression">Expression</a>
            <span class="token">')'</span>
            <br/>
            `|`
            <span class="token">'AVG'</span>
            <span class="token">'('</span>
            <span class="token">'DISTINCT'</span>?
            <a data-cite="SPARQL11-QUERY#rExpression">Expression</a>
            <span class="token">')'</span>
            <br/>
            `|`
            <span class="token">'SAMPLE'</span>
            <span class="token">'('</span>
            <span class="token">'DISTINCT'</span>?
            <a data-cite="SPARQL11-QUERY#rExpression">Expression</a>
            <span class="token">')'</span>
            <br/>
            `|`
            <span class="token">'GROUP_CONCAT'</span>
            <span class="token">'('</span>
            <span class="token">'DISTINCT'</span>?
            <a data-cite="SPARQL11-QUERY#rExpression">Expression</a>
            ( <span class="token">';'</span> <span class="token">'SEPARATOR'</span> <span class="token">'='</span> <a data-cite="SPARQL11-QUERY#rString">String</a> )?
            <span class="token">')'</span>
            <br/>
            <strong>
            `|`
            <span class="token">'FOLD'</span>
            <span class="token">'('</span>
            <span class="token">'DISTINCT'</span>?
            <a data-cite="SPARQL11-QUERY#rExpression">Expression</a>
            ( <span class="token">','</span> <a data-cite="SPARQL11-QUERY#rExpression">Expression</a> )?
            ( <span class="token">'ORDER'</span> <span class="token">'BY'</span> <a data-cite="SPARQL11-QUERY#rOrderCondition">OrderCondition</a>+ )?
            <span class="token">')'</span>
            </strong>
            </code>
          </td>
        </tr>

      </table>

    </section>

    <section id="fold-translation">
      <h2>Translation to the Algebra</h2>

      <p>
        Based on the SPARQL grammar, the SPARQL specification <q>defines the process of converting graph patterns and solution modifiers in a SPARQL query string into a SPARQL algebra expression</q> (see <a data-cite="SPARQL11-QUERY#sparqlQuery">Section&nbsp;18.2</a> of [[SPARQL11-QUERY]]).
        This process must be adapted to consider FOLD clauses as added by the extended grammar introduced above.
        In particular, the step of translating grouping and aggregation during this process needs to be extended.
        The original algorithm that defines this translation is given in <a data-cite="SPARQL11-QUERY#sparqlGroupAggregate">Section&nbsp;18.2.4.1</a> of [[SPARQL11-QUERY]].
        The extended version of the algorithm is given as follows, where the parts that are modified or added to cover the FOLD operator are marked in bold font.
      </p>
      <div style="width: 100%; border: 1px solid; padding: 5px">
        <pre class="nohighlight" style="margin: 0px">
Let A := the empty sequence
Let Q := the query level being evaluated
Let P := the algebra translation of the GroupGraphPattern of the query level
Let E := [], a list of pairs of the form (variable, expression)

If Q contains GROUP BY exprlist
   Let G := Group(exprlist, P)
Else If Q contains an aggregate in SELECT, HAVING, ORDER BY
   Let G := Group((1), P)
Else
   skip the rest of the aggregate step
   End

Global i := 1   # Initially 1 for each query processed

For each (X AS Var) in SELECT, each HAVING(X), and each ORDER BY X in Q
  For each unaggregated variable V in X
      Replace V with Sample(V)
      End
  For each aggregate R(args <strong>ORDER BY orderconditions</strong>; scalarvals) now in X
      <strong># note ORDER BY clause may be omitted</strong>
      # note scalarvals may be omitted, then it's equivalent to the empty set
      <strong>If aggregate contains ORDER BY orderconditions
          G := OrderGroups(G, orderconditions)
          End
      If R = Fold
          If |args| = 1
              setfunc = Fold1
          Else
              setfunc = Fold2
              End
      Else
          setfunc = R
          End</strong>
      A<sub>i</sub> := Aggregation(args, <strong>setfunc</strong>, scalarvals, G)
      Replace R(...) with agg<sub>i</sub> in Q
      i := i + 1
      End
  End

For each variable V appearing outside of an aggregate
   A<sub>i</sub> := Aggregation(V, Sample, {}, G)
   E := E append (V, agg<sub>i</sub>)
   i := i + 1
   End

A := A<sub>i</sub>, ..., A<sub>i-1</sub>
P := AggregateJoin(A)
        </pre>
      </div>

      <p>
        Notice that the extended algorithm uses the new algebra symbol `OrderGroups`. Hence, to use this algorithm, the list of symbols in the SPARQL algebra (as given in the second table of <a data-cite="SPARQL11-QUERY#sparqlQuery">Section&nbsp;18.2</a> [[SPARQL11-QUERY]]) needs to be extended by adding this symbol. The evaluation semantics of algebra expressions that contain this symbol is defined in the following.
      </p>

    </section>

    <section id="ordergroups-algebra">
      <h2>Algebra</h2>

      <p>
        This section defines an operator for evaluating the new algebra symbol (as <a data-cite="SPARQL11-QUERY#sparqlAlgebra">Section&nbsp;18.5</a> of [[SPARQL11-QUERY]] does for the standard SPARQL algebra symbols). This operator has the same name as the algebra symbol and shall be used in the following section to extend the evaluation semantics of algebra expressions that may contain the new algebra symbol.
      </p>

      <div class="defn">
        <p><b>Definition: <dfn id="defn_algOrderGroups" style="font-style:normal">OrderGroups</dfn></b></p>
        <p>
          Let {&nbsp;<var>key<sub>1</sub></var>→<var>Ψ<sub>1</sub></var>, ..., <var>key<sub>m</sub></var>→<var>Ψ<sub>|m|</sub></var>&nbsp;} be a partial function from keys to solution sequences. OrderGroups({&nbsp;<var>key<sub>1</sub></var>→<var>Ψ<sub>1</sub></var>, ..., <var>key<sub>|m|</sub></var>→<var>Ψ<sub>|m|</sub></var>&nbsp;}, |condition|) is also a partial function from keys to solution sequences that is defined as follows:
        </p>
        <p>
          OrderGroups({&nbsp;<var>key<sub>1</sub></var>→<var>Ψ<sub>1</sub></var>, ..., <var>key<sub>|m|</sub></var>→<var>Ψ<sub>|m|</sub></var>&nbsp;}, |condition|) =
          {
          <var>key<sub>1</sub></var>→<a data-cite="SPARQL11-QUERY#defn_algOrderBy">OrderBy</a>(<var>Ψ<sub>1</sub></var>, |condition|),
          ...,
          <var>key<sub>|m|</sub></var>→<a data-cite="SPARQL11-QUERY#defn_algOrderBy">OrderBy</a>(<var>Ψ<sub>|m|</sub></var>, |condition|)
          }
        </p>
      </div>

      <section id="aggregateAlgebra">
        <h2>Aggregate Algebra</h2>
        <p>Two new set functions are introduced to support the FOLD aggregate:</p>

        <section id="aggFold1">
          <h2>Fold1</h2>
          <p>
            Fold1 is a SPARQL set function which combines the elements in the aggregate group into a <a>cdt:List literal</a>.
          </p>
          <div class="defn">
            <p><b>Definition: <span id="defn_aggFold1">Fold1</span></b></p>
            <pre class="code nohighlight"><a href="#dfn-cdt-list-literal">cdt:List</a> Fold1(sequence <var>S</var>)</pre>
            <p>|L| = Flatten(|S|)</p>
            <p>|n| = ||L||</p>
            <p>
              Fold1(|S|) is a <a>cdt:List literal</a> that represents a <a>term list</a>&nbsp;|tm| that contains |n| elements where, for every |i| in {1, ..., |n|}, the element at the |i|-th position of |tm| is determined as follows: If the element at the |i|-th position of |L| is an error, then the element at the |i|-th position of |tm| is <a>null</a>. Otherwise, the element at the |i|-th position of |tm| is the element at the |i|-th position of |L|.
            </p>
          </div>
          <p class="note">
            If |S| is the empty sequence, then |n|=0 and, thus, the result of Fold1(|S|) is a <a>cdt:List literal</a> that represents the <a>empty term list</a>.
          </p>
          <p class="note">
            By its definition, Fold1 behaves in the same way as the <a href="#func_list">cdt:List</a> function if that function is invoked by passing each element of |L| as a separate argument.
          </p>
        </section>

        <section id="aggFold2">
          <h2>Fold2</h2>
          <p>
            Fold2 is a SPARQL set function which combines the elements in the aggregate group into a <a>cdt:Map literal</a>.
          </p>
          <div class="defn">
            <p><b>Definition: <span id="defn_aggFold2">Fold2</span></b></p>
            <pre class="code nohighlight"><a href="#dfn-cdt-map-literal">cdt:Map</a> Fold2(sequence <var>S</var>)</pre>
            <p>|L| = Flatten(|S|)</p>
            <p>
              |n| = ||L||
              <br/>
              Note that |n| is an even number, which is due to
              i)&nbsp;the <a href="#fold-grammar">grammar of the FOLD aggregate</a>,
              ii)&nbsp;the corresponding <a href="#fold-translation">translation to the algebra</a>, and
              iii)&nbsp;the definition of the <a data-cite="SPARQL11-QUERY#defn_algAggregation ">Aggregation</a> operator.
            </p>
            <p>
              Fold2(|S|) is a <a>cdt:Map literal</a> that represents a <a>term map</a>&nbsp;|tm| that is constructed by the following algorithm.
            </p>
            <div class="algorithm">
              <ol>
                <li>Initialize |tm| as the <a>empty term map</a>.</li>
                <li>For every integer |i| from 1 to |n|/2:
                  <ol>
                    <li>Let |k| be the element at the (2<var>i</var>-1)-th position of |L|.</li>
                    <li>Let |v| be the element at the 2<var>i</var>-th position of |L|.</li>
                    <li>If |k| is neither an error nor a blank node, then:
                      <ol>
                        <li>If |tm| contains a <a>map entry</a> (<var>k'</var>,<var>v'</var>) such that |k|=<var>k'</var>, then replace this map entry (<var>k'</var>,<var>v'</var>) by the map entry (|k|,|v|). Otherwise, add the map entry (|k|,|v|) to |tm|.</li>
                      </ol>
                    </li>
                  </ol>
                </li>
              </ol>
            </div>
          </div>
          <p class="note">
            If |S| is the empty sequence, then |n|=0 and, thus, the result of Fold2(|S|) is a <a>cdt:Map literal</a> that represents the <a>empty term map</a>.
          </p>
          <p class="note">
            By its definition, Fold2 behaves in the same way as the <a href="#func_map">cdt:Map</a> function if that function is invoked by passing each element of |L| as a separate argument.
          </p>
        </section>

      </section>

    </section>

    <section id="ordergroups-semantics">
      <h2>Evaluation Semantics</h2>

      <p>
        The SPARQL specification defines a function <q>eval(D(G), algebra expression) as the evaluation of an algebra expression with respect to a dataset D having active graph G</q> (see <a data-cite="SPARQL11-QUERY#sparqlAlgebraEval">Section&nbsp;18.6</a> of [[SPARQL11-QUERY]]). The definition of this function is recursive. To cover algebra expressions that may contain the new algebra symbol (`OrderGroups`) the definition of this function needs to be extended with the following additional case.
      </p>

      <div class="defn">
        <p><b>Definition: <dfn id="defn_evalOrderGroups" style="font-style:normal">Evaluation of OrderGroups</dfn></b></p>
        <p>
          eval(D(G), `OrderGroups(`<var style="font-style: normal">`L`</var>, <var style="font-style: normal">`orderconditions`</var>`)`) = <a>OrderGroups</a>(eval(D(G), <var style="font-style: normal">`L`</var>), <var style="font-style: normal">`orderconditions`</var>)
        </p>
      </div>

    </section>

  </section>



  <section id="unfold">
    <h2>UNFOLD</h2>

    <p>
      This section defines an extension of the SPARQL language that adds a new operator called UNFOLD. As illustrated in Section&nbsp;<a href="#description-of-unfold" class="sectionRef"></a>, this operator can be used to transform composite values (given in the form of <a>cdt:List literals</a> or <a>cdt:Map literals</a>) into their individual components and assigns these components separately to new query variables.
    </p>

    <p>
      In particular, recall from Section&nbsp;<a href="#description-of-unfold" class="sectionRef"></a> that there are two variations of this operator: one that assigns a single new query variable (i.e., `UNFOLD(expr AS ?v1)`) and another one that assigns two new query variables (i.e., `UNFOLD(expr AS ?v1, ?v2)`).
      When applied to <a>cdt:List literals</a>, the one-variable version binds the new variable to each of the RDF terms in the corresponding <a>term list</a> (or leaves it unbound for <a>null</a> values) and the two-variables version binds the first new variable to each RDF term in the term list (or leaves it unbound for null values) and the second variable to the corresponding position of the term/null in the list.
      When applied to <a>cdt:Map literals</a>, the one-variable version binds the variable to each of the keys in the <a>term map</a> and the two-variables version binds the first variable to each key in the term map and the second variable to the corresponding value (or leaves it unbound for null values).
    </p>

    <p class="note">
      Note that there is an asymmetry between the two-variables version of UNFOLD for cdt:List literals and the two-variables version for cdt:Map literals. In the case of maps, the values are assigned to the second variable whereas, for lists, the values (the list elements) are assigned to the first variable.
      <br/><br/>
      While it would be possible to eliminate this asymmetry by changing the two-variables version of UNFOLD for cdt:List literals such that the list elements are assigned to the second variable (and the positions to the first variable), doing so would introduce another asymmetry: This asymmetry would then be between the so-changed two-variables version and the one-variable version of UNFOLD for cdt:List literals, because the latter binds the first (and, in this case, only) variable to the values. A follow-up change to eliminate this asymmetry as well may be to define the one-variable version such that it assigns the (single) variable to the positions and not to the list elements. However, this definition would have a very limited practical value and, thus, the initially mentioned asymmetry is considered as the best possible compromise.
    </p>

    <p>
      Adding this new UNFOLD operator to the language requires an extension to the grammar of SPARQL, an extension of the SPARQL algebra, and corresponding extensions both of the process of converting SPARQL graph patterns into SPARQL algebra expressions and of the evaluation semantics. The following sections define these extensions.
    </p>

    <section id="unfold-grammar">
      <h2>Grammar</h2>

      <p>
        Adding the UNFOLD operator to SPARQL requires the following extension of the <a data-cite="SPARQL11-QUERY#rGraphPatternNotTriples">`GraphPatternNotTriples`</a> production of the <a data-cite="SPARQL11-QUERY#sparqlGrammar">SPARQL grammar</a>. The part in which the extended production differs from the corresponding production in the original grammar is marked in bold font. The second production defined below (i.e., <a href="#rUnfold">`Unfold`</a>) needs to be added and has no counterpart in the original grammar. The given production rules use several symbols for which no production rule is provided below (e.g., <a data-cite="SPARQL11-QUERY#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a>, <a data-cite="SPARQL11-QUERY#rExpression">Expression</a>); the production rules for these symbols are defined as given in the original SPARQL grammar.
      </p>

      <table class="grammar">

        <tr id="rGraphPatternNotTriples">
          <td>[56+]</td>
          <td>`GraphPatternNotTriples`</td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <a data-cite="SPARQL11-QUERY#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a>
            `|`
            <a data-cite="SPARQL11-QUERY#rOptionalGraphPattern">OptionalGraphPattern</a>
            `|`
            <a data-cite="SPARQL11-QUERY#rMinusGraphPattern">MinusGraphPattern</a>
            `|`
            <a data-cite="SPARQL11-QUERY#rGraphGraphPattern">GraphGraphPattern</a>
            `|`
            <a data-cite="SPARQL11-QUERY#rServiceGraphPattern">ServiceGraphPattern</a>
            `|`
            <a data-cite="SPARQL11-QUERY#rFilter">Filter</a>
            `|`
            <a data-cite="SPARQL11-QUERY#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a>
            `|`
            <a data-cite="SPARQL11-QUERY#rBind">Bind</a>
            `|`
            <a data-cite="SPARQL11-QUERY#rInlineData">InlineData</a>
            <strong>
            `|`
            <a href="#rUnfold">Unfold</a>
            </strong>
          </td>
        </tr>

        <tr id="rUnfold">
          <td>[174]</td>
          <td>`Unfold`</td>
          <td>&nbsp;::=&nbsp;</td>
          <td>
            <code class="token">'UNFOLD'</code>
            <code class="token">'('</code>
            <a data-cite="SPARQL11-QUERY#rExpression">Expression</a>
            <code class="token">'AS'</code>
            <a data-cite="SPARQL11-QUERY#rVar">Var</a>
            `(`
            <code class="token">','</code>
            <a data-cite="SPARQL11-QUERY#rVar">Var</a>
            `)?`
            <code class="token">')'</code>
          </td>
        </tr>

      </table>

      <p>
        Two additional constraints MUST be satisfied when using the UNFOLD operator:
      </p>
      <ol>
        <li>
          For every expression of the form `UNFOLD(expr AS v, v')`, `v` and `v'` MUST be two different variables.
        </li>
        <li>
          Second, the variable(s) assigned in an UNFOLD operator must not be already in use; more formally:
        </li>
        <ul>
          <li>For every expression of the form `UNFOLD(expr AS v)`, the variable `v` MUST NOT be <a data-cite="SPARQL11-QUERY#variableScope">in-scope</a> from the preceding elements in the group graph pattern in which the expression is used.</li>
          <li>For every expression of the form `UNFOLD(expr AS v, v')`, the variable `v` MUST NOT be <a data-cite="SPARQL11-QUERY#variableScope">in-scope</a> from the preceding elements in the group graph pattern in which the expression is used, and the same holds for the variable `v'`.</li>
        </ul>
      </ol>

      <p>
        The notion of in-scope variables as used in the second constraint is defined in <a data-cite="SPARQL11-QUERY#variableScope">Section&nbsp;18.2.1</a> of [[SPARQL11-QUERY]]. When using the extended syntax with the UNFOLD operator, this notion must be extended as well. To capture this extension formally, the table in <a data-cite="SPARQL11-QUERY#variableScope">Section&nbsp;18.2.1</a> of [[SPARQL11-QUERY]] is augmented with the following two additional rows.
      </p>
      <table class="inscope">
        <tr>
          <th>Syntax Form</th>
          <th>In-scope variables</th>
        </tr>
        <tr>
          <td>`UNFOLD(expr AS v)` </td>
          <td style="padding-left: 30px;"> `v` is in-scope</td>
        </tr>
        <tr style="padding-left: 30px;">
          <td>`UNFOLD(expr AS v, v')` </td>
          <td> `v` and `v'` are in-scope</td>
        </tr>
      </table>

    </section>

    <section id="unfold-translation">
      <h2>Translation to the Algebra</h2>

      <p>
        Based on the SPARQL grammar, the SPARQL specification <q>defines the process of converting graph patterns and solution modifiers in a SPARQL query string into a SPARQL algebra expression</q> (see <a data-cite="SPARQL11-QUERY#sparqlQuery">Section&nbsp;18.2</a> of [[SPARQL11-QUERY]]). This process must be adapted to consider UNFOLD clauses as added by the extended grammar introduced above. In particular, the step of translating group graph patterns (<a data-cite="SPARQL11-QUERY#rGroupGraphPattern">GroupGraphPattern</a>) during this process needs to be extended. The original algorithm that defines this translation is given in <a data-cite="SPARQL11-QUERY#sparqlTranslateGraphPatterns">Section&nbsp;18.2.2.6</a> of [[SPARQL11-QUERY]]. The extended version of the algorithm is given as follows, where the parts that are added to cover the UNFOLD operator are marked in bold font.
      </p>
      <div style="width: 100%; border: 1px solid; padding: 5px">
        <pre class="nohighlight" style="margin: 0px">
Let G := the empty pattern, a basic graph pattern which is the empty set.

For each element E in the GroupGraphPattern

    If E is of the form OPTIONAL{P}
        Let A := Translate(P)
        If A is of the form Filter(F, A2)
            G := LeftJoin(G, A2, F)
        Else
            G := LeftJoin(G, A, true)
            End
        End

    If E is of the form MINUS{P}
        G := Minus(G, Translate(P))
        End

    If E is of the form BIND(expr AS var)
        G := Extend(G, var, expr)
        End
        </pre>

        <pre class="nohighlight" style="margin: 0px;
                                        font-weight: bold;
                                        padding-left: 4ch;
                                        padding-top: 3ex;
                                        padding-bottom: 3ex;">
    If E is of the form UNFOLD(expr AS var)
        G := Unfold1(G, var, expr)
        End

    If E is of the form UNFOLD(expr AS var1, var2)
        G := Unfold2(G, var1, var2, expr)
        End
        </pre>
        <pre class="nohighlight" style="margin: 0px">
    If E is any other form
        Let A := Translate(E)
        G := Join(G, A)
        End

   End

The result is G.
        </pre>
      </div>

      <p>
        Notice that the extended algorithm uses two new algebra symbols: `Unfold1` and `Unfold2`. Hence, to use this algorithm, the list of symbols in the SPARQL algebra (as given in the second table of <a data-cite="SPARQL11-QUERY#sparqlQuery">Section&nbsp;18.2</a> [[SPARQL11-QUERY]]) needs to be extended by adding these two symbols. The evaluation semantics of algebra expressions that contain any of these two symbols is defined in the following.
      </p>

    </section>

    <section id="unfold-algebra">
      <h2>Algebra</h2>

      <p>
        This section defines operators for evaluating the two new algebra symbols (as <a data-cite="SPARQL11-QUERY#sparqlAlgebra">Section&nbsp;18.5</a> of [[SPARQL11-QUERY]] does for the standard SPARQL algebra symbols). These operators have the same name as the algebra symbols and shall be used in the following section to extend the evaluation semantics of algebra expressions that may contain the two new algebra symbols.
      </p>

      <p>
        The operator for evaluating `Unfold1` is defined as follows.
      </p>

      <div class="defn">
        <p><b>Definition: <dfn id="dfn-Unfold1" style="font-style:normal">Unfold1</dfn></b></p>
        <p>
          Let <var>&mu;</var> be a <a data-cite="SPARQL11-QUERY#defn_sparqlSolutionMapping">solution mapping</a>, |var| be a <a data-cite="SPARQL11-QUERY#defn_QueryVariable">variable</a>, and |expr| be an <a data-cite="SPARQL11-QUERY#expressions">expression</a>.
          <br/>
          Then, Unfold1(<var>&mu;</var>, |var|, |expr|) is a multiset of solution mappings that is defined as follows:
        </p>
        <ul>
          <li>
            If |var|&nbsp;&notin;&nbsp;dom(<var>&mu;</var>) and |expr|(<var>&mu;</var>) is a <a>well-formed cdt:List literal</a>, then
            <ul>
              <li>
                Unfold1(<var>&mu;</var>, |var|, |expr|) = { <var>&mu;</var> | |L| contains <a>null</a> } &cup; <var>&Omega;'</var>, where
                <br/>&nbsp; &nbsp; |L| is the <a>term list</a> represented by the cdt:List literal |expr|(<var>&mu;</var>) and
                <br/>&nbsp; &nbsp; <var>&Omega;'</var> = { <var>&mu;</var> &cup; (|var|, |term|) | |term| is an RDF term in |L| },
              </li>
              <li>
                card[Unfold1(<var>&mu;</var>, |var|, |expr|)](<var>&mu;'</var>) = 0 for every <var>&mu;'</var>&nbsp;&ne;&nbsp;<var>&mu;</var> and <var>&mu;'</var>&nbsp;&notin;&nbsp;<var>&Omega;'</var>,
              </li>
              <li>
                card[Unfold1(<var>&mu;</var>, |var|, |expr|)](<var>&mu;'</var>) is the number of <a>null</a> values in |L| if <var>&mu;'</var>&nbsp;=&nbsp;<var>&mu;</var>, and
              </li>
              <li>
                card[Unfold1(<var>&mu;</var>, |var|, |expr|)](<var>&mu;'</var>) is the number of times the RDF term <var>&mu;'</var>(|var|) is contained in |L| if <var>&mu;'</var>&nbsp;&isin;&nbsp;<var>&Omega;'</var>.
              </li>
            </ul>
          </li>
          <li>
            If |var|&nbsp;&notin;&nbsp;dom(<var>&mu;</var>) and |expr|(<var>&mu;</var>) is a <a>well-formed cdt:Map literal</a>, then
            <ul>
              <li>
                Unfold1(<var>&mu;</var>, |var|, |expr|) = { <var>&mu;</var> &cup; (|var|, |key|) | |key| is the <a>key</a> of a <a>map entry</a> in |M| }, where
                <br/>&nbsp; &nbsp; |M| is the <a>term map</a> represented by the cdt:Map literal |expr|(<var>&mu;</var>),
              </li>
              <li>
                card[Unfold1(<var>&mu;</var>, |var|, |expr|)](<var>&mu;'</var>) = 1 for every <var>&mu;'</var>&nbsp;&isin;&nbsp;Unfold1(<var>&mu;</var>, |var|, |expr|), and
              </li>
              <li>
                card[Unfold1(<var>&mu;</var>, |var|, |expr|)](<var>&mu;'</var>) = 0 for every <var>&mu;'</var>&nbsp;&notin;&nbsp;Unfold1(<var>&mu;</var>, |var|, |expr|).
              </li>
            </ul>
          </li>
          <li>
            If |var| &notin; dom(<var>&mu;</var>) and |expr|(<var>&mu;</var>) is an error or an RDF term that is neither a well-formed cdt:List literal nor a well-formed cdt:Map literal, then
            <ul>
              <li>
                Unfold1(<var>&mu;</var>, |var|, |expr|) = {<var>&mu;</var>},
              </li>
              <li>
                card[Unfold1(<var>&mu;</var>, |var|, |expr|)](<var>&mu;'</var>) = 1 if <var>&mu;'</var>&nbsp;=&nbsp;<var>&mu;</var>, and
              </li>
              <li>
                card[Unfold1(<var>&mu;</var>, |var|, |expr|)](<var>&mu;'</var>) = 0 for every <var>&mu;'</var>&nbsp;&ne;&nbsp;<var>&mu;</var>.
              </li>
            </ul>
          </li>
          <li>
            If |var| &isin; dom(<var>&mu;</var>), then Unfold1(<var>&mu;</var>, |var|, |expr|) is undefined.
          </li>
        </ul>

        <p>
          Let <var>&Omega;</var> a multiset of solution mappings. We define:
          <br/>
          Unfold1(<var>&Omega;</var>, |var|, |expr|) = &#x22C3;<sub><var>&mu;</var> &isin; <var>&Omega;</var></sub> Unfold1(<var>&mu;</var>, |var|, |expr|)
        </p>
      </div>

      <p class="note">
        By the given definition , for cases in which |var|&nbsp;&notin;&nbsp;dom(<var>&mu;</var>) and |expr|(<var>&mu;</var>) is a well-formed cdt:List literal that represents the <a>empty term list</a>, <a>Unfold1</a>(<var>&mu;</var>, |var|, |expr|) is the empty multiset of solution mappings. Similarly, if |var|&nbsp;&notin;&nbsp;dom(<var>&mu;</var>) and |expr|(<var>&mu;</var>) is a well-formed cdt:Map literal that represents the <a>empty term map</a>, then <a>Unfold1</a>(<var>&mu;</var>, |var|, |expr|) is also the empty multiset.
      </p>

      <p>
        The operator for evaluating `Unfold2` is defined as follows.
      </p>

      <div class="defn">
        <p><b>Definition: <dfn id="dfn-Unfold2" style="font-style:normal">Unfold2</dfn></b></p>

          Let <var>&mu;</var> be a <a data-cite="SPARQL11-QUERY#defn_sparqlSolutionMapping">solution mapping</a>, <var>var<sub>1</sub></var> and <var>var<sub>2</sub></var> be two different <a data-cite="SPARQL11-QUERY#defn_QueryVariable">variables</a>, and |expr| be an <a data-cite="SPARQL11-QUERY#expressions">expression</a>.
          <br/>
          Then, Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|) is a multiset of solution mappings that is defined as follows:
        </p>
        <ul>
          <li>
            If <var>var<sub>1</sub></var>&nbsp;&notin;&nbsp;dom(<var>&mu;</var>), <var>var<sub>2</sub></var>&nbsp;&notin;&nbsp;dom(<var>&mu;</var>), and |expr|(<var>&mu;</var>) is a <a>well-formed cdt:List literal</a> such that the <a>term list</a>&nbsp;|L| represented by this literals is a nonempty, then
            <ul>
              <li>
                Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|) = { <var>&mu;</var> &cup; <var>&mu;<sub>|i|</sub></var> &cup; (<var>var<sub>2</sub></var>, |i|) | 1 &le; |i| &le; |n| }, where
                <br/>&nbsp; &nbsp; <var>&mu;<sub>|i|</sub></var> is the empty solution mapping if the element at the |i|-th position of |L| is <a>null</a>,
                <br/>&nbsp; &nbsp; otherwise, <var>&mu;<sub>|i|</sub></var> = (<var>var<sub>1</sub></var>, |term|) where |term| is element at the |i|-th position of |L|, and
                <br/>&nbsp; &nbsp; |n| is the number of elements in |L|,
              </li>
              <li>
                card[Unfold1(<var>&mu;</var>, |var|, |expr|)](<var>&mu;'</var>) = 1 for every <var>&mu;'</var>&nbsp;&isin;&nbsp;Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|), and
              </li>
              <li>
                card[Unfold1(<var>&mu;</var>, |var|, |expr|)](<var>&mu;'</var>) = 0 for every <var>&mu;'</var>&nbsp;&notin;&nbsp;Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|).
              </li>
            </ul>
          </li>
          <li>
            If <var>var<sub>1</sub></var>&nbsp;&notin;&nbsp;dom(<var>&mu;</var>), <var>var<sub>2</sub></var>&nbsp;&notin;&nbsp;dom(<var>&mu;</var>), and |expr|(<var>&mu;</var>) is a <a>well-formed cdt:List literal</a> that represents the <a>empty term list</a>, then Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|) is the empty multiset.
          </li>
          <li>
            If <var>var<sub>1</sub></var>&nbsp;&notin;&nbsp;dom(<var>&mu;</var>), <var>var<sub>2</sub></var>&nbsp;&notin;&nbsp;dom(<var>&mu;</var>), and |expr|(<var>&mu;</var>) is a <a>well-formed cdt:Map literal</a>, then
            <ul>
              <li>
                Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|) = { <var>&mu;</var> &cup; (<var>var<sub>1</sub></var>, |k|) &cup; <var>&mu;<sub>|v|</sub></var> | (|k|,|v|) is a <a>map entry</a> in |M| }, where
                <br/>&nbsp; &nbsp; <var>&mu;<sub>|v|</sub></var> is the empty solution mapping if |v| is <a>null</a>, otherwise, <var>&mu;<sub>|v|</sub></var> = (<var>var<sub>2</sub></var>, |v|), and
                <br/>&nbsp; &nbsp; |M| is the <a>term map</a> represented by the cdt:Map literal |expr|(<var>&mu;</var>),
              </li>
              <li>
                card[Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|)](<var>&mu;'</var>) = 1 for every <var>&mu;'</var>&nbsp;&isin;&nbsp;Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|),
              </li>
              <li>
                card[Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|)](<var>&mu;'</var>) = 0 for every <var>&mu;'</var>&nbsp;&notin;&nbsp;Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|).
              </li>
            </ul>
          </li>
          <li>
            If <var>var<sub>1</sub></var>&nbsp;&notin;&nbsp;dom(<var>&mu;</var>), <var>var<sub>2</sub></var>&nbsp;&notin;&nbsp;dom(<var>&mu;</var>), and |expr|(<var>&mu;</var>) is an error or an RDF term that is neither a well-formed cdt:List literal nor a well-formed cdt:Map literal, then
            <ul>
              <li>
                Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|) = {<var>&mu;</var>},
              </li>
              <li>
                card[Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|)](<var>&mu;'</var>) = 1 if <var>&mu;'</var>&nbsp;=&nbsp;<var>&mu;</var>, and
              </li>
              <li>
                card[Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|)](<var>&mu;'</var>) = 0 for every <var>&mu;'</var>&nbsp;&ne;&nbsp;<var>&mu;</var>.
              </li>
            </ul>
          </li>
          <li>
            If <var>var<sub>1</sub></var>&nbsp;&isin;&nbsp;dom(<var>&mu;</var>) or <var>var<sub>2</sub></var>&nbsp;&isin;&nbsp;dom(<var>&mu;</var>), then Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|) is undefined.
          </li>
        </ul>

        <p>
          Let <var>&Omega;</var> a multiset of solution mappings. We define:
          <br/>
          Unfold2(<var>&Omega;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|) = &#x22C3;<sub><var>&mu;</var> &isin; <var>&Omega;</var></sub> Unfold2(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|)
        </p>
      </div>

      <p class="note">
        While the given definition captures the case of cdt:List literals with the empty term list explicitly (see the second main bullet point in the definition), the case of cdt:Map literals with the <a>empty term map</a> are captured implicitly as part of the third main bullet point. In this case, the result of <a>Unfold2</a>(<var>&mu;</var>, <var>var<sub>1</sub></var>, <var>var<sub>2</sub></var>, |expr|) is also the empty multiset of solution mappings.
      </p>

    </section>

    <section id="unfold-semantics">
      <h2>Evaluation Semantics</h2>

      <p>
        The SPARQL specification defines a function <q>eval(D(G), algebra expression) as the evaluation of an algebra expression with respect to a dataset D having active graph G</q> (see <a data-cite="SPARQL11-QUERY#sparqlAlgebraEval">Section&nbsp;18.6</a> of [[SPARQL11-QUERY]]). The definition of this function is recursive. To cover algebra expressions that may contain the two new algebra symbols (`Unfold1` and `Unfold2`) the definition of this function needs to be extended with the following two additional cases.
      </p>

      <div class="defn">
        <p><b>Definition: <dfn id="dfn-evalUnfold" style="font-style:normal">Evaluation of Unfold1</dfn></b></p>
        <p>
          eval(D(G), `Unfold1(`<var style="font-style: normal">`P`</var>, <var style="font-style: normal">`var`</var>, <var style="font-style: normal">`expr`</var>`)`) = <a>Unfold1</a>(eval(D(G), <var style="font-style: normal">`P`</var>), <var style="font-style: normal">`var`</var>, <var style="font-style: normal">`expr`</var>)
        </p>
      </div>

      <div class="defn">
        <p><b>Definition: <dfn id="dfn-evalUnfold2" style="font-style:normal">Evaluation of Unfold2</dfn></b></p>
        <p>
          eval(D(G), `Unfold2(`<var style="font-style: normal">`P`</var>, <var style="font-style: normal">`var1`</var>, <var style="font-style: normal">`var2`</var>, <var style="font-style: normal">`expr`</var>`)`) = <a>Unfold2</a>(eval(D(G), <var style="font-style: normal">`P`</var>), <var style="font-style: normal">`var1`</var>, <var style="font-style: normal">`var2`</var>, <var style="font-style: normal">`expr`</var>)
        </p>
      </div>

    </section>

  </section>

  <section id="import-export-composite-values">
    <h1>Importing and Exporting of Composite Values</h1>

    <section class="informative">
      <h2>Motivation</h2>
      <p>
        In the normal handling of an RDF syntax, <a data-cite="RDF11-CONCEPTS#dfn-blank-node-identifier">blank node identifiers</a> are scoped to the current document, and any identifiers used in that document are merely a syntactic convenience for referencing blank nodes freshly allocated during parsing.
        As an example, consider the following snippet of Turtle syntax [[TURTLE]].
      </p>
        
      <pre id="load-renaming-blank-example"
         data-transform="updateExample"
         data-content-type="text/turtle"
         class="nohighlight example">
      <!--
      _:b1 ex:p4 "[ <http://example.org/alice>, <http://example.org/bob>, _:eve ]"^^cdt:List .
      -->
      </pre>
      
      <p>
        Parsing this data as Turtle will result in a single triple whose subject is a blank node (now dissociated from the `b1` identifier), and whose object is a <a>cdt:List literal</a> that represents a three-element <a>term list</a> in which the third element is a blank node.
        However, using a Turtle parser not aware of Composite Values will result in an object literal containing the substring "_:eve".
        This presents a challenge, as allowing values to reference specific blank nodes by identifier in this way would allow multiple documents to reference the same blank node, and might expose <em>internal</em> blank node identifiers as <em>external</em> identifiers (a form of unintentional <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-skolem-iri">skolemization</a>).
      </p>
        
      <p>
        The following sections describe requirements for conforming SPARQL systems that must be applied to composite values during their import into and export from datasets to support proper handling of blank nodes.
      </p>
    </section>

    <section>
      <h2>Importing Requirements</h2>
      <p>
        Conforming implementations MUST process <a>cdt:List literal</a>s and <a>cdt:Map literal</a>s during loading, replacing the substrings containing the serialized form of any blank nodes with identifier <var>id</var> with a blank node label <var>b</var>, such that
      </p>
      
      <ul>
        <li>within the scope of the document being processed, all occurrences of <var>id</var> are replaced with the same <var>b</var> value, and</li>
        <li>within the scope of the document being processed, two distinct <var>id</var> values are replaced with distinct <var>b</var> values, and</li>
        <li>
          if the format of the document being processed has a mechanism for explicitly identifying blank nodes outside of cdt:List and cdt:Map literals (e.g., `_:b1` syntax in N-Triples and in Turtle, `rdf:nodeID` in RDF/XML),
          and the blank node identifier <var>id</var> appears both inside and outside of such literals,
          and the parser for this document format emits a blank node <var>B</var> for occurrences of <var>id</var> outside of the literals,
          then the rewritten blank node label <var>b</var> MUST be a lexical form that maps to <var>B</var> in the lexical-to-value mapping (that is, <i><a>bnl2bn</a></i>(<var>id</var>) = <var>B</var>).
        </li>
      </ul>

      <p>
        Here, "loading" is any single process by which composite values enter a SPARQL system or RDF Dataset. This includes (but is not limited to):
      </p>

      <ul>
        <li>The parsing of a SPARQL Query string [[SPARQL11-QUERY]] or of a SPARQL Update string [[SPARQL11-UPDATE]], which may contain literals.</li>
        <li>The loading of RDF data via a SPARQL <a data-cite="SPARQL11-UPDATE#load">`LOAD`</a> operation [[SPARQL11-UPDATE]]</li>
        <li>The loading of RDF data via a single SPARQL graph store protocol request [[SPARQL11-HTTP-RDF-UPDATE]]</li>
        <li>The loading of RDF data via any single SPARQL <a data-cite="SPARQL11-QUERY#unnamedGraph">`FROM`</a> or <a data-cite="SPARQL11-QUERY#namedGraphs">`FROM NAMED`</a> clause [[SPARQL11-QUERY]] in systems that <a data-cite="SPARQL11-SERVICE-DESCRIPTION#sd-dereferencesuris">support the dereferencing and loading of RDF data specified for the dataset to be queried</a></li>
        <li>Importing of any RDF data to the internally-managed RDF dataset via means other than SPARQL Update statements [[SPARQL11-UPDATE]] or the SPARQL Graph Store HTTP Protocol [[SPARQL11-HTTP-RDF-UPDATE]]</li>
        <li>The loading of SPARQL Results via [[SPARQL11-FEDERATED-QUERY]]</li>
      </ul>

      <p>Loading the Turtle in <a href="#load-renaming-blank-example-simple"></a>, data with `_:b0` in a <a>cdt:List literal</a> MUST result in an (internal) dataset with a single triple whose object is a <a>cdt:List literal</a> containing a blank node whose identifier is NOT "b0" (<a href="#load-renaming-blank-example-simple-result"></a>):
      <pre id="load-renaming-blank-example-simple"
         title="Loading of a cdt:List literal with a blank node"
         data-transform="updateExample"
         data-content-type="text/turtle"
         class="nohighlight example">
      <!--
      ex:s ex:p1 "[ _:b0 ]"^^cdt:List .
      -->
      </pre>
      <pre id="load-renaming-blank-example-simple-result"
         title="Loading of a cdt:List literal with a blank node: Result"
         data-transform="updateExample"
         data-content-type="text/n-triples"
         class="nohighlight example">
      <!--
      <http://example.org/s> <http://example.org/p1> "[ _:b001 ]"^^<http://w3id.org/awslabs/neptune/SPARQL-CDTs/List> .
      -->
      </pre>

      <p>Evaluating a SPARQL Update in <a href="#load-renaming-blank-example-load-twice"></a> with two `INSERT DATA` operations with the same blank-node-containing <a>cdt:List literal</a> MUST result in the addition of two triples to the dataset in which the newly-added triples' <a>cdt:List literal</a>s contain different blank nodes and where those blank node identifiers MUST be different and MUST NOT be "b0" (<a href="#load-renaming-blank-example-load-twice-result"></a>):</p>
      <pre id="load-renaming-blank-example-load-twice"
         title="Repeated loading of cdt:List literals with a blank node"
         data-transform="updateExample"
         data-content-type="application/sparql-update"
         class="nohighlight example">
      <!--
      INSERT DATA { <s> <p2> "[ _:b0 ]"^^cdt:List } ;
      INSERT DATA { <s> <p2> "[ _:b0 ]"^^cdt:List } ;
      -->
      </pre>
      <pre id="load-renaming-blank-example-load-twice-result"
         title="Repeated loading of cdt:List literals with a blank node: Result"
         data-transform="updateExample"
         data-content-type="text/n-triples"
         class="nohighlight example">
      <!--
      <http://example.org/s> <http://example.org/p2> "[ _:b002 ]"^^<http://w3id.org/awslabs/neptune/SPARQL-CDTs/List> .
      <http://example.org/s> <http://example.org/p2> "[ _:b003 ]"^^<http://w3id.org/awslabs/neptune/SPARQL-CDTs/List> .
      -->
      </pre>

      <p>Loading the Turtle in <a href="#load-renaming-blank-example-consistent-ids"></a> with a triple with `_:b0` appearing in both the subject position and inside a <a>cdt:List literal</a> object MUST result in a dataset with a single triple whose subject is the same blank node as contained in the single-element <a>cdt:List literal</a> object, and where that blank node MUST NOT have the identifier "b0" (<a href="#load-renaming-blank-example-consistent-ids-result"></a>):</p>
      <pre id="load-renaming-blank-example-consistent-ids"
         title="Producing consistent blank node identifiers shared between a cdt:List literal and the RDF data that contains this literal"
         data-transform="updateExample"
         data-content-type="text/turtle"
         class="nohighlight example">
      <!--
      _:b0 ex:p3 "[ _:b0 ]"^^cdt:List .
      -->
      </pre>
      <pre id="load-renaming-blank-example-consistent-ids-result"
         title="Producing consistent blank node identifiers shared between a cdt:List literal and the RDF data that contains this literal: Result"
         data-transform="updateExample"
         data-content-type="text/n-triples"
         class="nohighlight example">
      <!--
      _:b004 <http://example.org/p3> "[ _:b004 ]"^^<http://w3id.org/awslabs/neptune/SPARQL-CDTs/List> .
      -->
      </pre>

      <p>Loading the Turtle in <a href="#load-renaming-blank-reuse"></a> with a triple with a <a>cdt:Map literal</a> containing two map entries, both having the same blank node value, MUST result in a dataset with a single triple whose <a>cdt:Map literal</a> object contains two map entries having the same blank node value, and whose identifier MUST NOT be "b0" (<a href="#load-renaming-blank-reuse-result"></a>):</p>
      <pre id="load-renaming-blank-reuse"
         title="Consistent rewriting of blank node identifiers that are used multiple times in a cdt:Map literal"
         data-transform="updateExample"
         data-content-type="text/turtle"
         class="nohighlight example">
      <!--
      ex:s ex:p3 "{ 'this': _:b0, 'again': _:b0 }"^^cdt:Map .
      -->
      </pre>
      <pre id="load-renaming-blank-reuse-result"
         title="Consistent rewriting of blank node identifiers that are used multiple times in a cdt:Map literal: Result"
         data-transform="updateExample"
         data-content-type="text/n-triples"
         class="nohighlight example">
      <!--
      <http://example.org/s> <http://example.org/p3> "{'this': _:b005,'again': _:b005}"^^<http://w3id.org/awslabs/neptune/SPARQL-CDTs/Map> .
      -->
      </pre>
    </section>

    <section>
      <h2>Exporting Requirements</h2>
      <p>
        Conforming implementations MUST process <a>cdt:List literal</a>s and <a>cdt:Map literal</a>s during export, replacing the substrings containing the serialized form of any blank nodes with identifier <var>id</var> with a blank node label <var>b</var>, such that
      </p>

      <ul>
        <li>within the scope of the document being serialized, all occurrences of <var>id</var> as a blank node identifier are replaced with the same <var>b</var> value (both inside and outside of composite values), and</li>
        <li>within the scope of the document being serialized, two distinct <var>id</var> values are replaced with distinct <var>b</var> values.</li>
      </ul>

      <p>
        Here, "exporting" is any single process by which composite values leave a SPARQL system or RDF Dataset. This includes (but is not limited to):
      </p>

      <ul>
        <li>Serializing SPARQL Results in a concrete syntax (such as [[SPARQL11-RESULTS-JSON]] or [[SPARQL11-RESULTS-CSV-TSV]])</li>
        <li>Serializing RDF results to a CONSTRUCT or DESCRIBE query in a concrete syntax (such as [[TURTLE]])</li>
        <li>Serializing the full or partial contents of an RDF dataset in a concrete syntax (such as [[RDF-12-N-QUADS]]) via [[SPARQL12-GRAPH-STORE-PROTOCOL]]</li>
        <li>Serializing the full or partial contents of an RDF dataset in a concrete syntax via means other than [[SPARQL12-GRAPH-STORE-PROTOCOL]]</li>
      </ul>

      <p>Exporting the dataset in <a href="#export-consistent-ids-turtle"></a> as Turtle MUST result in a document containing a single triple whose blank node subject has the same identifier as the blank node contained in the one-value <a>cdt:List literal</a> object (<a href="#export-consistent-ids-turtle-result"></a>):</p>
      <pre id="export-consistent-ids-turtle"
         title="Exporting consistent blank node identifiers shared between RDF and Composite Values"
         data-transform="updateExample"
         data-content-type="text/n-triples"
         class="nohighlight example">
      <!--
      _:b004 <http://example.org/p3> "[ _:b004 ]"^^<http://w3id.org/awslabs/neptune/SPARQL-CDTs/List> .
      -->
      </pre>
      <pre id="export-consistent-ids-turtle-result"
         title="Exporting consistent blank node identifiers shared between RDF and Composite Values: Result"
         data-transform="updateExample"
         data-content-type="text/turtle"
         class="nohighlight example">
      <!--
      _:xyz ex:p3 "[ _:xyz ]"^^cdt:List .
      -->
      </pre>

      <p>Similarly, serializing the query results from <a href="#export-consistent-ids-srj"></a> as [[SPARQL11-RESULTS-JSON]] MUST result in a document containing a single result where the <var>b</var> blank node has the same identifier as the blank node contained in the one-value <a>cdt:List literal</a> `list` value (<a href="#export-consistent-ids-srj-result"></a>):</p>
      <pre id="export-consistent-ids-srj"
         title="Exporting consistent blank node identifiers shared between RDF and Composite Values"
         data-transform="updateExample"
         data-content-type="application/sparql-query"
         class="nohighlight example">
      <!--
      SELECT ?b ?list WHERE {
        BIND(BNODE() AS ?b)
        BIND(cdt:List(?b) AS ?list)
      }
      -->
      </pre>
      <pre id="export-consistent-ids-srj-result"
         title="Exporting consistent blank node identifiers shared between RDF and Composite Values: Result"
         data-transform="updateExample"
         data-content-type="application/sparql-results+json"
         class="nohighlight example">
      <!--
{
  "head": {
    "vars": [ "b", "list" ]
  },
  "results": {
    "bindings": [
      {
        "b": { "type": "bnode", "value": "_:b123" }
        "list": {
          "datatype": "http://w3id.org/awslabs/neptune/SPARQL-CDTs/List",
          "type": "literal",
          "value": "[_:b123]"
        }
      }
    ]
  }
}
      -->
      </pre>
    </section>
      
  </section>

  <section class="appendix informative">
    <h2>IANA Considerations</h2>

    <p>TODO</p>

  </section>


  <section class="appendix">
    <h2>Complete EBNF Grammars</h2>

    <section class="appendix informative" id="cdt-ebnf">
      <h2>Composite Datatypes EBNF Grammar</h2>
      <p>
        The following is a complete grammar for composite datatype literals (i.e., literals that conform either to the <a>cdt:List datatype</a> or to the <a>cdt:Map datatype</a>). The EBNF used here is defined in XML 1.0 [[EBNF-NOTATION]].
      </p>
      <div data-include="../ebnf/cdt-literals.html"></div>
    </section>

    <section class="appendix informative" id="sparql-cdt-ebnf">
      <h2>SPARQL-CDT EBNF Grammar</h2>
      <p>
        The following is a complete grammar for the SPARQL language with the extensions for composite datatype literals as defined in this document. The EBNF used here is defined in XML 1.0 [[EBNF-NOTATION]].
      </p>
      <div data-include="../ebnf/sparql-cdt.html"></div>
    </section>

  </section>

<!--   <section class="appendix informative" id="issue-summary"> -->
    <!-- A list of issues will magically appear here -->
<!--   </section> -->

</body>
</html>
